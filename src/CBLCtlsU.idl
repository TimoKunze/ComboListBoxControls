//////////////////////////////////////////////////////////////////////
/// \mainpage ComboListBoxControls Documentation
///
/// \section intro_sec Introduction
///
/// %ComboListBoxControls is a collection of combo and list box ActiveX controls. The \c ComboBox control
/// wraps the \c ComboBox window class, the \c DriveComboBox and \c ImageComboBox controls wrap the
/// \c ComboBoxEx32 window class and the \c ListBox control wraps the \c ListBox window class.\n
/// The controls are optimized for Visual Basic 6.0, but should also work in any other environment that
/// supports COM controls.
///
/// \section basics_sec Basics
///
/// The controls superclass the mentioned native window classes of Windows: \c ComboBox, \c ComboBoxEx32
/// and \c ListBox. Although I tried to wrap all features of these window classes (status: Windows 10),
/// some things may be missing. In these cases you usually may use the Win32 API and handle the controls as
/// native windows of the corresponding class. One of my goals was it to create controls that may be
/// controlled via API as well as via the classes that I implemented.
///
/// \section reqs_sec Requirements
///
/// %ComboListBoxControls Unicode runs on the following operating systems:
/// - Windows XP (SP3 or later)
/// - Windows Server 2003 (SP2 or later)
/// - Windows Vista (SP2 or later)
/// - Windows Server 2008 (SP2 or later)
/// - Windows 7 (SP1 or later)
/// - Windows Server 2008 R2 (SP1 or later)
/// - Windows 8
/// - Windows Server 2012
/// - Windows 8.1
/// - Windows Server 2012 R2
/// - Windows 10
/// - Windows Server 2016
/// - Systems supported by Wine (Wine is a Win32 subsystem for alternative operating systems) - <strong>limited support</strong>
/// - ReactOS (a free Windows XP clone) - <strong>limited support</strong>
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system tagged with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// There's no entitlement to support. Period. However, you have good chances to get help if you post your
/// questions on <a href="https://github.com/TimoKunze/ComboListBoxControls">GitHub</a> or in the
/// <a href="https://www.timosoft-software.de/forum/viewforum.php?f=40">forums</a>.\n
/// Also the project is open source, so feel free to have a look at the source code. You may modify it, but
/// please consider sharing your changes with the rest of the world.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2009-2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian LÃ¼tgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is the \c Font property ignored?</strong>\n
/// It isn't. My controls have a property \c UseSystemFont which defaults to \c True. This property tells
/// the control to use the system font rather than the font set by the \c Font property.\n
/// Why is this property's default \c True? Well, if I set system wide settings (like fonts) I expect all
/// applications to follow them. Unfortunately ignoring system wide settings seems to be trendy, so see
/// my decision as an educational measure.
///
/// <strong>2. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace CBLCtlsLibU
/// \brief <em>Contains COM definitions for the controls' public interfaces</em>
///
/// This is the Unicode version of the ComboListBoxControls COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(FCCB83BF-E483-4317-9FF2-A460758238B5),
	version(1.5),
	helpstring("TimoSoft ComboListBoxControls 1.5 (Unicode)")
]
library CBLCtlsLibU
{
	importlib("stdole2.tlb");


	/// \brief <em>Constants used with the \c Appearance properties</em>
	///
	/// \sa IComboBox::Appearance, IListBox::Appearance
	// \sa IComboBox::Appearance, IDriveComboBox::Appearance, IImageComboBox::Appearance,
	//     IListBox::Appearance
	[helpstring("Constants used with the 'Appearance' properties.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight,
		/// \brief Let the control decide about the outer border style
		///
		/// \remarks This value can't be set at runtime and is valid for the \c ComboBox control only.
		[helpstring("The control decides itself which border to draw. This value can't be set at runtime and is valid for the 'ComboBox' control only.")]
		aDefault
	} AppearanceConstants;

	/// \brief <em>Constants used with the \c BorderStyle properties</em>
	///
	/// \sa IComboBox::BorderStyle, IListBox::BorderStyle
	// \sa IComboBox::BorderStyle, IDriveComboBox::BorderStyle, IImageComboBox::BorderStyle,
	//     IListBox::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' properties.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used with the \c CharacterConversion properties</em>
	///
	/// \sa IComboBox::CharacterConversion
	[helpstring("Constants used with the 'CharacterConversion' properties.")]
	typedef enum CharacterConversionConstants {
		/// \brief The control does not convert anything
		[helpstring("The control does not convert anything.")]
		ccNone,
		/// \brief The control converts all characters to lowercase as they are typed into the control
		[helpstring("The control converts all characters to lowercase as they are typed into the control.")]
		ccLowerCase,
		/// \brief The control converts all characters to uppercase as they are typed into the control
		[helpstring("The control converts all characters to uppercase as they are typed into the control.")]
		ccUpperCase
	} CharacterConversionConstants;

	/// \brief <em>Constants used with the \c CompareItems event</em>
	///
	/// \sa _IComboBoxEvents::CompareItems, _IListBoxEvents::CompareItems
	[helpstring("Constants used with the 'CompareItems' event.")]
	typedef enum CompareResultConstants {
		/// \brief The first item should precede the second
		[helpstring("The first item should precede the second.")]
		crFirstSecond = -1,
		/// \brief The two items are equivalent
		[helpstring("The two items are equivalent.")]
		crEqual = 0,
		/// \brief The first item should follow the second
		[helpstring("The first item should follow the second.")]
		crSecondFirst = 1
	} CompareResultConstants;

	/// \brief <em>Flags used with the \c DisabledEvents properties</em>
	///
	/// \sa IComboBox::DisabledEvents, IDriveComboBox::DisabledEvents, IImageComboBox::DisabledEvents,
	///     IListBox::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' properties. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MouseEnter, \c MouseHover,
		/// \c MouseLeave, \c ItemMouseEnter, \c ItemMouseLeave, \c MouseMove, \c MouseWheel
		///
		/// \sa _IComboBoxEvents::MouseDown, _IComboBoxEvents::MouseUp, _IComboBoxEvents::MouseEnter,
		///     _IComboBoxEvents::MouseHover, _IComboBoxEvents::MouseLeave, _IComboBoxEvents::MouseMove,
		///     _IComboBoxEvents::MouseWheel,\n
		///     _IDriveComboBoxEvents::MouseDown, _IDriveComboBoxEvents::MouseUp,
		///     _IDriveComboBoxEvents::MouseEnter, _IDriveComboBoxEvents::MouseHover,
		///     _IDriveComboBoxEvents::MouseLeave, _IDriveComboBoxEvents::MouseMove,
		///     _IDriveComboBoxEvents::MouseWheel,\n
		///     _IImageComboBoxEvents::MouseDown, _IImageComboBoxEvents::MouseUp,
		///     _IImageComboBoxEvents::MouseEnter, _IImageComboBoxEvents::MouseHover,
		///     _IImageComboBoxEvents::MouseLeave, _IImageComboBoxEvents::MouseMove,
		///     _IImageComboBoxEvents::MouseWheel,\n
		///     _IListBoxEvents::MouseDown, _IListBoxEvents::MouseUp, _IListBoxEvents::MouseEnter,
		///     _IListBoxEvents::MouseHover, _IListBoxEvents::MouseLeave, _IListBoxEvents::ItemMouseEnter,
		///     _IListBoxEvents::ItemMouseLeave, _IListBoxEvents::MouseMove,
		///     _IListBoxEvents::MouseWheel
		[helpstring("Disables the following events: MouseDown, MouseUp, MouseEnter, MouseHover, MouseLeave, ItemMouseEnter, ItemMouseLeave, MouseMove, MouseWheel")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _IComboBoxEvents::Click, _IComboBoxEvents::DblClick, _IComboBoxEvents::MClick,
		///     _IComboBoxEvents::MDblClick, _IComboBoxEvents::RClick, _IComboBoxEvents::RDblClick,
		///     _IComboBoxEvents::XClick, _IComboBoxEvents::XDblClick,
		///     _IDriveComboBoxEvents::Click, _IDriveComboBoxEvents::DblClick, _IDriveComboBoxEvents::MClick,
		///     _IDriveComboBoxEvents::MDblClick, _IDriveComboBoxEvents::RClick,
		///     _IDriveComboBoxEvents::RDblClick, _IDriveComboBoxEvents::XClick,
		///     _IDriveComboBoxEvents::XDblClick,
		///     _IImageComboBoxEvents::Click, _IImageComboBoxEvents::DblClick, _IImageComboBoxEvents::MClick,
		///     _IImageComboBoxEvents::MDblClick, _IImageComboBoxEvents::RClick,
		///     _IImageComboBoxEvents::RDblClick, _IImageComboBoxEvents::XClick,
		///     _IImageComboBoxEvents::XDblClick,
		///     _IListBoxEvents::Click, _IListBoxEvents::DblClick, _IListBoxEvents::MClick,
		///     _IListBoxEvents::MDblClick, _IListBoxEvents::RClick, _IListBoxEvents::RDblClick,
		///     _IListBoxEvents::XClick, _IListBoxEvents::XDblClick
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Mouse events concerning the drop-down list box control won't be fired
		///
		/// The following events won't be fired: \c ListMouseDown, \c ListMouseUp, \c ListMouseMove,
		/// \c ListMouseWheel, \c ItemMouseEnter, \c ItemMouseLeave
		///
		/// \sa _IComboBoxEvents::ListMouseDown, _IComboBoxEvents::ListMouseUp,
		///     _IComboBoxEvents::ListMouseMove, _IComboBoxEvents::ListMouseWheel,
		///     _IComboBoxEvents::ItemMouseEnter, _IComboBoxEvents::ItemMouseLeave,
		///     _IDriveComboBoxEvents::ListMouseDown, _IDriveComboBoxEvents::ListMouseUp,
		///     _IDriveComboBoxEvents::ListMouseMove, _IDriveComboBoxEvents::ListMouseWheel,
		///     _IDriveComboBoxEvents::ItemMouseEnter, _IDriveComboBoxEvents::ItemMouseLeave,
		///     _IImageComboBoxEvents::ListMouseDown, _IImageComboBoxEvents::ListMouseUp,
		///     _IImageComboBoxEvents::ListMouseMove, _IImageComboBoxEvents::ListMouseWheel,
		///     _IImageComboBoxEvents::ItemMouseEnter, _IImageComboBoxEvents::ItemMouseLeave
		[helpstring("Disables the following events: ListMouseDown, ListMouseUp, ListMouseMove, ListMouseWheel, ItemMouseEnter, ItemMouseLeave")]
		deListBoxMouseEvents = 0x04,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _IComboBoxEvents::KeyDown, _IComboBoxEvents::KeyUp, _IComboBoxEvents::KeyPress,
		///     _IDriveComboBoxEvents::KeyDown, _IDriveComboBoxEvents::KeyUp, _IDriveComboBoxEvents::KeyPress,
		///     _IImageComboBoxEvents::KeyDown, _IImageComboBoxEvents::KeyUp, _IImageComboBoxEvents::KeyPress,
		///     _IListBoxEvents::KeyDown, _IListBoxEvents::KeyUp, _IListBoxEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief Events concerning item-insertions won't be fired
		///
		/// The following events won't be fired: \c InsertingItem, \c InsertedItem
		///
		/// \sa _IComboBoxEvents::InsertingItem, _IComboBoxEvents::InsertedItem,
		///     _IDriveComboBoxEvents::InsertingItem, _IDriveComboBoxEvents::InsertedItem,
		///     _IImageComboBoxEvents::InsertingItem, _IImageComboBoxEvents::InsertedItem,
		///     _IListBoxEvents::InsertingItem, _IListBoxEvents::InsertedItem
		[helpstring("Disables the following events: InsertingItem, InsertedItem")]
		deItemInsertionEvents = 0x20,
		/// \brief Events concerning item-deletions won't be fired
		///
		/// The following events won't be fired: \c RemovingItem, \c RemovedItem
		///
		/// \sa _IComboBoxEvents::RemovingItem, _IComboBoxEvents::RemovedItem,
		///     _IDriveComboBoxEvents::InsertingItem, _IDriveComboBoxEvents::InsertedItem,
		///     _IImageComboBoxEvents::InsertingItem, _IImageComboBoxEvents::InsertedItem,
		///     _IListBoxEvents::InsertingItem, _IListBoxEvents::InsertedItem
		[helpstring("Disables the following events: RemovingItem, RemovedItem")]
		deItemDeletionEvents = 0x40,
		/// \brief The \c FreeItemData event won't be fired
		///
		/// The following event won't be fired: \c FreeItemData
		///
		/// \sa _IComboBoxEvents::FreeItemData, _IDriveComboBoxEvents::FreeItemData,
		///     _IImageComboBoxEvents::FreeItemData, _IListBoxEvents::FreeItemData
		[helpstring("Disables the following event: FreeItemData")]
		deFreeItemData = 0x80,
		/// \brief The \c BeforeDrawText event won't be fired
		///
		/// The following event won't be fired: \c BeforeDrawText
		///
		/// \sa _IComboBoxEvents::BeforeDrawText, _IImageComboBoxEvents::BeforeDrawText
		[helpstring("Disables the following event: BeforeDrawText")]
		deBeforeDrawText = 0x400,
		/// \brief The \c TextChanged event won't be fired
		///
		/// The following events won't be fired: \c TextChanged
		///
		/// \sa _IComboBoxEvents::TextChanged, _IImageComboBoxEvents::TextChanged
		[helpstring("Disables the following event: TextChanged")]
		deTextChangedEvents = 0x1000,
		/// \brief Click events concerning the drop-down list box control won't be fired
		///
		/// The following events won't be fired: \c ListClick
		///
		/// \sa _IDriveComboBoxEvents::ListClick, _IImageComboBoxEvents::ListClick
		[helpstring("Disables the following events: ListClick")]
		deListBoxClickEvents = 0x4000,
		/// \brief Events concerning item selection changes won't be fired
		///
		/// The following events won't be fired: \c BeginSelectionChange, \c SelectionCanceled,
		/// \c SelectionChanging
		///
		/// \sa _IComboBoxEvents::SelectionCanceled, _IComboBoxEvents::SelectionChanging,
		///     _IDriveComboBoxEvents::SelectionCanceled, _IDriveComboBoxEvents::BeginSelectionChange,
		///     _IDriveComboBoxEvents::SelectionChanging,
		///     _IImageComboBoxEvents::SelectionCanceled, _IImageComboBoxEvents::BeginSelectionChange,
		///     _IImageComboBoxEvents::SelectionChanging
		[helpstring("Disables the following events: BeginSelectionChange, SelectionCanceled, SelectionChanging")]
		deSelectionChangingEvents = 0x40000,
		/// \brief The \c ProcessCharacterInput and the \c ProcessKeyStroke events won't be fired
		///
		/// The following events won't be fired: \c ProcessCharacterInput, \c ProcessKeyStroke
		///
		/// \attention Setting or clearing this flag destroys and recreates the control window.
		///
		/// \sa _IListBoxEvents::ProcessCharacterInput, _IListBoxEvents::ProcessKeyStroke
		[helpstring("Disables the following events: ProcessCharacterInput, ProcessKeyStroke. Setting or clearing this flag destroys and recreates the control window.")]
		deProcessKeyboardInput = 0x100000
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IDriveComboBox::DisplayNameStyle property</em>
	///
	/// \sa IDriveComboBox::DisplayNameStyle
	[helpstring("Constants used with the 'DriveComboBox.DisplayNameStyle' property.")]
	typedef enum DisplayNameStyleConstants {
		/// \brief Displays drives with the drive letters only
		[helpstring("Displays drives with the drive letters only.")]
		dnsDriveLetter,
		/// \brief Displays drives with the drive letters (followed by a colon) only
		[helpstring("Displays drives with the drive letters (followed by a colon) only.")]
		dnsDriveLetterWithColon,
		/// \brief Displays drives with the volume name only
		[helpstring("Displays drives with the volume name only.")]
		dnsVolumeName,
		/// \brief Displays drives like the \c DriveListBox control of Visual Basic 6.0 (e. g. "C: [Windows]")
		[helpstring("Displays drives like the \c DriveListBox control of Visual Basic 6.0 (e. g. ""C: [Windows]"").")]
		dnsVB6Style,
		/// \brief Displays drives like Windows Explorer
		[helpstring("Displays drives like Windows Explorer.")]
		dnsShellStyle
	} DisplayNameStyleConstants;

	/// \brief <em>Flags used with the \c IDriveComboBox::DisplayedDriveTypes property</em>
	///
	/// \sa IDriveComboBox::DisplayedDriveTypes
	[helpstring("Flags used with the 'DriveComboBox.DisplayedDriveTypes' property. They can be combined.")]
	typedef enum DriveTypeConstants {
		/// \brief Drives, for which the drive type could not be determined, are displayed
		[helpstring("Drives, for which the drive type could not be determined, are displayed.")]
		dtUnknown = 0x01,
		/// \brief Drives, for which the root path is invalid (for example, there is no volume mounted at the specified path), are displayed
		[helpstring("Drives, for which the root path is invalid (for example, there is no volume mounted at the specified path), are displayed.")]
		dtOther = 0x02,
		/// \brief Drives that have fixed media (for example, hard drives or flash drives) are displayed
		[helpstring("Drives that have fixed media (for example, hard drives or flash drives) are displayed.")]
		dtFixed = 0x04,
		/// \brief Drives for optical media (for example, CD-ROM drives) are displayed
		[helpstring("Drives for optical media (for example, CD-ROM drives) are displayed.")]
		dtOptical = 0x08,
		/// \brief Drives for any removable media (for example, floppy drives, thumb drives, or flash card readers) are displayed
		[helpstring("Drives for any removable media (for example, floppy drives, thumb drives, or flash card readers) are displayed.")]
		dtRemovable = 0x10,
		/// \brief Remote (network) drives are displayed
		[helpstring("Remote (network) drives are displayed.")]
		dtRemote = 0x20,
		/// \brief RAM disk drives are displayed
		[helpstring("RAM disk drives are displayed.")]
		dtRAMDisk = 0x40,
		/// \brief Any drive is displayed
		[helpstring("Any drive is displayed.")]
		dtAll = (dtUnknown | dtOther | dtFixed | dtOptical | dtRemovable | dtRemote | dtRAMDisk)
	} DriveTypeConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used with the \c DropDownKey properties</em>
	///
	/// \sa IComboBox::DropDownKey, IDriveComboBox::DropDownKey, IImageComboBox::DropDownKey
	[helpstring("Constants used with the 'DropDownKey' properties.")]
	typedef enum DropDownKeyConstants {
		/// \brief The F4 key is used to open the drop-down window while the down arrow key is used to change the selection
		[helpstring("The F4 key is used to open the drop-down window while the down arrow key is used to change the selection.")]
		ddkF4,
		/// \brief The down arrow key is used to open the drop-down window while the F4 key has no function
		[helpstring("The down arrow key is used to open the drop-down window while the F4 key has no function.")]
		ddkDownArrow
	} DropDownKeyConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _IComboBoxEvents::MouseDown, _IComboBoxEvents::MouseEnter,
	///     _IComboBoxEvents::MouseHover, _IComboBoxEvents::MouseLeave,
	///     _IComboBoxEvents::MouseMove, _IComboBoxEvents::MouseUp,
	///     _IComboBoxEvents::XClick, _IComboBoxEvents::XDblClick,\n
	///     _IDriveComboBoxEvents::MouseDown, _IDriveComboBoxEvents::MouseEnter,
	///     _IDriveComboBoxEvents::MouseHover, _IDriveComboBoxEvents::MouseLeave,
	///     _IDriveComboBoxEvents::MouseMove, _IDriveComboBoxEvents::MouseUp,
	///     _IDriveComboBoxEvents::XClick, _IDriveComboBoxEvents::XDblClick,\n
	///     _IImageComboBoxEvents::MouseDown, _IImageComboBoxEvents::MouseEnter,
	///     _IImageComboBoxEvents::MouseHover, _IImageComboBoxEvents::MouseLeave,
	///     _IImageComboBoxEvents::MouseMove, _IImageComboBoxEvents::MouseUp,
	///     _IImageComboBoxEvents::XClick, _IImageComboBoxEvents::XDblClick,\n
	///     _IListBoxEvents::MouseDown, _IListBoxEvents::MouseEnter,
	///     _IListBoxEvents::MouseHover, _IListBoxEvents::MouseLeave,
	///     _IListBoxEvents::MouseMove, _IListBoxEvents::MouseUp,
	///     _IListBoxEvents::XClick, _IListBoxEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Constants used with the \c Filter properties</em>
	///
	/// \sa IComboBoxItems::Filter, IDriveComboBoxItems::Filter, IImageComboBoxItems::Filter,
	///     IListBoxItems::Filter
	[helpstring("Constants used with the 'Filter' properties.")]
	typedef enum FilteredPropertyConstants {
		/// \brief Retrieve or set the filter that filters by the \c IconIndex property
		///
		/// \sa IDriveComboBoxItem::IconIndex, IImageComboBoxItem::IconIndex
		[helpstring("Retrieve or set the filter that filters by the 'IconIndex' property.")]
		fpIconIndex = 4,
		/// \brief Retrieve or set the filter that filters by the \c Indent property
		///
		/// \sa IDriveComboBoxItem::Indent, IImageComboBoxItem::Indent
		[helpstring("Retrieve or set the filter that filters by the 'Indent' property.")]
		fpIndent = 5,
		/// \brief Retrieve or set the filter that filters by the \c Index property
		///
		/// \sa IComboBoxItem::Index, IDriveComboBoxItem::Index, IImageComboBoxItem::Index, IListBoxItem::Index
		[helpstring("Retrieve or set the filter that filters by the 'Index' property.")]
		fpIndex = 6,
		/// \brief Retrieve or set the filter that filters by the \c ItemData property
		///
		/// \sa IComboBoxItem::ItemData, IDriveComboBoxItem::ItemData, IImageComboBoxItem::ItemData,
		///     IListBoxItem::ItemData
		[helpstring("Retrieve or set the filter that filters by the 'ItemData' property.")]
		fpItemData = 7,
		/// \brief Retrieve or set the filter that filters by the \c OverlayIndex property
		///
		/// \sa IDriveComboBoxItem::OverlayIndex, IImageComboBoxItem::OverlayIndex
		[helpstring("Retrieve or set the filter that filters by the 'OverlayIndex' property.")]
		fpOverlayIndex = 8,
		/// \brief Retrieve or set the filter that filters by the \c Selected property
		///
		/// \sa IListBoxItem::Selected
		[helpstring("Retrieve or set the filter that filters by the 'Selected' property.")]
		fpSelected = 9,
		/// \brief Retrieve or set the filter that filters by the \c Text property
		///
		/// \sa IComboBoxItem::Text, IDriveComboBoxItem::Text, IImageComboBoxItem::Text, IListBoxItem::Text
		[helpstring("Retrieve or set the filter that filters by the 'Text' property.")]
		fpText = 11,
		/// \brief Retrieve or set the filter that filters by the \c SelectedIconIndex property
		///
		/// \sa IDriveComboBoxItem::SelectedIconIndex, IImageComboBoxItem::SelectedIconIndex
		[helpstring("Retrieve or set the filter that filters by the 'SelectedIconIndex' property.")]
		fpSelectedIconIndex = 14,
		/// \brief Retrieve or set the filter that filters by the \c DriveType property
		///
		/// \sa IDriveComboBoxItem::DriveType
		[helpstring("Retrieve or set the filter that filters by the 'DriveType' property.")]
		fpDriveType = 18,
		/// \brief Retrieve or set the filter that filters by the \c Path property
		///
		/// \sa IDriveComboBoxItem::Path
		[helpstring("Retrieve or set the filter that filters by the 'Path' property.")]
		fpPath = 19
	} FilteredPropertyConstants;

	/// \brief <em>Constants used with the \c FilterType properties</em>
	///
	/// \sa IComboBoxItems::FilterType, IListBoxItems::FilterType
	[helpstring("Constants used with the 'FilterType' properties.")]
	typedef enum FilterTypeConstants {
		/// \brief The filter is deactivated
		[helpstring("The filter is deactivated.")]
		ftDeactivated,
		/// \brief An item must match this filter to be in the collection
		[helpstring("An item must match this filter to be in the collection.")]
		ftIncluding,
		/// \brief An item must not match this filter to be in the collection
		[helpstring("An item must not match this filter to be in the collection.")]
		ftExcluding
	} FilterTypeConstants;

	/// \brief <em>Flags used with the \c IDriveComboBox::HandleOLEDragDrop property</em>
	///
	/// \sa IDriveComboBox::HandleOLEDragDrop
	[helpstring("Flags used with the 'DriveComboBox.HandleOLEDragDrop' property.")]
	typedef enum HandleOLEDragDropConstants {
		/// \brief The control automatically initiates drag'n'drop operations if the user drags an item
		[helpstring("The control automatically initiates drag'n'drop operations if the user drags an item.")]
		hoddSourcePart = 0x01,
		/// \brief Data being dragged (and maybe dropped) over the control is handled automatically
		///
		/// If this flag is set, the control reacts to data being dragged and maybe dropped onto a drive item.
		[helpstring("Data being dragged (and maybe dropped) over the control is handled automatically.")]
		hoddTargetPart = 0x02
	} HandleOLEDragDropConstants;

	/// \brief <em>Flags used with the \c HitTest methods</em>
	///
	/// \sa IComboBox::HitTest, IDriveComboBox::HitTest, IImageComboBox::HitTest, IListBox::HitTest
	[helpstring("Flags used with the 'HitTest' methods.")]
	typedef enum HitTestConstants {
		/// \brief Not over an item
		///
		/// The specified point lies inside the control's client area, but is not over an item.
		[helpstring("The specified point lies inside the control's client area, but is not over an item.")]
		htNotOverItem = 0x00000001,
		/// \brief On an item
		///
		/// The specified point lies on an item.
		[helpstring("The specified point lies on an item.")]
		htItem = 0x00000046,
		/// \brief Above the control's client area
		///
		/// The specified point lies above the control's client area.
		[helpstring("The specified point lies above the control's client area.")]
		htAbove = 0x00000100,
		/// \brief Below the control's client area
		///
		/// The specified point lies below the control's client area.
		[helpstring("The specified point lies below the control's client area.")]
		htBelow = 0x00000200,
		/// \brief To the right of the control's client area
		///
		/// The specified point lies to the right of the control's client area.
		[helpstring("The specified point lies to the right of the control's client area.")]
		htToRight = 0x00000400,
		/// \brief To the left of the control's client area
		///
		/// The specified point lies to the left of the control's client area.
		[helpstring("The specified point lies to the left of the control's client area.")]
		htToLeft = 0x00000800,
		/// \brief On the text box portion
		///
		/// The specified point lies on the combo box control's text box portion.
		///
		/// \remarks This value is invaid for list box controls.
		[helpstring("The specified point lies on the combo box control's text box portion.")]
		htTextBoxPortion = 0x01000000,
		/// \brief On the combo box portion
		///
		/// The specified point lies on the combo box control's combo box portion.
		///
		/// \remarks This value is invaid for list box controls.
		[helpstring("The specified point lies on the combo box control's combo box portion.")]
		htComboBoxPortion = 0x02000000
	} HitTestConstants;

	/// \brief <em>Constants used with the \c IconVisibility property</em>
	///
	/// \sa IDriveComboBox::IconVisibility, IImageComboBox::IconVisibility
	[helpstring("Constants used with the 'IconVisibility' property.")]
	typedef enum IconVisibilityConstants {
		/// \brief The icons are displayed
		[helpstring("The icons are displayed.")]
		ivVisible,
		/// \brief The icons are not displayed, but the item's text is indented as if the icons were displayed
		[helpstring("The icons are not displayed, but the item's text is indented as if the icons were displayed.")]
		ivHiddenButIndent,
		/// \brief The icons are not displayed
		[helpstring("The icons are not displayed.")]
		ivHiddenDontIndent,
	} IconVisibilityConstants;

	/// \brief <em>Constants used with the \c hImageList properties</em>
	///
	/// \sa IDriveComboBox::hImageList, IDriveComboBox::hImageList, IImageComboBox::hImageList,
	///     IListBox::hImageList
	[helpstring("Constants used with the 'hImageList' properties.")]
	typedef enum ImageListConstants {
		/// \brief Identifies the image list containing the items' icons
		///
		/// Identifies the image list containing the items' icons. If this image list is set to 0, no icons are
		/// drawn.
		///
		/// \sa IDriveComboBoxItem::IconIndex, IDriveComboBoxItem::SelectedIconIndex,
		///     IDriveComboBoxItem::OverlayIndex,
		///     IImageComboBoxItem::IconIndex, IImageComboBoxItem::SelectedIconIndex,
		///     IImageComboBoxItem::OverlayIndex
		[helpstring("Identifies the image list containing the items' icons.")]
		ilItems = 1,
		/// \brief Identifies the image list containing the items' icons used for Aero OLE drag images
		///
		/// Identifies the image list containing the items' icons used when icons with a high resolution are
		/// required. Currently the only usage of this image list is the creation of Aero OLE drag images.\n
		/// If this image list is set to 0, the \c ilItems image list is used.
		///
		/// \sa IListBox::SupportOLEDragImages, IListBox::OLEDrag, _IListBoxEvents::ItemGetDisplayInfo
		[helpstring("Identifies the image list containing the items' icons used for Aero OLE drag images.")]
		ilHighResolution = 4
	} ImageListConstants;

	/// \brief <em>Constants used with the \c IMEMode properties</em>
	///
	/// \sa IComboBox::IMEMode, IDriveComboBox::IMEMode, IImageComboBox::IMEMode, IListBox::IMEMode
	[helpstring("Constants used with the 'IMEMode' properties.")]
	typedef enum IMEModeConstants {
		/// \brief Use the same IME settings as the control's parent
		[helpstring("Inherit the IME status from the control's parent.")]
		imeInherit = -1,
		/// \brief Don't change anything on the control's default IME settings
		[helpstring("Leaves the control's IME status untouched.")]
		imeNoControl = 0,
		/// \brief Set the control's IME status to "on"
		[helpstring("Sets the control's IME status to \"on\".")]
		imeOn = 1,
		/// \brief Set the control's IME status to "off"
		[helpstring("Sets the control's IME status to \"off\".")]
		imeOff = 2,
		/// \brief Don't use IME
		[helpstring("Disables IME for the control.")]
		imeDisable = 3,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Hiragana Double-Byte Characters\" (Japanese IME only).")]
		imeHiragana = 4,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Double-Byte Characters\" (Japanese IME only).")]
		imeKatakana = 5,
		/// \brief Set the control's IME status to "Katakana Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Single-Byte Characters\" (Japanese IME only).")]
		imeKatakanaHalf = 6,
		/// \brief Set the control's IME status to "Alphanumeric Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Double-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlphaFull = 7,
		/// \brief Set the control's IME status to "Alphanumeric Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Single-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlpha = 8,
		/// \brief Set the control's IME status to "Hangul Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Single-Byte Characters\" (Korean IME only).")]
		imeHangulFull = 9,
		/// \brief Set the control's IME status to "Hangul Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Double-Byte Characters\" (Korean IME only).")]
		imeHangul = 10
	} IMEModeConstants;

	/// \brief <em>Constants that may be used with the \c SetInsertMarkPosition and \c GetInsertMarkPosition methods</em>
	///
	/// Constants that may be used for the \c relativePosition parameter of the \c SetInsertMarkPosition
	/// and \c GetInsertMarkPosition methods.
	///
	/// \sa IComboBox::SetListInsertMarkPosition, IImageComboBox::SetListInsertMarkPosition,
	///     IListBox::SetInsertMarkPosition,
	///     IComboBox::GetListInsertMarkPosition, IImageComboBox::GetListInsertMarkPosition,
	///     IListBox::GetInsertMarkPosition
	[helpstring("Constants that may be used for the 'relativePosition' parameter of the 'SetInsertMarkPosition' and 'GetInsertMarkPosition' methods.")]
	typedef enum InsertMarkPositionConstants {
		/// \brief The insertion mark is or will be removed
		[helpstring("The insertion mark is or will be removed.")]
		impNowhere = 0,
		/// \brief The insertion mark is or will be placed before the item
		[helpstring("The insertion mark is or will be placed before the item.")]
		impBefore = 1,
		/// \brief The insertion mark is or will be placed after the item
		[helpstring("The insertion mark is or will be placed after the item.")]
		impAfter = 2,
		/// \brief The insertion mark won't be (re-)moved
		[helpstring("The insertion mark won't be (re-)moved.")]
		impDontChange = 3
	} InsertMarkPositionConstants;

	/// \brief <em>Constants used with the \c InsertMarkStyle properties</em>
	///
	/// \sa IListBox::InsertMarkStyle
	[helpstring("Constants used with the 'InsertMarkStyle' properties.")]
	typedef enum InsertMarkStyleConstants {
		/// \brief The system's native insertion mark style is used
		///
		/// \remarks With this style, the insertion mark is drawn onto the control's parent window and will
		///          vanish if this window is redrawn.
		[helpstring("The system's native insertion mark style is used. With this style, the insertion mark is drawn onto the control's parent window and will vanish if this window is redrawn.")]
		imsNative,
		/// \brief An improved insertion mark style similar to this of the list view control is used
		///
		/// \remarks With this style, the insertion mark is drawn into the control's window and won't
		///          vanish if this window is redrawn.
		[helpstring("An improved insertion mark style similar to this of the list view control is used. With this style, the insertion mark is drawn into the control's window and won't vanish if this window is redrawn.")]
		imsImproved
	} InsertMarkStyleConstants;

	/// \brief <em>Constants used to identify items within an \c IComboBoxItems, \c IDriveComboBoxItems, \c IImageComboBoxItems or \c IListBoxItems collection</em>
	///
	/// \sa IComboBoxItems, IDriveComboBoxItems, IImageComboBoxItems, IListBoxItems
	[helpstring("Constants used to identify items within a 'ComboBoxItems', 'DriveComboBoxItems', 'ImageComboBoxItems' or 'ListBoxItems' collection.")]
	typedef enum ItemIdentifierTypeConstants {
		/// \brief The item is identified by an unique ID
		///
		/// An item's ID will never change.
		///
		/// \sa IComboBoxItem::ID, IDriveComboBoxItem::ID, IImageComboBoxItem::ID, IListBoxItem::ID
		[helpstring("The item is identified by an unique ID.")]
		iitID,
		/// \brief The item is identified by a zero-based index
		///
		/// Reordering the items won't change an item's index, but removing or adding new items may
		/// do so.
		///
		/// \remarks This is the preferred and fastest method to identify an item.
		///
		/// \sa IComboBoxItem::Index, IDriveComboBoxItem::Index, IImageComboBoxItem::Index, IListBoxItem::Index
		[helpstring("The item is identified by a zero-based index.")]
		iitIndex
	} ItemIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c GetRectangle methods</em>
	///
	/// \sa IComboBoxItem::GetRectangle, IDriveComboBoxItem::GetRectangle, IImageComboBoxItem::GetRectangle,
	///     IListBoxItem::GetRectangle
	[helpstring("Constants used with the 'GetRectangle' methods.")]
	typedef enum ItemRectangleTypeConstants {
		/// \brief The rectangle surrounds the item's selected parts
		///
		/// The rectangle is the rectangle that is highlighted when the item is selected.
		[helpstring("The rectangle is the rectangle that is highlighted when the item is selected.")]
		irtSelection = 3
	} ItemRectangleTypeConstants;

	/// \brief <em>Constants used with the \c MousePointer properties</em>
	///
	/// \sa IComboBox::MousePointer, IDriveComboBox::MousePointer, IImageComboBox::MousePointer,
	///     IListBox::MousePointer
	[helpstring("Constants used with the 'MousePointer' properties.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor.
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with the \c MultiSelect property</em>
	///
	/// \sa IListBox::MultiSelect
	[helpstring("Constants used with the 'MultiSelect' property.")]
	typedef enum MultiSelectConstants {
		/// \brief The control doesn't allow selection of multiple items
		[helpstring("The control doesn't allow selection of multiple items.")]
		msNone,
		/// \brief The control allows selection of multiple items by using the SHIFT or STRG key and the mouse
		[helpstring("The control allows selection of multiple items by using the SHIFT or STRG key and the mouse.")]
		msNormal,
		/// \brief The control allows selection of multiple items by using the SPACE bar or the mouse
		///
		/// The control allows selection of multiple items. To toggle the selection state of an item, the item
		/// must be clicked or the SPACE bar must be pressed while the item has the keyboard focus.
		[helpstring("The control allows selection of multiple items. To toggle the selection state of an item, the item must be clicked or the SPACE bar must be pressed while the item has the keyboard focus.")]
		msSelectByClick
	} MultiSelectConstants;

	/// \brief <em>Constants used with the \c OLEQueryContinueDrag event</em>
	///
	/// \sa _IDriveComboBoxEvents::OLEQueryContinueDrag, _IImageComboBoxEvents::OLEQueryContinueDrag,
	///     _IListBoxEvents::OLEQueryContinueDrag
	[helpstring("Constants used with the 'OLEQueryContinueDrag' event.")]
	typedef enum OLEActionToContinueWithConstants {
		/// \brief Continue the drag'n'drop operation
		[helpstring("Continue the drag'n'drop operation.")]
		oatcwContinue = 0x0 /*S_OK*/,
		/// \brief Cancel the drag'n'drop operation
		[helpstring("Cancel the drag'n'drop operation.")]
		oatcwCancel = 0x40101 /*DRAGDROP_S_CANCEL*/,
		/// \brief Complete the drag'n'drop operation
		[helpstring("Complete the drag'n'drop operation.")]
		oatcwDrop = 0x40100 /*DRAGDROP_S_DROP*/
	} OLEActionToContinueWithConstants;

	/// \brief <em>Constants used with the \c OLEDragImageStyle property</em>
	///
	/// \sa IDriveComboBox::OLEDragImageStyle, IImageComboBox::OLEDragImageStyle, IListBox::OLEDragImageStyle
	[helpstring("Constants used with the 'OLEDragImageStyle' property.")]
	typedef enum OLEDragImageStyleConstants {
		/// \brief OLE drag images will be generated in classic style
		[helpstring("OLE drag images will be generated in classic style.")]
		odistClassic,
		/// \brief OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems
		///
		/// \remarks Aero style is supported by Windows Vista and newer systems.\n
		///          The icons for Aero style drag images are taken from the \c ilHighResolution image list.
		///
		/// \sa IDriveComboBox::hImageList, IImageComboBox::hImageList, IListBox::hImageList
		[helpstring("OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems. Aero style is supported by Windows Vista and newer systems.")]
		odistAeroIfAvailable
	} OLEDragImageStyleConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _IComboBoxEvents::OLEDragEnter, _IComboBoxEvents::OLEDragMouseMove,
	///     _IComboBoxEvents::OLEDragDrop,
	///     _IDriveComboBoxEvents::OLEDragEnter, _IDriveComboBoxEvents::OLEDragMouseMove,
	///     _IDriveComboBoxEvents::OLEDragDrop,
	///     _IImageComboBoxEvents::OLEDragEnter, _IImageComboBoxEvents::OLEDragMouseMove,
	///     _IImageComboBoxEvents::OLEDragDrop,
	///     _IListBoxEvents::OLEDragEnter, _IListBoxEvents::OLEDragMouseMove,
	///     _IListBoxEvents::OLEDragDrop
	[helpstring("Constants used with the 'OLEDrag*' events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Flags used to identify the required drawing action during owner-drawing</em>
	///
	/// \sa _IListBoxEvents::OwnerDrawItem
	[helpstring("Flags used to identify the required drawing action during owner-drawing.")]
	typedef enum OwnerDrawActionConstants {
		/// \brief The entire control needs to be drawn
		[helpstring("The entire control needs to be drawn.")]
		odaDrawEntire = 0x1 /*ODA_DRAWENTIRE*/,
		/// \brief The control's selection state has changed
		[helpstring("The control's selection state has changed.")]
		odaSelectionStateChanged = 0x2 /*ODA_SELECT*/,
		/// \brief The control has gained or lost the keyboard focus
		[helpstring("The control has gained or lost the keyboard focus.")]
		odaFocusChanged = 0x4 /*ODA_FOCUS*/
	} OwnerDrawActionConstants;

	/// \brief <em>Constants used with the \c OwnerDrawItems properties</em>
	///
	/// \sa IComboBox::OwnerDrawItems, IListBox::OwnerDrawItems
	[helpstring("Constants used with the 'OwnerDrawItems' properties.")]
	typedef enum OwnerDrawItemsConstants {
		/// \brief The control draws the items
		[helpstring("The control draws the items.")]
		odiDontOwnerDraw,
		/// \brief The control raises the \c OwnerDrawItem event if an item must be drawn
		///
		/// The control raises the \c OwnerDrawItem event if an item must be drawn. All items have the same
		/// height.
		///
		/// \sa IComboBox::ItemHeight, IListBox::ItemHeight, _IComboBoxEvents::OwnerDrawItem,
		///     _IListBoxEvents::OwnerDrawItem
		[helpstring("The control raises the 'OwnerDrawItem' event if an item must be drawn. All items have the same height.")]
		odiOwnerDrawFixedHeight,
		/// \brief The control raises the \c OwnerDrawItem event if an item must be drawn
		///
		/// The control raises the \c OwnerDrawItem event if an item must be drawn. For each item the
		/// \c MeasureItem event is raised to retrieve its individual height.
		///
		/// \sa _IComboBoxEvents::MeasureItem, _IComboBoxEvents::OwnerDrawItem,
		///     _IListBoxEvents::MeasureItem, _IListBoxEvents::OwnerDrawItem
		[helpstring("The control raises the 'OwnerDrawItem' event if an item must be drawn. For each item the 'MeasureItem' event is raised to retrieve its individual height.")]
		odiOwnerDrawVariableHeight
	} OwnerDrawItemsConstants;

	/// \brief <em>Flags used to identify item states during owner-drawing</em>
	///
	/// \sa _IComboBoxEvents::OwnerDrawItem, _IListBoxEvents::OwnerDrawItem
	[helpstring("Flags used to identify item states during owner-drawing.")]
	typedef enum OwnerDrawItemStateConstants {
		/// \brief The item is selected
		[helpstring("The item is selected.")]
		odisSelected = 0x1 /*ODS_SELECTED*/,
		/// \brief The item is disabled
		[helpstring("The item is disabled.")]
		odisDisabled = 0x4 /*ODS_DISABLED*/,
		/// \brief The item has the keyboard focus
		[helpstring("The item has the keyboard focus.")]
		odisFocus = 0x10 /*ODS_FOCUS*/,
		/// \brief The control is drawn without the keyboard accelerator cues
		[helpstring("The control is drawn without the keyboard accelerator cues.")]
		odisNoAccelerator = 0x100 /*ODS_NOACCEL*/,
		/// \brief The control is drawn without focus indicator cues
		[helpstring("The control is drawn without focus indicator cues.")]
		odisNoFocusRectangle = 0x200 /*ODS_NOFOCUSRECT*/,
		/// \brief The item is to be drawn for the selection field (edit control) of the combo box
		///
		/// \remarks This flag is used by the \c ComboBox control only.
		[helpstring("The item is to be drawn for the selection field (edit control) of the combo box.")]
		odisDrawingIntoSelectionField = 0x1000 /*ODS_COMBOBOXEDIT*/
	} OwnerDrawItemStateConstants;

	/// \brief <em>Constants used with the \c ItemGetDisplayInfo event</em>
	///
	/// \sa _IDriveComboBoxEvents::ItemGetDisplayInfo, _IImageComboBoxEvents::ItemGetDisplayInfo,
	///     _IListBoxEvents::ItemGetDisplayInfo
	[helpstring("Constants used with the 'ItemGetDisplayInfo' event.")]
	typedef enum RequestedInfoConstants {
		/// \brief The event was fired to retrieve the item's text
		///
		/// \sa IDriveComboBoxItem::Text, IImageComboBoxItem::Text
		[helpstring("The control requires the item's text.")]
		riItemText = 0x0001,
		/// \brief The event was fired to retrieve the index of the item's icon
		///
		/// \sa IDriveComboBoxItem::IconIndex, IImageComboBoxItem::IconIndex
		[helpstring("The control requires the index of the item's icon.")]
		riIconIndex = 0x0002,
		/// \brief The event was fired to retrieve the index of the item's selected icon
		///
		/// The event was fired to retrieve the index of the item's selected icon. The selected icon
		/// is used instead of the standard icon if the item is the control's selected item.
		///
		/// \sa IDriveComboBoxItem::SelectedIconIndex, IImageComboBoxItem::SelectedIconIndex
		[helpstring("The control requires the index of the item's selected icon.")]
		riSelectedIconIndex = 0x0004,
		/// \brief The event was fired to retrieve the index of the item's overlay icon
		///
		/// \sa IDriveComboBoxItem::OverlayIndex, IImageComboBoxItem::OverlayIndex
		[helpstring("The control requires the index of the item's overlay icon.")]
		riOverlayIndex = 0x0010,
		/// \brief The event was fired to retrieve the item's indentation
		///
		/// The event was fired to retrieve the item's indentation in steps of 10 pixels. If set to 1, the
		/// item's indentation will be 10 pixels; if set to 2, it will be 20 pixels and so on.
		///
		/// \sa IDriveComboBoxItem::Indent, IImageComboBoxItem::Indent
		[helpstring("The control requires the item's indentation.")]
		riIndent = 0x0040,
	} RequestedInfoConstants;

	/// \brief <em>Flags used with the \c RightToLeft properties</em>
	///
	/// \sa IComboBox::RightToLeft, IDriveComboBox::RightToLeft, IImageComboBox::RightToLeft,
	///     IListBox::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' properties. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The control's text is read from right to left, but the general layout is left to right.
		[helpstring("The control's text is read from right to left, but the general layout is left to right.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left.
		[helpstring("The general layout is right to left.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Flags used with the \c MouseWheel events</em>
	///
	/// \sa _IComboBoxEvents::MouseWheel, _IComboBoxEvents::ListMouseWheel,
	///     _IDriveComboBoxEvents::MouseWheel, _IDriveComboBoxEvents::ListMouseWheel,
	///     _IImageComboBoxEvents::MouseWheel, _IImageComboBoxEvents::ListMouseWheel,
	///     _IListBoxEvents::MouseWheel
	[helpstring("Flags used with the 'MouseWheel' events.")]
	typedef enum ScrollAxisConstants {
		/// \brief Scroll vertically
		[helpstring("The control will scroll vertically.")]
		saVertical = 1,
		/// \brief Scroll horizontally
		[helpstring("The control will scroll horizontally.")]
		saHorizontal = 2
	} ScrollAxisConstants;

	/// \brief <em>Constants used with the \c SelectionChanging event</em>
	///
	/// \sa _IDriveComboBoxEvents::SelectionChanging, _IImageComboBoxEvents::SelectionChanging
	[helpstring("Constants used with the 'SelectionChanging' event.")]
	typedef enum SelectionChangeReasonConstants {
		/// \brief The control's edit box lost the keyboard focus
		[helpstring("The control's edit box lost the keyboard focus.")]
		scrLostFocus = 1/*CBENF_KILLFOCUS*/,
		/// \brief The user has pressed the ENTER key
		[helpstring("The user has pressed the ENTER key.")]
		scrPressedReturn = 2/*CBENF_RETURN*/,
		/// \brief The user has pressed the ESC key
		[helpstring("The user has pressed the ESC key.")]
		scrPressedEscape = 3/*CBENF_ESCAPE*/,
		/// \brief The drop-down list has been activated
		[helpstring("The drop-down list has been activated.")]
		scrActivatedDropDownList = 4/*CBENF_DROPDOWN*/
	} SelectionChangeReasonConstants;

	/// \brief <em>Constants used with the \c Style properties</em>
	///
	/// \sa IComboBox::Style, IImageComboBox::Style
	[helpstring("Constants used with the 'Style' properties.")]
	typedef enum StyleConstants {
		/// \brief The control consists of an edit field and a drop-down list
		///
		/// The control consists of an edit field and a drop-down list. Values can be entered into the edit
		/// field or selected from the drop-down list.
		[helpstring("The control consists of an edit field and a drop-down list. Values can be entered into the edit field or selected from the drop-down list.")]
		sComboDropDownList,
		/// \brief The control consists of a static field and a drop-down list
		///
		/// The control consists of a static field and a drop-down list. Values can be selected from the
		/// drop-down list.
		[helpstring("The control consists of a static field and a drop-down list. Values can be selected from the drop-down list.")]
		sDropDownList,
		/// \brief The control consists of an edit field
		///
		/// The control consists of an edit field. Values can be entered into the edit field.
		[helpstring("The control consists of an edit field. Values can be entered into the edit field.")]
		sComboField
	} StyleConstants;

	/// \brief <em>Flags used with the \c ToolTips property</em>
	///
	/// \sa IListBox::ToolTips
	[helpstring("Flags used with the 'ToolTips' property. They can be combined.")]
	typedef enum ToolTipsConstants {
		/// \brief Display label tips
		[helpstring("The control displays tooltips for partially hidden item labels.")]
		ttLabelTips = 1,
		/// \brief Display per-item tooltips (so-called info tips) and fire the \c ItemGetInfoTipText event
		///
		/// \sa _IListBoxEvents::ItemGetInfoTipText
		[helpstring("The control displays per-item tooltips (so-called info tips) and fires the 'ItemGetInfoTipText' event.")]
		ttInfoTips = 2
	} ToolTipsConstants;

	/// \brief <em>Constants used with the \c UseSystemImageList property</em>
	///
	/// \sa IDriveComboBox::UseSystemImageList
	[helpstring("Constants used with the 'UseSystemImageList' property.")]
	typedef enum UseSystemImageListConstants {
		/// \brief Use a custom image list instead of a system image list
		[helpstring("Use a custom image list instead of a system image list.")]
		usilNone = 0x00,
		/// \brief Use the system image list for small icons (usually 16x16)
		[helpstring("Use the system image list for small icons (usually 16x16).")]
		usilSmallImageList = 0x01,
		/// \brief Use the system image list for large icons (usually 32x32)
		[helpstring("Use the system image list for large icons (usually 32x32).")]
		usilLargeImageList = 0x02,
		/// \brief Use the system image list for extra-large icons (usually 48x48)
		///
		/// \remarks Requires Windows XP or newer.
		[helpstring("Use the system image list for extra-large icons (usually 48x48). Requires Windows XP or newer")]
		usilExtraLargeImageList = 0x04,
		/// \brief Use the system image list for jumbo-sized icons (usually 256x256)
		///
		/// \remarks Requires Windows Vista or newer.
		[helpstring("Use the system image list for jumbo-sized icons (usually 256x256). Requires Windows Vista or newer")]
		usilJumboImageList = 0x08
	} UseSystemImageListConstants;

	/// \brief <em>Constants used with the \c WritingDirectionChanged event</em>
	///
	/// \sa _IComboBoxEvents::WritingDirectionChanged, _IImageComboBoxEvents::WritingDirectionChanged
	[helpstring("Constants used with the 'WritingDirectionChanged' event.")]
	typedef enum WritingDirectionConstants {
		/// \brief The writing direction is left-to-right
		[helpstring("The writing direction is left-to-right.")]
		wdLeftToRight,
		/// \brief The writing direction is right-to-left
		[helpstring("The writing direction is right-to-left.")]
		wdRightToLeft
	} WritingDirectionConstants;


	/// \brief <em>Holds the coordinates of a rectangle's opposing corners</em>
	///
	/// \sa _IComboBoxEvents::OwnerDrawItem, _IListBoxEvents::OwnerDrawItem
	// NOTE: If we change the UUID, we also need to update _IComboBoxEvents_CP.h and _IListBoxEvents_CP.h!
	[helpstring("Holds a rectangle's position and size."), uuid(8940470A-8420-402b-8949-7D715B9C11CD)]
	typedef struct RECTANGLE
	{
		/// \brief <em>Holds the position of the rectangle's left border in pixels</em>
		[helpstring("Holds the position of the rectangle's left border in pixels.")]
		OLE_XPOS_PIXELS Left;
		/// \brief <em>Holds the position of the rectangle's upper border in pixels</em>
		[helpstring("Holds the position of the rectangle's upper border in pixels.")]
		OLE_YPOS_PIXELS Top;
		/// \brief <em>Holds the position of the rectangle's right border in pixels</em>
		[helpstring("Holds the position of the rectangle's right border in pixels.")]
		OLE_XPOS_PIXELS Right;
		/// \brief <em>Holds the position of the rectangle's lower border in pixels</em>
		[helpstring("Holds the position of the rectangle's lower border in pixels.")]
		OLE_YPOS_PIXELS Bottom;
	} RECTANGLE;


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(0FB6AFBB-245B-459c-81BE-0531D4E87665),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, IComboBox::SupportOLEDragImages, IDriveComboBox::SupportOLEDragImages,
		///     IImageComboBox::SupportOLEDragImages, IListBox::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, IComboBox::SupportOLEDragImages, IDriveComboBox::SupportOLEDragImages,
		///     IImageComboBox::SupportOLEDragImages, IListBox::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(C2E417EF-8BE6-4398-B395-2A72B8B24B40),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(F74E7AF5-83EB-43bd-BAD3-9B62D674C42E),
		version(1.5),
		noncreatable,
		helpstring("OLEDataObject Class 1.5 (Unicode)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	/// \interface IVirtualComboBoxItem
	/// \brief <em>Wraps a not existing item</em>
	///
	/// This interface is a wrapper around a combo box item that does not yet or not anymore exist within
	/// the control.
	///
	/// \sa _IVirtualComboBoxItemEvents, IComboBoxItem, _IComboBoxEvents
	[
		object,
		uuid(6ABBA61F-7467-4a5f-B2A1-6405C40C19DA),
		dual,
		nonextensible,
		helpstring("IVirtualComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IVirtualComboBoxItem : IDispatch
	{
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves the zero-based index that will identify or has identified the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IComboBoxItems::Add
		[propget, id(DISPID_VCBI_INDEX), helpstring("Retrieves the item's zero-based index."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IComboBoxEvents::FreeItemData
		[propget, id(DISPID_VCBI_ITEMDATA), helpstring("Retrieves the Long value associated with the item."), nonbrowsable]
		HRESULT ItemData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's text</em>
		///
		/// Retrieves the item's text.
		///
		/// \remarks This is the default property of the \c IVirtualComboBoxItem interface.\n
		///          This property is read-only.
		[propget, id(DISPID_VCBI_TEXT), helpstring("Retrieves the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
	}


	/// \interface _IVirtualComboBoxItemEvents
	/// \brief <em>The \c VirtualComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c VirtualComboBoxItem class may raise.
	///
	/// \sa IVirtualComboBoxItem
	[
		uuid(54656C80-F3E4-4edd-8857-961DBE2F3765),
		helpstring("IVirtualComboBoxItem-event-interface")
	]
	dispinterface _IVirtualComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualComboBoxItem class</em>
	///
	/// This COM class implements the \c IVirtualComboBoxItem and \c _IVirtualComboBoxItemEvents
	/// interfaces.
	///
	/// \sa IVirtualComboBoxItem, _IVirtualComboBoxItemEvents, ComboBox, ComboBoxItem
	[
		uuid(0EF624A2-77FE-46c9-9FBE-42A561D98F25),
		version(1.0),
		noncreatable,
		helpstring("VirtualComboBoxItem Class 1.0 (Unicode)")
	]
	coclass VirtualComboBoxItem
	{
		[default] interface IVirtualComboBoxItem;
		[default, source] dispinterface _IVirtualComboBoxItemEvents;
	};


	/// \interface IComboBoxItem
	/// \brief <em>Wraps an existing combo box item</em>
	///
	/// This interface is a wrapper around an item that - unlike an item wrapped by
	/// \c IVirtualComboBoxItem - really exists within the control.
	///
	/// \sa _IComboBoxItemEvents, IVirtualComboBoxItem, IComboBoxItems, IComboBox, _IComboBoxEvents
	[
		object,
		uuid(CF00AAA5-9BA6-4924-94BD-06CD0425B34F),
		dual,
		nonextensible,
		helpstring("IComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IComboBoxItem : IDispatch
	{
		/// \brief <em>Specifies the item's height</em>
		///
		/// Retrieves or sets the item's height in pixels.
		///
		/// \remarks If the \c OwnerDrawItems property is not set to \c odiOwnerDrawVariableHeight, this
		///          property is read-only. Use the \c IComboBox::ItemHeight property instead.
		///
		/// \sa GetRectangle, IComboBox::OwnerDrawItems, IComboBox::ItemHeight
		[propget, id(DISPID_CBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBox.ItemHeight' property instead.")]
		HRESULT Height([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBox.ItemHeight' property instead.")]
		HRESULT Height([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the item's ID</em>
		///
		/// Retrieves an unique ID identifying this item.
		///
		/// \remarks An item's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, ItemIdentifierTypeConstants
		[propget, id(DISPID_CBI_ID), helpstring("Retrieves the item's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves a zero-based index identifying this item.
		///
		/// \remarks Although adding or removing items changes other items' indexes, the index is the best
		///          (and fastest) option to identify an item.\n
		///          This property is read-only.
		///
		/// \sa ID, ItemIdentifierTypeConstants
		[propget, id(DISPID_CBI_INDEX), helpstring("Retrieves the item's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the item. Use this property to associate
		/// any data with the item.
		///
		/// \sa _IComboBoxEvents::FreeItemData
		[propget, id(DISPID_CBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([out, retval] LONG* pValue);
		[propput, id(DISPID_CBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([in] LONG newValue);
		/// \brief <em>Specifies whether the item is selected</em>
		///
		/// Retrieves whether the item is the currently selected item. If this property is set to \c True, the
		/// item is selected; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IComboBox::SelectedItem
		[propget, id(DISPID_CBI_SELECTED), helpstring("Retrieves whether the item is the currently selected item.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the item's text</em>
		///
		/// Retrieves or sets the item's text.
		///
		/// \remarks This is the default property of the \c IComboBoxItem interface.
		[propget, id(DISPID_CBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_CBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([in] BSTR newValue);

		/// \brief <em>Retrieves the bounding rectangle of either the item or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client
		/// area) of either the item or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c ItemRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the drop-down list box control's upper-left corner.
		///
		/// \sa Height, ItemRectangleTypeConstants
		[id(DISPID_CBI_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client area) of either the item or a part of it.")]
		HRESULT GetRectangle(ItemRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
	}


	/// \interface _IComboBoxItemEvents
	/// \brief <em>The \c ComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c ComboBoxItem class may raise.
	///
	/// \sa IComboBoxItem
	[
		uuid(00D03A1C-5C4D-41fb-ACBD-0D0CB1C5104D),
		helpstring("IComboBoxItem-event-interface")
	]
	dispinterface _IComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ComboBoxItem class</em>
	///
	/// This COM class implements the \c IComboBoxItem and \c _IComboBoxItemEvents interfaces.
	///
	/// \sa IComboBoxItem, _IComboBoxItemEvents, ComboBox, ComboBoxItems
	[
		uuid(3603CD63-0104-4bb5-8BC2-C12B9248E93D),
		version(1.5),
		noncreatable,
		helpstring("ComboBoxItem Class 1.5 (Unicode)")
	]
	coclass ComboBoxItem
	{
		[default] interface IComboBoxItem;
		[default, source] dispinterface _IComboBoxItemEvents;
	};


	/// \interface IComboBoxItems
	/// \brief <em>Manages a collection of \c ComboBoxItem objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c ComboBoxItem
	/// objects. A \c ComboBoxItems object is used to group items that have certain properties in common.
	///
	/// \sa _IComboBoxItemsEvents, IComboBoxItem, IComboBox
	[
		object,
		uuid(9840F11B-2AD5-4ce5-B30E-A6A39FD02316),
		dual,
		nonextensible,
		helpstring("IComboBoxItems interface"),
		pointer_default(unique)
	]
	interface IComboBoxItems : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on an item,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_CBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets an item filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal itemProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_CBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_CBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets an item filter.\n
		/// An \c IComboBoxItems collection can be filtered by any of \c IComboBoxItem's properties, that
		/// the \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple
		/// filters are possible, too. A filter is a \c Variant containing an array whose elements are of
		/// type \c Variant. Each element of this array contains a valid value for the property, that the
		/// filter refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_CBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_CBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets an item filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_CBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_CBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c ComboBoxItem object from the collection</em>
		///
		/// Retrieves a \c ComboBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be retrieved.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IComboBoxItems interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_CBIS_ITEM), helpstring("Retrieves a 'ComboBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IComboBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ListBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_CBIS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds an item to the combo box</em>
		///
		/// Adds an item with the specified properties at the specified position in the control and returns
		/// a \c ComboBoxItem object wrapping the inserted item.
		///
		/// \param[in] itemText The new item's caption text.
		/// \param[in] insertAt The new item's zero-based index. If set to -1, the item will be inserted
		///            as the last item.
		/// \param[in] itemData A \c Long value that will be associated with the item.
		///
		/// \return The inserted item.
		///
		/// \remarks If the \c HasStrings property is set to \c False and the \c OwnerDrawItems property is set
		///          to a value other than \c odiDontOwnerDraw, the parameter \c itemText is ignored.
		///
		/// \sa Count, Remove, RemoveAll, IComboBoxItem::Text, IComboBoxItem::ItemData, IComboBox::HasStrings,
		///     IComboBox::OwnerDrawItems, IComboBox::PrepareForItemInsertions
		[id(DISPID_CBIS_ADD), helpstring("Adds a new item with the specified properties.")]
		HRESULT Add([in] BSTR itemText, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(0)] LONG ItemData, [out, retval] IComboBoxItem** ppAddedItem);
		/// \brief <em>Retrieves whether the specified item is part of the item collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the item to be checked.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified item is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, ItemIdentifierTypeConstants
		[id(DISPID_CBIS_CONTAINS), helpstring("Retrieves whether the specified item is part of the item collection.")]
		HRESULT Contains([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c ComboBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_CBIS_COUNT), helpstring("Retrieves the number of 'ComboBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified item in the collection from the combo box</em>
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be removed.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, ItemIdentifierTypeConstants
		[id(DISPID_CBIS_REMOVE), helpstring("Removes the specified item in the collection from the control.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType);
		/// \brief <em>Removes all items in the collection from the combo box</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_CBIS_REMOVEALL), helpstring("Removes all items in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IComboBoxItemsEvents
	/// \brief <em>The \c ComboBoxItems class' events interface</em>
	///
	/// This interface defines all events the \c ComboBoxItems class may raise.
	///
	/// \sa IComboBoxItems
	[
		uuid(FCD44EBE-D8CA-42c8-8836-157B7CF976D9),
		helpstring("IComboBoxItems-event-interface")
	]
	dispinterface _IComboBoxItemsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ComboBoxItems class</em>
	///
	/// This COM class implements the \c IComboBoxItems and \c _IComboBoxItemsEvents interfaces.
	///
	/// \sa IComboBoxItems, _IComboBoxItemsEvents, ComboBox, ComboBoxItem
	[
		uuid(A30D3BA4-E321-4038-8CC9-5C1F4A44FE0C),
		version(1.5),
		noncreatable,
		helpstring("ComboBoxItems Class 1.5 (Unicode)")
	]
	coclass ComboBoxItems
	{
		[default] interface IComboBoxItems;
		[default, source] dispinterface _IComboBoxItemsEvents;
	};


	/// \interface IComboBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the combo box control's main interface. It wraps the control window.
	///
	/// \sa _IComboBoxEvents
	[
		object,
		uuid(E9DDEC6F-794E-475b-B9A9-E791FC5AF542),
		dual,
		nonextensible,
		helpstring("IComboBox interface"),
		pointer_default(unique)
	]
	interface IComboBox : IDispatch
	{
		/// \brief <em>Specifies whether the contained edit control accepts numbers only</em>
		///
		/// Retrieves or sets whether the contained edit control accepts all kind of text or only numbers. If
		/// set to \c True, only numbers, otherwise all text is accepted.
		///
		/// \sa Text
		[propget, id(DISPID_CB_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_CB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_CB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's automatic scrolling features</em>
		///
		/// Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret
		/// reaches the borders of the control's client area. If set to \c True, the control scrolls
		/// automatically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Style
		[propget, id(DISPID_CB_AUTOHORIZONTALSCROLLING), helpstring("Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoHorizontalScrolling([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_AUTOHORIZONTALSCROLLING), helpstring("Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoHorizontalScrolling([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks Starting with comctl32.dll version 6.10, this property is ignored if the \c Style property
		///          is set to \c sDropDownList.
		///
		/// \sa ForeColor, ListBackColor, Style
		[propget, id(DISPID_CB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored if the 'Style' property is set to 'sDropDownList'.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored if the 'Style' property is set to 'sDropDownList'.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_CB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_CB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Controls the control's automatic character conversion features</em>
		///
		/// Retrieves or sets the kind of conversion that is applied to characters that are typed into the
		/// control. Any of the values defined by the \c CharacterConversionConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa DoOEMConversion, Text, CharacterConversionConstants
		[propget, id(DISPID_CB_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control. Changing this property destroys and recreates the control window.")]
		HRESULT CharacterConversion([out, retval] CharacterConversionConstants* pValue);
		[propput, id(DISPID_CB_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control. Changing this property destroys and recreates the control window.")]
		HRESULT CharacterConversion([in] CharacterConversionConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the control's items</em>
		///
		/// Retrieves a collection object wrapping the combo box items.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IComboBoxItems
		[propget, id(DISPID_CB_COMBOITEMS), helpstring("Retrieves a collection object wrapping the control's items."), nonbrowsable]
		HRESULT ComboItems([out, retval] IComboBoxItems** ppItems);
		/// \brief <em>Specifies the control's textual cue</em>
		///
		/// Retrieves or sets the control's textual cue.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text
		[propget, id(DISPID_CB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([out, retval] BSTR* pValue);
		[propput, id(DISPID_CB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([in] BSTR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_CB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_CB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_CB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control tries to work-around character set problems related to filenames</em>
		///
		/// Retrieves or sets whether the control's text is converted from the Windows character set to the OEM
		/// character set and then back to the Windows character set. Such a conversion ensures proper
		/// character conversion when the application calls the \c CharToOem function to convert a Windows
		/// string in the control to OEM characters. This property is most useful if the control contains file
		/// names that will be used on file systems that do not support Unicode.\n
		/// If set to \c True, the conversion is performed; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa CharacterConversion, Text,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647473.aspx">CharToOem</a>
		[propget, id(DISPID_CB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic opening of the drop-down list box control during drag'n'drop</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down
		/// button during a drag'n'drop operation before the drop-down list box control will be opened
		/// automatically. If set to 0, automatic drop-down is disabled. If set to -1, the system's
		/// double-click time, multiplied with 4, is used.
		///
		/// \sa RegisterForOLEDragDrop, ListDragScrollTimeBase, _IComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_CB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([in] LONG newValue);
		/// \brief <em>Retrieves the accessibility object state of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the accessibility object state of the drop-down button which is displayed if the \c Style
		/// property is set to \c sComboDropDownList or \c sDropDownList. For a list of possible object states
		/// see the <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">MSDN article</a>.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Style, IsDroppedDown,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">Accessibility Object State Constants</a>
		[propget, id(DISPID_CB_DROPDOWNBUTTONOBJECTSTATE), helpstring("Retrieves the accessibility object state of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'."), nonbrowsable]
		HRESULT DropDownButtonObjectState([out, retval] LONG* pValue);
		/// \brief <em>Specifies which key opens the drop-down window</em>
		///
		/// Retrieves or sets the key that opens the drop-down window when pressed. Any of the values defined
		/// by the \c DropDownKeyConstants enumeration is valid.
		///
		/// \sa DropDownKeyConstants
		[propget, id(DISPID_CB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([out, retval] DropDownKeyConstants* pValue);
		[propput, id(DISPID_CB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([in] DropDownKeyConstants newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_CB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the first item that is displayed in the drop-down list box control's client area</em>
		///
		/// Retrieves or sets the first combo box item, that is entirely located within the drop-down list box
		/// control's client area and therefore visible to the user.
		///
		/// \sa ComboItems
		[propget, id(DISPID_CB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([out, retval] IComboBoxItem** ppFirstItem);
		[propputref, id(DISPID_CB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([in] IComboBoxItem* pNewFirstItem);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, ForeColor, ListForeColor
		[propget, id(DISPID_CB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_CB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_CB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor, ListForeColor
		[propget, id(DISPID_CB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies whether the control's items are strings</em>
		///
		/// Retrieves or sets whether the items in the control are strings. If set to \c True, the control
		/// contains strings; otherwise the items consist of the value specified by the \c ItemData property
		/// only.
		///
		/// \remarks This property is ignored if the \c OwnerDrawItems property is set to \c odiDontOwnerDraw.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa OwnerDrawItems, IComboBoxItem::ItemData, IComboBoxItem::Text
		[propget, id(DISPID_CB_HASSTRINGS), helpstring("Retrieves or sets whether the items in the control are strings. This property is ignored if the 'OwnerDrawItems' property is set to 'odiDontOwnerDraw'. Changing this property destroys and recreates the control window.")]
		HRESULT HasStrings([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_HASSTRINGS), helpstring("Retrieves or sets whether the items in the control are strings. This property is ignored if the 'OwnerDrawItems' property is set to 'odiDontOwnerDraw'. Changing this property destroys and recreates the control window.")]
		HRESULT HasStrings([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IComboBoxEvents::MouseHover
		[propget, id(DISPID_CB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndEdit, hWndListBox, _IComboBoxEvents::RecreatedControlWindow,
		///     _IComboBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_CB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained edit control's window handle</em>
		///
		/// Retrieves the contained edit control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndListBox, _IComboBoxEvents::CreatedEditControlWindow,
		///     _IComboBoxEvents::DestroyedEditControlWindow
		[propget, id(DISPID_CB_HWNDEDIT), helpstring("Retrieves the contained edit control's window handle."), nonbrowsable]
		HRESULT hWndEdit([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the drop-down list box control's window handle</em>
		///
		/// Retrieves the drop-down list box control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndEdit, _IComboBoxEvents::CreatedListBoxControlWindow,
		///     _IComboBoxEvents::DestroyedListBoxControlWindow, _IComboBoxEvents::ListDropDown,
		///     _IComboBoxEvents::ListCloseUp
		[propget, id(DISPID_CB_HWNDLISTBOX), helpstring("Retrieves the drop-down list box control's window handle."), nonbrowsable]
		HRESULT hWndListBox([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_CB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_CB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \brief <em>Specifies whether the control displays partial items</em>
		///
		/// Retrieves or sets whether the control resizes itself so that an integral number of items is
		/// displayed. If set to \c True, an integral number of items is displayed and the control's height
		/// may be changed to achieve this; otherwise partial items may be displayed.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ItemHeight
		[propget, id(DISPID_CB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		HRESULT IntegralHeight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		HRESULT IntegralHeight([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves whether the drop-down list box control is currently displayed</em>
		///
		/// Retrieves whether the drop-down list box control is currently displayed. If \c True, the list box
		/// is displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Style, DropDownButtonObjectState
		[propget, id(DISPID_CB_ISDROPPEDDOWN), helpstring("Retrieves whether the drop-down list box control is currently displayed."), nonbrowsable]
		HRESULT IsDroppedDown([out, retval] VARIANT_BOOL* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_CB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies all items' height</em>
		///
		/// Retrieves or sets the items' height in pixels. If set to -1, the default setting is used.
		///
		/// \remarks If the \c OwnerDrawItems property is set to \c odiOwnerDrawVariableHeight, this property
		///          is ignored. Use the \c IComboBoxItem::Height property instead.
		///
		/// \sa OwnerDrawItems, IntegralHeight, IComboBoxItem::Height, SelectionFieldHeight
		[propget, id(DISPID_CB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels. If the 'OwnerDrawItems' property is set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBoxItem.Height' property instead.")]
		HRESULT ItemHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels. If the 'OwnerDrawItems' property is set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBoxItem.Height' property instead.")]
		HRESULT ItemHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the visibility of the vertical scroll bar in the drop-down list box control</em>
		///
		/// Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled
		/// instead of hidden if the control does not contain enough items to scroll. If set to \c True, the
		/// scroll bar is disabled; otherwise it is hidden.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ComboItems, ListScrollableWidth
		[propget, id(DISPID_CB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the drop-down list box control's background color</em>
		///
		/// Retrieves or sets the drop-down list box control's background color.
		///
		/// \sa ListForeColor, BackColor, ListInsertMarkColor
		[propget, id(DISPID_CB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		HRESULT ListBackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		HRESULT ListBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa RegisterForOLEDragDrop, _IComboBoxEvents::ListOLEDragMouseMove
		[propget, id(DISPID_CB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([in] LONG newValue);
		/// \brief <em>Specifies the drop-down list box control's text color</em>
		///
		/// Retrieves or sets the drop-down list box control's text color.
		///
		/// \sa ListBackColor, ForeColor, ListInsertMarkColor
		[propget, id(DISPID_CB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		HRESULT ListForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		HRESULT ListForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the height of the drop-down list box</em>
		///
		/// Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting
		/// is used.
		///
		/// \sa ListWidth, MinVisibleItems
		[propget, id(DISPID_CB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \sa SetListInsertMarkPosition, ListBackColor, ListForeColor
		[propget, id(DISPID_CB_LISTINSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT ListInsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_CB_LISTINSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT ListInsertMarkColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the width by which the drop-down list box can be scrolled horizontally</em>
		///
		/// Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled
		/// horizontally. If the width of the control is greater than this value, a horizontal scroll bar is
		/// displayed.
		///
		/// \sa ListAlwaysShowVerticalScrollBar, ListWidth
		[propget, id(DISPID_CB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		HRESULT ListScrollableWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		HRESULT ListScrollableWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the width of the drop-down list box</em>
		///
		/// Retrieves or sets the width in pixels of the drop-down list box.
		///
		/// \remarks The minimum width of the drop-down list box is the combo box width.
		///
		/// \sa ListHeight, ListScrollableWidth
		[propget, id(DISPID_CB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_CB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the control's current locale</em>
		///
		/// Retrieves or sets the control's current locale. The locale influences how items are sorted if the
		/// \c Sorted property is set to \c True. For a list of possible locale identifiers see
		/// <a href="https://msdn.microsoft.com/en-us/library/dd318693.aspx">MSDN Online</a>.
		///
		/// \sa Sorted
		[propget, id(DISPID_CB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		HRESULT Locale([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		HRESULT Locale([in] LONG newValue);
		/// \brief <em>Specifies the maximum length of the input</em>
		///
		/// Retrieves or sets the maximum number of characters, that the user can type into the control. If set
		/// to -1, the system's default setting is used.
		///
		/// \remarks Text, that is set through the \c Text property may exceed this limit.
		///
		/// \sa TextLength, Text, _IComboBoxEvents::TruncatedText
		[propget, id(DISPID_CB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([in] LONG newValue);
		/// \brief <em>Specifies the minimum number of visible items in the drop-down list box</em>
		///
		/// Retrieves or sets the minimum number of visible items in the drop-down list box. The list box will
		/// be made large enough to display the specified number of items, even if the height specified by the
		/// \c ListHeight property is smaller.
		///
		/// \remarks This property is ignored if the \c IntegralHeight property is set to \c False.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa ListHeight, IntegralHeight
		[propget, id(DISPID_CB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT MinVisibleItems([out, retval] LONG* pValue);
		[propput, id(DISPID_CB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT MinVisibleItems([in] LONG newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_CB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_CB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_CB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_CB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_CB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the items are drawn by the application instead of the control</em>
		///
		/// Retrieves or sets whether your application draws the items itself. Any of the values defined by the
		/// \c OwnerDrawItemsConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa HasStrings, OwnerDrawItemsConstants
		[propget, id(DISPID_CB_OWNERDRAWITEMS), helpstring("Retrieves or sets whether your application draws the items itself. Changing this property destroys and recreates the control window.")]
		HRESULT OwnerDrawItems([out, retval] OwnerDrawItemsConstants* pValue);
		[propput, id(DISPID_CB_OWNERDRAWITEMS), helpstring("Retrieves or sets whether your application draws the items itself. Changing this property destroys and recreates the control window.")]
		HRESULT OwnerDrawItems([in] OwnerDrawItemsConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IComboBoxEvents::ContextMenu
		[propget, id(DISPID_CB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_CB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IComboBoxEvents::OLEDragEnter
		[propget, id(DISPID_CB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_CB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_CB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the control's currently selected item</em>
		///
		/// Retrieves or sets the control's currently selected item.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa IComboBoxItem::Selected, SelectItemByText, _IComboBoxEvents::SelectionChanged
		[propget, id(DISPID_CB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([out, retval] IComboBoxItem** ppSelectedItem);
		[propputref, id(DISPID_CB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([in] IComboBoxItem* pNewSelectedItem);
		/// \brief <em>Specifies the height of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves or sets the height of the part of the control that displays the currently selected item.
		/// If set to -1, the default setting is used.
		///
		/// \sa ItemHeight
		[propget, id(DISPID_CB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_CB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa SupportOLEDragImages, _IComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_CB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the items are sorted alphabetically</em>
		///
		/// Retrieves or sets whether the items in the control are sorted alphabetically. If set to \c True,
		/// the control sorts the items alphabetically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ComboItems, Locale, _IComboBoxEvents::CompareItems
		[propget, id(DISPID_CB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how data can be input into the control</em>
		///
		/// Retrieves or sets which kind of user input is possible. Any of the values defined by the
		/// \c StyleConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa StyleConstants
		[propget, id(DISPID_CB_STYLE), helpstring("Retrieves or sets which kind of user input is possible. Changing this property destroys and recreates the control window.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_CB_STYLE), helpstring("Retrieves or sets which kind of user input is possible. Changing this property destroys and recreates the control window.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_CB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_CB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the text currently displayed in the combo portion</em>
		///
		/// Retrieves or sets the text currently displayed in the combo portion of the control.
		///
		/// \sa TextLength, MaxTextLength, AcceptNumbersOnly, CueBanner, ForeColor, Font,
		///     _IComboBoxEvents::TextChanged
		[propget, id(DISPID_CB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_CB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Retrieves the length of the text currently displayed in the combo portion</em>
		///
		/// Retrieves the length of the text specified by the \c Text property.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaxTextLength, Text
		[propget, id(DISPID_CB_TEXTLENGTH), helpstring("Retrieves the length of the text specified by the 'Text' property. This property is read-only."), nonbrowsable]
		HRESULT TextLength([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_CB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_CB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_CB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Closes the drop-down list box control</em>
		///
		/// Closes the drop-down list box control.
		///
		/// \sa OpenDropDownWindow, _IComboBoxEvents::ListCloseUp, hWndListBox
		[id(DISPID_CB_CLOSEDROPDOWNWINDOW), helpstring("Closes the drop-down list box control.")]
		HRESULT CloseDropDownWindow(void);
		/// \brief <em>Finds an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByText, SelectItemByItemData, IComboBoxItem::ItemData
		[id(DISPID_CB_FINDITEMBYITEMDATA), helpstring("Searches the combo box control for the first item that has the 'ItemData' property set to the specified value.")]
		HRESULT FindItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IComboBoxItem** ppFoundItem);
		/// \brief <em>Finds an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \remarks The search is not case sensitive.
		///
		/// \sa FindItemByItemData, SelectItemByText, IComboBoxItem::Text
		[id(DISPID_CB_FINDITEMBYTEXT), helpstring("Searches the combo box control for the first item that starts with the specified text. The search is not case sensitive.")]
		HRESULT FindItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IComboBoxItem** ppFoundItem);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the drop-down list box control's
		///            upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the drop-down list box control's
		///            upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] comboItem The item at which the insertion mark should be displayed.
		///
		/// \sa SetListInsertMarkPosition, GetListInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_CB_GETCLOSESTLISTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestListInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] IComboBoxItem** comboItem);
		/// \brief <em>Retrieves the bounding rectangle of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// drop-down button which is displayed if the \c Style property is set to \c sComboDropDownList or
		/// \c sDropDownList.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		///
		/// \sa Style, GetSelectionFieldRectangle, GetDroppedStateRectangle
		[id(DISPID_CB_GETDROPDOWNBUTTONRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'.")]
		HRESULT GetDropDownButtonRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the bounding rectangle of the control including the drop-down list box</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the
		/// control when it is dropped down, i. e. including the drop-down list box.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		///
		/// \sa IsDroppedDown, GetDropDownButtonRectangle, GetSelectionFieldRectangle
		[id(DISPID_CB_GETDROPPEDSTATERECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the control when it is dropped down, i. e. including the drop-down list box.")]
		HRESULT GetDroppedStateRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] comboItem The item at which the insertion mark is displayed.
		///
		/// \sa SetListInsertMarkPosition, GetClosestListInsertMarkPosition, GetListInsertMarkRectangle,
		///     InsertMarkPositionConstants
		[id(DISPID_CB_GETLISTINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetListInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] IComboBoxItem** comboItem);
		/// \brief <em>Retrieves the bounding rectangle of the control's insertion mark</em>
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the drop-down list box control's upper-left corner.
		///
		/// \sa GetListInsertMarkPosition, SetListInsertMarkPosition
		[id(DISPID_CB_GETLISTINSERTMARKRECTANGLE), helpstring("Retrieves the bounding rectangle of the control's insertion mark.")]
		HRESULT GetListInsertMarkRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Retrieves the contained edit control's current selection's start and end</em>
		///
		/// Retrieves the zero-based character indices of the contained edit control's current selection's start and end.
		///
		/// \param[out] selectionStart The zero-based index of the character at which the selection starts.
		/// \param[out] selectionEnd The zero-based index of the first unselected character after the end of
		///             the selection.
		///
		/// \sa SetSelection
		[id(DISPID_CB_GETSELECTION), helpstring("Retrieves the zero-based character indices of the contained edit control's current selection's start and end.")]
		HRESULT GetSelection([in, out, defaultvalue(0)] LONG* selectionStart, [in, out, defaultvalue(0)] LONG* selectionEnd);
		/// \brief <em>Retrieves the bounding rectangle of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// part of the control that displays the currently selected item.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		///
		/// \sa Style, GetDropDownButtonRectangle, GetDroppedStateRectangle
		[id(DISPID_CB_GETSELECTIONFIELDRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the part of the control that displays the currently selected item.")]
		HRESULT GetSelectionFieldRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		///
		/// \return A value specifying the exact part of the control the specified point lies in. Some of the
		///         values defined by the \c HitTestConstants enumeration are valid.
		///
		/// \sa ListHitTest, HitTestConstants
		[id(DISPID_CB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [out, retval] HitTestConstants* pHitTestDetails);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the drop-down list box control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[out] hitTestDetails Receives a value specifying the exact part of the drop-down list box
		///             control the specified point lies in. Some of the values defined by the
		///             \c HitTestConstants enumeration are valid.
		///
		/// \return The item that the specified point belongs to. \c Nothing, if no item was "hit".
		///
		/// \sa HitTest, HitTestConstants
		[id(DISPID_CB_LISTHITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT ListHitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IComboBoxItem** ppHitItem);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_CB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Opens the drop-down list box control</em>
		///
		/// Opens the drop-down list box control.
		///
		/// \sa CloseDropDownWindow, _IComboBoxEvents::ListDropDown, hWndListBox
		[id(DISPID_CB_OPENDROPDOWNWINDOW), helpstring("Opens the drop-down list box control.")]
		HRESULT OpenDropDownWindow(void);
		/// \brief <em>Prepares the control for insertion of many items</em>
		///
		/// Prepares the control for the insertion of many items by reserving memory in advance. It is not
		/// necessary to call this method, but doing so can improve performance when inserting many (> 100)
		/// items at once.
		///
		/// \param[in] numberOfItems The number of items for which to reserve memory in advance.
		/// \param[in] averageStringWidth The average length of the item texts.
		///
		/// \return The number of items for which memory has been allocated.
		///
		/// \sa IComboBoxItems::Add
		[id(DISPID_CB_PREPAREFORITEMINSERTIONS), helpstring("Prepares the control for the insertion of many (> 100) items by reserving memory in advance.")]
		HRESULT PrepareForItemInsertions([in] LONG numberOfItems, [in] LONG averageStringWidth, [out, retval] LONG* pAllocatedItems);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_CB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_CB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Finds and selects an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value. If a matching item is found, it is made the selected item as specified by the
		/// \c SelectedItem property.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByText, FindItemByItemData, IComboBoxItem::ItemData, SelectedItem
		[id(DISPID_CB_SELECTITEMBYITEMDATA), helpstring("Searches the list box control for the first item that has the 'ItemData' property set to the specified value. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IComboBoxItem** ppFoundItem);
		/// \brief <em>Finds and selects an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text. If a matching
		/// item is found, it is made the selected item as specified by the \c SelectedItem property.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \remarks The search is not case sensitive.
		///
		/// \sa SelectItemByItemData, FindItemByText, IComboBoxItem::Text, SelectedItem
		[id(DISPID_CB_SELECTITEMBYTEXT), helpstring("Searches the list box control for the first item that starts with the specified text. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property. The search is not case sensitive.")]
		HRESULT SelectItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IComboBoxItem** ppFoundItem);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified item. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] comboItem The item at which to show the insertion mark. If set to \c Nothing, the
		///            insertion mark will be removed.
		///
		/// \sa GetListInsertMarkPosition, GetClosestListInsertMarkPosition, ListInsertMarkColor,
		///     RegisterForOLEDragDrop, InsertMarkPositionConstants
		[id(DISPID_CB_SETLISTINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetListInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] IComboBoxItem* comboItem);
		/// \brief <em>Sets the contained edit control's selection's start and end</em>
		///
		/// Sets the zero-based character indices of the contained edit control's selection's start and end.
		///
		/// \param[in] selectionStart The zero-based index of the character at which the selection starts. If
		///            set to -1, the current selection is cleared.
		/// \param[in] selectionEnd The zero-based index of the first unselected character after the end of
		///            the selection.
		///
		/// \remarks To select all text in the contained edit control, set \c selectionStart to 0 and
		///          \c selectionEnd to -1.
		///
		/// \sa GetSelection
		[id(DISPID_CB_SETSELECTION), helpstring("Sets the zero-based character indices of the contained edit control's selection's start and end.")]
		HRESULT SetSelection([in] LONG selectionStart, [in] LONG selectionEnd);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IComboBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_CB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IComboBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ComboBox class' events interface</em>
	///
	/// This interface defines all events the \c ComboBox class may raise.
	///
	/// \sa IComboBox
	[
		uuid(B949002F-D3A1-4ca9-9796-F3D564F0E131),
		helpstring("IComboBox-event-interface")
	]
	dispinterface _IComboBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The selected item was changed</em>
			///
			/// Will be fired after another item became the selected item.
			///
			/// \param[in] previousSelectedItem The previous selected item.
			/// \param[in] newSelectedItem The new selected item.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa IComboBoxItem::Selected, IComboBox::SelectedItem, SelectionCanceled, SelectionChanging
			[id(DISPID_CBE_SELECTIONCHANGED), helpstring("Will be fired after another item became the selected item.")]
			void SelectionChanged(IComboBoxItem* previousSelectedItem, IComboBoxItem* newSelectedItem);
			/// \brief <em>The control's text is about to be drawn</em>
			///
			/// Will be fired before the contained edit control's content is drawn.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IComboBox::Text, IComboBox::DisabledEvents
			[id(DISPID_CBE_BEFOREDRAWTEXT), helpstring("Will be fired before the contained edit control's content is drawn. This event may be disabled.")]
			void BeforeDrawText(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>Two items must be compared</em>
			///
			/// Will be fired during sorting of an owner-drawn combo box if two items must be compared.
			///
			/// \param[in] firstItem The first item to compare.
			/// \param[in] secondItem The second item to compare.
			/// \param[in] locale The identifier of the locale to use for comparison.
			/// \param[in,out] result The comparison's result. Any of the values defined by the
			///                \c CompareResultConstants enumeration is valid.
			///
			/// \remarks The items' indexes may be -1. For instance, this will happen if one of the items is
			///          currently being inserted. In this case all properties of \c IComboBoxItem except
			///          \c Index and \c ItemData will fail and the \c ItemData property is read-only.
			///
			/// \sa IComboBox::OwnerDrawItems, IComboBox::Sorted, IComboBox::Locale, CompareResultConstants,
			///     IComboBoxItem::Index, IComboBoxItem::ItemData
			[id(DISPID_CBE_COMPAREITEMS), helpstring("Will be fired during sorting of an owner-drawn combo box if two items must be compared.")]
			void CompareItems(IComboBoxItem* firstItem, IComboBoxItem* secondItem, LONG Locale, CompareResultConstants* result);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The part of the control that the menu's proposed position lies in.
			///            Some of the values defined by the \c HitTestConstants enumeration are valid.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_CBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The contained edit control was created</em>
			///
			/// Will be fired after the contained edit control was created.
			///
			/// \param[in] hWndEdit The contained edit control's window handle.
			///
			/// \sa DestroyedEditControlWindow, IComboBox::hWndEdit
			[id(DISPID_CBE_CREATEDEDITCONTROLWINDOW), helpstring("Will be fired after the contained edit control was created.")]
			void CreatedEditControlWindow(LONG hWndEdit);
			/// \brief <em>The drop-down list box control was created</em>
			///
			/// Will be fired after the drop-down list box control was created.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa DestroyedListBoxControlWindow, ListDropDown, IComboBox::hWndListBox
			[id(DISPID_CBE_CREATEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was created.")]
			void CreatedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IComboBox::hWnd
			[id(DISPID_CBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The contained edit control was destroyed</em>
			///
			/// Will be fired after the contained edit control was destroyed.
			///
			/// \param[in] hWndEdit The contained edit control's window handle.
			///
			/// \sa CreatedEditControlWindow, IComboBox::hWndEdit
			[id(DISPID_CBE_DESTROYEDEDITCONTROLWINDOW), helpstring("Will be fired after the contained edit control was destroyed.")]
			void DestroyedEditControlWindow(LONG hWndEdit);
			/// \brief <em>The drop-down list box control was destroyed</em>
			///
			/// Will be fired after the drop-down list box control was destroyed.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa CreatedListBoxControlWindow, ListCloseUp, IComboBox::hWndListBox
			[id(DISPID_CBE_DESTROYEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was destroyed.")]
			void DestroyedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>Any data associated with an item should be freed</em>
			///
			/// Will be fired if any data associated with the specified item should be freed.
			///
			/// \param[in] comboItem The item for which to free the data. If \c Nothing, all items' data should
			///            be freed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all items freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingItem, RemovedItem, IComboBoxItem::ItemData, IComboBox::DisabledEvents
			[id(DISPID_CBE_FREEITEMDATA), helpstring("Will be fired if any data associated with the specified item should be freed. This event may be disabled.")]
			void FreeItemData(IComboBoxItem* comboItem);
			/// \brief <em>An item was inserted</em>
			///
			/// Will be fired after a new item was inserted.
			///
			/// \param[in] comboItem The item that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingItem, RemovedItem, IComboBoxItem, IComboBox::DisabledEvents
			[id(DISPID_CBE_INSERTEDITEM), helpstring("Will be fired after a new item was inserted. This event may be disabled.")]
			void InsertedItem(IComboBoxItem* comboItem);
			/// \brief <em>An item is about to be inserted</em>
			///
			/// Will be fired before a new item is inserted.
			///
			/// \param[in] comboItem The item that is about to be inserted. If the combo box is sorted, this
			///            object's \c Index property may be wrong.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the item
			///                isn't inserted. If set to \c False, the item is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedItem, RemovingItem, IVirtualComboBoxItem::Index, IComboBox::Sorted,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_INSERTINGITEM), helpstring("Will be fired before a new item is inserted. This event may be disabled.")]
			void InsertingItem(IVirtualComboBoxItem* comboItem, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>The mouse cursor was moved into an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseLeave, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_ITEMMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseEnter(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseEnter, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_ITEMMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseLeave(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IComboBox::DisabledEvents
			[id(DISPID_CBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IComboBox::DisabledEvents
			[id(DISPID_CBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IComboBox::DisabledEvents
			[id(DISPID_CBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The control's drop-down list box window was closed</em>
			///
			/// Will be fired after the drop-down list box window has been closed.
			///
			/// \sa ListDropDown, IComboBox::CloseDropDownWindow, IComboBox::hWndListBox
			[id(DISPID_CBE_LISTCLOSEUP), helpstring("Will be fired after the drop-down list box window has been closed.")]
			void ListCloseUp(void);
			/// \brief <em>The control's drop-down list box window was opened</em>
			///
			/// Will be fired after the drop-down list box window has been opened (before it is made
			/// visible).
			///
			/// \sa ListCloseUp, IComboBox::OpenDropDownWindow, IComboBox::hWndListBox
			[id(DISPID_CBE_LISTDROPDOWN), helpstring("Will be fired after the drop-down list box window has been opened (before it is made visible).")]
			void ListDropDown(void);
			/// \brief <em>A mouse button was pressed over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseUp, MouseDown, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_LISTMOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseDown(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, ListMouseUp, ListMouseWheel, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_LISTMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseMove(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, MouseUp, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_LISTMOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseUp(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseMove, MouseWheel, HitTestConstants, ExtendedMouseButtonConstants,
			///     ScrollAxisConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_LISTMOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseWheel(IComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the drop-down list box control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragLeave, ListMouseUp, OLEDragDrop,
			///     IComboBox::RegisterForOLEDragDrop, IComboBox::FinishOLEDragDrop, OLEDropEffectConstants,
			///     IComboBox::SetListInsertMarkPosition, HitTestConstants
			[id(DISPID_CBE_LISTOLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the drop-down list box control's client area.")]
			void ListOLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragMouseMove, ListOLEDragLeave, ListOLEDragDrop, OLEDragEnter,
			///     IComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, IComboBox::ListDragScrollTimeBase,
			///     IComboBox::SetListInsertMarkPosition, HitTestConstants
			[id(DISPID_CBE_LISTOLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list box control's client area.")]
			void ListOLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the drop-down list
			/// box control's client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoCloseUp If set to \c True, the drop-down list box control will be closed
			///                automatically; otherwise not.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragDrop, OLEDragLeave,
			///     IComboBox::RegisterForOLEDragDrop, IComboBox::SetListInsertMarkPosition, HitTestConstants
			[id(DISPID_CBE_LISTOLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list box control's client area or if the user canceled the drag'n'drop operation.")]
			void ListOLEDragLeave(IOLEDataObject* data, IComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, VARIANT_BOOL* autoCloseUp);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragEnter, ListOLEDragLeave, ListOLEDragDrop, ListMouseMove, OLEDragMouseMove,
			///     IComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, IComboBox::ListDragScrollTimeBase,
			///     IComboBox::SetListInsertMarkPosition, HitTestConstants
			[id(DISPID_CBE_LISTOLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void ListOLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>An item's size is required in an owner-drawn combo box</em>
			///
			/// Will be fired if the \c OwnerDrawItems property is set to a value other than \c odiDontOwnerDraw
			/// and a combo box item's size needs to be known in preparation of drawing it.
			///
			/// \param[in] comboItem The item for which the size is required. If the event is raised for the
			///            selection field, this parameter will be \c Nothing.
			/// \param[out] itemHeight Must be set to the item's height in pixels.
			///
			/// \sa OwnerDrawItem, IComboBox::ItemHeight, IComboBoxItem::Height, IComboBox::OwnerDrawItems
			[id(DISPID_CBE_MEASUREITEM), helpstring("Will be fired if the 'OwnerDrawItems' property is set to a value other than 'odiDontOwnerDraw' and a combo box item's size needs to be known in preparation of drawing it.")]
			void MeasureItem(IComboBoxItem* comboItem, OLE_YSIZE_PIXELS* ItemHeight);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ListMouseDown, HitTestConstants,
			///     ExtendedMouseButtonConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IListBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IComboBox::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ListMouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ListMouseUp, HitTestConstants,
			///     ExtendedMouseButtonConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ListMouseWheel, ExtendedMouseButtonConstants, ScrollAxisConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ListOLEDragDrop,
			///     IComboBox::RegisterForOLEDragDrop, IComboBox::FinishOLEDragDrop, OLEDropEffectConstants,
			///     HitTestConstants
			[id(DISPID_CBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ListOLEDragEnter,
			///     IComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants,
			///     IComboBox::DragDropDownTime
			[id(DISPID_CBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ListOLEDragLeave,
			///     IComboBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_CBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ListOLEDragMouseMove,
			///     IComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants
			///     IComboBox::DragDropDownTime
			[id(DISPID_CBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the control cannot allocate enough memory to meet a specific request.
			[id(DISPID_CBE_OUTOFMEMORY), helpstring("Will be fired if the control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>An item must be drawn in an owner-drawn combo box</em>
			///
			/// Will be fired if the \c OwnerDrawItems property is set to a value other than \c odiDontOwnerDraw
			/// and a combo box item must be drawn.
			///
			/// \param[in] comboItem The item to draw. If the event is raised for the selection field, this
			///            parameter will be \c Nothing.
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] itemState Specifies the item's current state (focused, selected etc.). Most of
			///            the values defined by the \c OwnerDrawItemStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa MeasureItem, IComboBox::ItemHeight, IComboBoxItem::Height, IComboBox::OwnerDrawItems, RECTANGLE,
			///     OwnerDrawActionConstants, OwnerDrawItemStateConstants
			[id(DISPID_CBE_OWNERDRAWITEM), helpstring("Will be fired if the 'OwnerDrawItems' property is set to a value other than 'odiDontOwnerDraw' and a combo box item must be drawn.")]
			void OwnerDrawItem(IComboBoxItem* comboItem, OwnerDrawActionConstants requiredAction, OwnerDrawItemStateConstants itemState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IComboBox::DisabledEvents
			[id(DISPID_CBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IComboBox::hWnd
			[id(DISPID_CBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>An item was removed</em>
			///
			/// Will be fired after an item was removed.
			///
			/// \param[in] comboItem The item that was removed. If \c Nothing, all items were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingItem, InsertedItem, IVirtualComboBoxItem, IComboBox::DisabledEvents
			[id(DISPID_CBE_REMOVEDITEM), helpstring("Will be fired after an item was removed. If 'comboItem' is 'Nothing', all items were removed. This event may be disabled.")]
			void RemovedItem(IVirtualComboBoxItem* comboItem);
			/// \brief <em>An item is about to be removed</em>
			///
			/// Will be fired before an item is removed.
			///
			/// \param[in] comboItem The item that is about to be removed. If \c Nothing, all items are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the item isn't
			///                removed. If set to \c False, the item is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedItem, InsertingItem, IComboBoxItem, IComboBox::DisabledEvents
			[id(DISPID_CBE_REMOVINGITEM), helpstring("Will be fired before an item is removed. If 'comboItem' is 'Nothing', all items are removed. This event may be disabled.")]
			void RemovingItem(IComboBoxItem* comboItem, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_CBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user canceled changing the selected item</em>
			///
			/// Will be fired after the user canceled changing the selected item.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IComboBoxItem::Selected, IComboBox::SelectedItem, SelectionChanging, SelectionChanged
			[id(DISPID_CBE_SELECTIONCANCELED), helpstring("Will be fired after the user canceled changing the selected item. This event may be disabled.")]
			void SelectionCanceled(void);
			/// \brief <em>The user finished changing the selected item</em>
			///
			/// Will be fired after the user finished changing the selected item.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IComboBoxItem::Selected, IComboBox::SelectedItem, SelectionChanged, SelectionCanceled
			[id(DISPID_CBE_SELECTIONCHANGING), helpstring("Will be fired after the user finished changing the selected item. This event may be disabled.")]
			void SelectionChanging(void);
			/// \brief <em>The control's text was changed</em>
			///
			/// Will be fired after the contained edit control's content was changed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IComboBox::Text
			[id(DISPID_CBE_TEXTCHANGED), helpstring("Will be fired after the contained edit control's content was changed. This event may be disabled.")]
			void TextChanged(void);
			/// \brief <em>The text, that was entered into the control, got truncated</em>
			///
			/// Will be fired if the text, that was entered into the contained edit control, got truncated. This
			/// happens in the following situations:
			/// - The control's resulting text would have been longer than allowed by the \c MaxTextLength
			///   property.
			/// - The control would have to scroll horizontally to display the entered text, but the
			///   \c AutoHorizontalScrolling property is set to \c False.
			///
			/// \sa IComboBox::Text, IComboBox::MaxTextLength, IComboBox::AutoHorizontalScrolling
			[id(DISPID_CBE_TRUNCATEDTEXT), helpstring("Will be fired if the text, that was entered into the contained edit control, got truncated.")]
			void TruncatedText(void);
			/// \brief <em>The control's writing direction has been changed by the user</em>
			///
			/// Will be fired if the contained edit control's writing direction has been changed by the user.
			///
			/// \param[in] newWritingDirection The control's new writing direction. Any of the values defined by
			///            the \c WritingDirectionConstants enumeration is valid.
			///
			/// \remarks Due to limitations of Microsoft Windows, this event is not raised if the writing
			///          direction is changed using the contained edit control's default context menu.
			///
			/// \sa IComboBox::RightToLeft, WritingDirectionConstants
			[id(DISPID_CBE_WRITINGDIRECTIONCHANGED), helpstring("Will be fired if the control's writing direction has been changed by the user.")]
			void WritingDirectionChanged(WritingDirectionConstants newWritingDirection);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IComboBox::DisabledEvents
			[id(DISPID_CBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ComboBox class</em>
	///
	/// The control's main COM class. It implements the \c IComboBox and
	/// \c _IComboBoxEvents interfaces.
	///
	/// \sa IComboBox, _IComboBoxEvents
	[
		uuid(5EA02E84-47EA-4e86-8C93-1E18D38945DA),
		version(1.5),
		helpstring("ComboBox Control 1.5 (Unicode)")
	]
	coclass ComboBox
	{
		[default] interface IComboBox;
		[default, source] dispinterface _IComboBoxEvents;
	};


	/// \interface IVirtualDriveComboBoxItem
	/// \brief <em>Wraps a not existing item</em>
	///
	/// This interface is a wrapper around an drive combo box item that does not yet or not anymore exist
	/// within the control.
	///
	/// \sa _IVirtualDriveComboBoxItemEvents, IDriveComboBoxItem, _IDriveComboBoxEvents
	[
		object,
		uuid(711B793F-03F8-4a1b-922F-F1FFA4EF1BDB),
		dual,
		nonextensible,
		helpstring("IVirtualDriveComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IVirtualDriveComboBoxItem : IDispatch
	{
		/// \brief <em>Retrieves the drive's type</em>
		///
		/// Retrieves the drive's type. Any of the values defined by the \c DriveTypeConstants enumeration
		/// is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Path, DriveTypeConstants
		[propget, id(DISPID_VDCBI_DRIVETYPE), helpstring("Retrieves the drive's type."), nonbrowsable]
		HRESULT DriveType([out, retval] DriveTypeConstants* pValue);
		/// \brief <em>Retrieves the item's icon</em>
		///
		/// Retrieves the zero-based index of the item's icon in the control's \c ilItems image list. If set to
		/// -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. If set to -2, no icon will be or was displayed for this item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo,
		///     SelectedIconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_VDCBI_ICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's indentation</em>
		///
		/// Retrieves the item's indentation in steps of 10 pixels. If set to 1, the item's indentation will be
		/// 10 pixels; if set to 2, it will be 20 pixels and so on. If set to -1, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IDriveComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_VDCBI_INDENT), helpstring("Retrieves the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves the zero-based index that will identify or has identified the item.
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_VDCBI_INDEX), helpstring("Retrieves the item's zero-based index."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IDriveComboBoxEvents::FreeItemData
		[propget, id(DISPID_VDCBI_ITEMDATA), helpstring("Retrieves the Long value associated with the item."), nonbrowsable]
		HRESULT ItemData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's icon</em>
		///
		/// Retrieves the one-based index of the item's overlay icon in the control's \c ilItems image list. If
		/// set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. An index of 0 means that no overlay will be or was drawn for this item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     SelectedIconIndex, ImageListConstants
		[propget, id(DISPID_VDCBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the drive's path</em>
		///
		/// Retrieves the drive's path.
		///
		/// \remarks This is the default property of the \c IVirtualDriveComboBoxItem interface.\n
		///          This property is read-only.
		///
		/// \sa DriveType, Text
		[propget, id(DISPID_VDCBI_PATH), helpstring("Retrieves the drive's path."), nonbrowsable]
		HRESULT Path([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the icon that is displayed next to the item if the item is selected</em>
		///
		/// Retrieves the zero-based index of the item's selected icon in the control's \c ilItems image list.
		/// The selected icon is used instead of the normal icon identified by the \c IconIndex property if the
		/// item is the selected item. If set to -1, the control will fire the \c ItemGetDisplayInfo event each
		/// time this property's value is required.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo,
		///     IconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_VDCBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's text</em>
		///
		/// Retrieves the item's text. If set to \c vbNullString, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Path, _IDriveComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_VDCBI_TEXT), helpstring("Retrieves the item's text. If set to 'vbNullString', the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT Text([out, retval] BSTR* pValue);
	}


	/// \interface _IVirtualDriveComboBoxItemEvents
	/// \brief <em>The \c VirtualDriveComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c VirtualDriveComboBoxItem class may raise.
	///
	/// \sa IVirtualDriveComboBoxItem
	[
		uuid(C6591928-96FE-4bad-8B84-575FFA63AA88),
		helpstring("IVirtualDriveComboBoxItem-event-interface")
	]
	dispinterface _IVirtualDriveComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualDriveComboBoxItem class</em>
	///
	/// This COM class implements the \c IVirtualDriveComboBoxItem and \c _IVirtualDriveComboBoxItemEvents
	/// interfaces.
	///
	/// \sa IVirtualDriveComboBoxItem, _IVirtualDriveComboBoxItemEvents, DriveComboBox, DriveComboBoxItem
	[
		uuid(AC0CD3EB-14BD-4674-8BC0-B333924D0BB8),
		version(1.0),
		noncreatable,
		helpstring("VirtualDriveComboBoxItem Class 1.0 (Unicode)")
	]
	coclass VirtualDriveComboBoxItem
	{
		[default] interface IVirtualDriveComboBoxItem;
		[default, source] dispinterface _IVirtualDriveComboBoxItemEvents;
	};


	/// \interface IDriveComboBoxItem
	/// \brief <em>Wraps an existing drive combo box item</em>
	///
	/// This interface is a wrapper around an item that - unlike an item wrapped by
	/// \c IVirtualDriveComboBoxItem - really exists within the control.
	///
	/// \sa _IDriveComboBoxItemEvents, IVirtualDriveComboBoxItem, IDriveComboBoxItems,
	///     IDriveComboBoxItemContainer, IDriveComboBox, _IDriveComboBoxEvents
	[
		object,
		uuid(9A31484E-B59B-4058-92D9-F2A54F0DD6D6),
		dual,
		nonextensible,
		helpstring("IDriveComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IDriveComboBoxItem : IDispatch
	{
		/// \brief <em>Retrieves the drive's type</em>
		///
		/// Retrieves the drive's type. Any of the values defined by the \c DriveTypeConstants enumeration
		/// is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Path, DriveTypeConstants
		[propget, id(DISPID_DCBI_DRIVETYPE), helpstring("Retrieves the drive's type."), nonbrowsable]
		HRESULT DriveType([out, retval] DriveTypeConstants* pValue);
		/// \brief <em>Specifies the item's height</em>
		///
		/// Retrieves or sets the item's height in pixels.
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetRectangle, IDriveComboBox::ItemHeight
		[propget, id(DISPID_DCBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBox.ItemHeight' property instead.")]
		HRESULT Height([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Specifies the item's icon</em>
		///
		/// Retrieves or sets the zero-based index of the item's icon in the control's \c ilItems image list.
		/// If set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value
		/// is required.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo,
		///     SelectedIconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_DCBI_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the item's icon in the control's 'ilItems' image list. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_DCBI_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the item's icon in the control's 'ilItems' image list. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Retrieves the item's ID</em>
		///
		/// Retrieves an unique ID identifying this item.
		///
		/// \remarks An item's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, ItemIdentifierTypeConstants
		[propget, id(DISPID_DCBI_ID), helpstring("Retrieves the item's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's indentation</em>
		///
		/// Retrieves or sets the item's indentation in steps of 10 pixels. If set to 1, the item's indentation
		/// will be 10 pixels; if set to 2, it will be 20 pixels and so on. If set to -1, the control will fire
		/// the \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \sa _IDriveComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_DCBI_INDENT), helpstring("Retrieves or sets the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_DCBI_INDENT), helpstring("Retrieves or sets the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves a zero-based index identifying this item.
		///
		/// \remarks Although adding or removing items changes other items' indexes, the index is the best
		///          (and fastest) option to identify an item.\n
		///          This property is read-only.
		///
		/// \sa ID, ItemIdentifierTypeConstants
		[propget, id(DISPID_DCBI_INDEX), helpstring("Retrieves the item's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the item. Use this property to associate
		/// any data with the item.
		///
		/// \sa _IDriveComboBoxEvents::FreeItemData
		[propget, id(DISPID_DCBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([out, retval] LONG* pValue);
		[propput, id(DISPID_DCBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([in] LONG newValue);
		/// \brief <em>Specifies the item's overlay icon</em>
		///
		/// Retrieves the one-based index of the item's overlay icon in the control's \c ilItems image list. If
		/// set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. An index of 0 means that no overlay is drawn for this item.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     SelectedIconIndex, ImageListConstants
		[propget, id(DISPID_DCBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's 'ilItems' image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_DCBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's 'ilItems' image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([in] LONG newValue);
		/// \brief <em>Retrieves the drive's path</em>
		///
		/// Retrieves the drive's path.
		///
		/// \remarks This is the default property of the \c IDriveComboBoxItem interface.\n
		///          This property is read-only.
		///
		/// \sa DriveType, Text
		[propget, id(DISPID_DCBI_PATH), helpstring("Retrieves the drive's path."), nonbrowsable]
		HRESULT Path([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the item is selected</em>
		///
		/// Retrieves whether the item is the currently selected item. If this property is set to \c True, the
		/// item is selected; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IDriveComboBox::SelectedItem
		[propget, id(DISPID_DCBI_SELECTED), helpstring("Retrieves whether the item is the currently selected item.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the icon that is displayed next to the item if the item is selected</em>
		///
		/// Retrieves or sets the zero-based index of the item's selected icon in the control's \c ilItems
		/// image list. The selected icon is used instead of the normal icon identified by the \c IconIndex
		/// property if the item is the selected item. If set to -1, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \sa IDriveComboBox::hImageList, _IDriveComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     OverlayIndex, ImageListConstants
		[propget, id(DISPID_DCBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_DCBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([in] LONG newValue);
		/// \brief <em>Specifies the item's text</em>
		///
		/// Retrieves or sets the item's text. If set to \c vbNullString, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \sa Path, _IDriveComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_DCBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_DCBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([in] BSTR newValue);

		/// \brief <em>Retrieves an image list containing the item's drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of this item.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return The handle to the image list containing the drag image.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_DCBI_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of this item.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Retrieves the bounding rectangle of either the item or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client
		/// area) of either the item or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c ItemRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the drop-down list box control's upper-left corner.
		///
		/// \sa Height, ItemRectangleTypeConstants
		[id(DISPID_DCBI_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client area) of either the item or a part of it.")]
		HRESULT GetRectangle(ItemRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
	}


	/// \interface _IDriveComboBoxItemEvents
	/// \brief <em>The \c DriveComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c DriveComboBoxItem class may raise.
	///
	/// \sa IDriveComboBoxItem
	[
		uuid(40E570A3-2F72-4035-B85B-0D723865C7D8),
		helpstring("IDriveComboBoxItem-event-interface")
	]
	dispinterface _IDriveComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c DriveComboBoxItem class</em>
	///
	/// This COM class implements the \c IDriveComboBoxItem and \c _IDriveComboBoxItemEvents interfaces.
	///
	/// \sa IDriveComboBoxItem, _IDriveComboBoxItemEvents, DriveComboBox, DriveComboBoxItems
	[
		uuid(6FEF9951-E954-403c-9C8B-B72D0A79F0A8),
		version(1.5),
		noncreatable,
		helpstring("DriveComboBoxItem Class 1.5 (Unicode)")
	]
	coclass DriveComboBoxItem
	{
		[default] interface IDriveComboBoxItem;
		[default, source] dispinterface _IDriveComboBoxItemEvents;
	};


	/// \interface IDriveComboBoxItems
	/// \brief <em>Manages a collection of \c DriveComboBoxItem objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c DriveComboBoxItem
	/// objects. While a \c DriveComboBoxItemContainer object is used to group any items and acts more like
	/// a clipboard, a \c DriveComboBoxItems object is used to group items that have certain properties in
	/// common.
	///
	/// \sa _IDriveComboBoxItemsEvents, IDriveComboBoxItem, IDriveComboBoxItemContainer, IDriveComboBox
	[
		object,
		uuid(493DB29A-192A-4972-8DF2-D6C4BA897CD8),
		dual,
		nonextensible,
		helpstring("IDriveComboBoxItems interface"),
		pointer_default(unique)
	]
	interface IDriveComboBoxItems : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on an item,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_DCBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets an item filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal itemProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_DCBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_DCBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets an item filter.\n
		/// An \c IComboBoxItems collection can be filtered by any of \c IComboBoxItem's properties, that
		/// the \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple
		/// filters are possible, too. A filter is a \c Variant containing an array whose elements are of
		/// type \c Variant. Each element of this array contains a valid value for the property, that the
		/// filter refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_DCBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_DCBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets an item filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_DCBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_DCBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c DriveComboBoxItem object from the collection</em>
		///
		/// Retrieves a \c DriveComboBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be retrieved.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IDriveComboBoxItems interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, Remove, Contains
		[propget, id(DISPID_DCBIS_ITEM), helpstring("Retrieves a 'DriveComboBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IDriveComboBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c DriveComboBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_DCBIS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Retrieves whether the specified item is part of the item collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the item to be checked.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified item is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Remove, ItemIdentifierTypeConstants
		[id(DISPID_DCBIS_CONTAINS), helpstring("Retrieves whether the specified item is part of the item collection.")]
		HRESULT Contains([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c DriveComboBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Remove, RemoveAll
		[id(DISPID_DCBIS_COUNT), helpstring("Retrieves the number of 'DriveComboBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified item in the collection from the combo box</em>
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be removed.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Count, RemoveAll, Contains, ItemIdentifierTypeConstants
		[id(DISPID_DCBIS_REMOVE), helpstring("Removes the specified item in the collection from the control.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType);
		/// \brief <em>Removes all items in the collection from the combo box</em>
		///
		/// \sa Count, Remove
		[id(DISPID_DCBIS_REMOVEALL), helpstring("Removes all items in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IDriveComboBoxItemsEvents
	/// \brief <em>The \c DriveComboBoxItems class' events interface</em>
	///
	/// This interface defines all events the \c DriveComboBoxItems class may raise.
	///
	/// \sa IDriveComboBoxItems
	[
		uuid(F763D253-CDC1-463b-BB04-CBE2127540A3),
		helpstring("IDriveComboBoxItems-event-interface")
	]
	dispinterface _IDriveComboBoxItemsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c DriveComboBoxItems class</em>
	///
	/// This COM class implements the \c IDriveComboBoxItems and \c _IDriveComboBoxItemsEvents interfaces.
	///
	/// \sa IDriveComboBoxItems, _IDriveComboBoxItemsEvents, DriveComboBox, DriveComboBoxItem
	[
		uuid(084A6EE0-F1E0-4642-BFD5-E32E4A1BA4AE),
		version(1.5),
		noncreatable,
		helpstring("DriveComboBoxItems Class 1.5 (Unicode)")
	]
	coclass DriveComboBoxItems
	{
		[default] interface IDriveComboBoxItems;
		[default, source] dispinterface _IDriveComboBoxItemsEvents;
	};


	/// \interface IDriveComboBoxItemContainer
	/// \brief <em>Manages a collection of \c DriveComboBoxItem objects</em>
	///
	/// This interface provides easy access to collections of \c DriveComboBoxItem objects. While a
	/// \c DriveComboBoxItems object is used to group items that have certain properties in common, a
	/// \c DriveComboBoxItemContainer object is used to group any items and acts more like a clipboard.
	///
	/// \sa _IDriveComboBoxItemContainerEvents, IDriveComboBoxItem, IDriveComboBoxItems, IDriveComboBox
	[
		object,
		uuid(FFE6BB93-B73A-450f-BE18-8D4573273BF2),
		dual,
		nonextensible,
		helpstring("IDriveComboBoxItemContainer interface"),
		pointer_default(unique)
	]
	interface IDriveComboBoxItemContainer : IDispatch
	{
		/// \brief <em>Retrieves a \c DriveComboBoxItem object from the collection</em>
		///
		/// Retrieves a \c DriveComboBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to retrieve.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID.
		///
		/// \remarks This is the default property of the \c IDriveComboBoxItemContainer interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, IDriveComboBoxItem::ID, Add, Remove
		[propget, id(DISPID_DCBIC_ITEM), helpstring("Retrieves a 'DriveComboBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IDriveComboBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c DriveComboBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_DCBIC__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds the specified item(s) to the collection</em>
		///
		/// \param[in] items The item(s) to add. May be either an item ID, a \c DriveComboBoxItem object or a
		///            \c DriveComboBoxItems collection.
		///
		/// \sa IDriveComboBoxItem::ID, Count, Remove, RemoveAll
		[id(DISPID_DCBIC_ADD), helpstring("Adds the specified item(s) to the collection.")]
		HRESULT Add([in] VARIANT Items);
		/// \brief <em>Clones the collection object</em>
		///
		/// Retrieves an exact copy of the collection.
		///
		/// \return The cloned object.
		///
		/// \sa IDriveComboBox::CreateItemContainer
		[id(DISPID_DCBIC_CLONE), helpstring("Creates an exact copy of the collection.")]
		HRESULT Clone([out, retval] IDriveComboBoxItemContainer** ppClone);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c DriveComboBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_DCBIC_COUNT), helpstring("Retrieves the number of 'DriveComboBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Retrieves an image list containing the items' common drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of the items of this collection.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return: The handle to the image list containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_DCBIC_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of the items of this collection.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Removes the specified item from the collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to remove.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID.
		/// \param[in] removePhysically If \c True, the item is removed from the control, too.
		///
		/// \sa IDriveComboBoxItem::ID, Add, Count, RemoveAll, ItemIdentifierTypeConstants
		[id(DISPID_DCBIC_REMOVE), helpstring("Removes the specified item from the collection.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [in, defaultvalue(0)] VARIANT_BOOL removePhysically);
		/// \brief <em>Removes all items from the collection</em>
		///
		/// \param[in] removePhysically If \c True, the items are removed from the control, too.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_DCBIC_REMOVEALL), helpstring("Removes all items from the collection.")]
		HRESULT RemoveAll([in, defaultvalue(0)] VARIANT_BOOL removePhysically);
	}


	/// \interface _IDriveComboBoxItemContainerEvents
	/// \brief <em>The \c DriveComboBoxItemContainer class' events interface</em>
	///
	/// This interface defines all events the \c DriveComboBoxItemContainer class may raise.
	///
	/// \sa IDriveComboBoxItemContainer
	[
		uuid(86598639-4E17-4bd6-8B12-58BD44775289),
		helpstring("IDriveComboBoxItemContainer-event-interface")
	]
	dispinterface _IDriveComboBoxItemContainerEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c DriveComboBoxItemContainer class</em>
	///
	/// This COM class implements the \c IDriveComboBoxItemContainer and
	/// \c _IDriveComboBoxItemContainerEvents interfaces.
	///
	/// \sa IDriveComboBoxItemContainer, _IDriveComboBoxItemContainerEvents, DriveComboBox, DriveComboBoxItem
	[
		uuid(B6958570-7C40-492d-BC7A-C0BF45E422D5),
		version(1.5),
		noncreatable,
		helpstring("DriveComboBoxItemContainer Class 1.5 (Unicode)")
	]
	coclass DriveComboBoxItemContainer
	{
		[default] interface IDriveComboBoxItemContainer;
		[default, source] dispinterface _IDriveComboBoxItemContainerEvents;
	};


	/// \interface IDriveComboBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the drive combo box control's main interface. It wraps the control window.
	///
	/// \sa _IDriveComboBoxEvents
	[
		object,
		uuid(2731AA87-BE3C-42bc-9DF6-5B10F16584EB),
		dual,
		nonextensible,
		helpstring("IDriveComboBox interface"),
		pointer_default(unique)
	]
	interface IDriveComboBox : IDispatch
	{
		// \brief <em>Controls the style of the control's outer border</em>
		//
		// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		// by the \c AppearanceConstants enumeration is valid.
		//
		// \sa BorderStyle, AppearanceConstants
		//[propget, id(DISPID_DCB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		//HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		//[propput, id(DISPID_DCB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		//HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks Starting with comctl32.dll version 6.10, this property is ignored.
		///
		/// \sa ForeColor
		// \sa ForeColor, ListBackColor
		[propget, id(DISPID_DCB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_DCB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		// \brief <em>Controls the style of the control's inner border</em>
		//
		// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		// defined by the \c BorderStyleConstants enumeration is valid.
		//
		// \sa Appearance, BorderStyleConstants
		//[propget, id(DISPID_DCB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		//HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		//[propput, id(DISPID_DCB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		//HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether string comparisons are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are executed when searching for an item by its
		/// text, are case sensitive. If set to \c True, the comparisons are case sensitive; otherwise not.
		///
		/// \sa FindItemByText, SelectItemByText
		[propget, id(DISPID_DCB_CASESENSITIVEITEMSEARCHING), helpstring("Retrieves or sets whether string comparisons, that are executed when searching for an item by its text, are case sensitive.")]
		HRESULT CaseSensitiveItemSearching([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_CASESENSITIVEITEMSEARCHING), helpstring("Retrieves or sets whether string comparisons, that are executed when searching for an item by its text, are case sensitive.")]
		HRESULT CaseSensitiveItemSearching([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the control's items</em>
		///
		/// Retrieves a collection object wrapping the combo box items.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IDriveComboBoxItems
		[propget, id(DISPID_DCB_COMBOITEMS), helpstring("Retrieves a collection object wrapping the control's items."), nonbrowsable]
		HRESULT ComboItems([out, retval] IDriveComboBoxItems** ppItems);
		/// \brief <em>Specifies the control's textual cue</em>
		///
		/// Retrieves or sets the control's textual cue.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text
		[propget, id(DISPID_DCB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([out, retval] BSTR* pValue);
		[propput, id(DISPID_DCB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([in] BSTR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_DCB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_DCB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Specifies which drive types are displayed by the control</em>
		///
		/// Retrieves or sets the drive types that will be displayed by the control. Any combination of the
		/// values defined by the \c DriveTypeConstants enumeration is valid.
		///
		/// \sa DisplayNameStyle, DriveTypesWithVolumeName, IDriveComboBoxItem::DriveType, DriveTypeConstants
		[propget, id(DISPID_DCB_DISPLAYEDDRIVETYPES), helpstring("Retrieves or sets the drive types that will be displayed by the control."), nonbrowsable]
		HRESULT DisplayedDriveTypes([out, retval] DriveTypeConstants* pValue);
		[propput, id(DISPID_DCB_DISPLAYEDDRIVETYPES), helpstring("Retrieves or sets the drive types that will be displayed by the control."), nonbrowsable]
		HRESULT DisplayedDriveTypes([in] DriveTypeConstants newValue);
		/// \brief <em>Controls how drives are displayed by the control</em>
		///
		/// Retrieves or sets the pattern for the drive items' text. Any of the values defined by the
		/// \c DisplayNameStyleConstants enumeration is valid.
		///
		/// \sa DisplayedDriveTypes, DriveTypesWithVolumeName, DisplayNameStyleConstants
		[propget, id(DISPID_DCB_DISPLAYNAMESTYLE), helpstring("Retrieves or sets the pattern for the drive items' text.")]
		HRESULT DisplayNameStyle([out, retval] DisplayNameStyleConstants* pValue);
		[propput, id(DISPID_DCB_DISPLAYNAMESTYLE), helpstring("Retrieves or sets the pattern for the drive items' text.")]
		HRESULT DisplayNameStyle([in] DisplayNameStyleConstants newValue);
		/// \brief <em>Specifies whether overlay icons are displayed</em>
		///
		/// Retrieves or sets whether overlay icons are displayed, for example, an image of a hand can be drawn
		/// over the drive icon if the drive is shared. If set to \c True, such overlay icons are displayed;
		/// otherwise not.
		///
		/// \sa hImageList, UseSystemImageList, IDriveComboBoxItem::OverlayIndex
		[propget, id(DISPID_DCB_DISPLAYOVERLAYIMAGES), helpstring("Retrieves or sets whether overlay icons are displayed, for example, an image of a hand can be drawn over the drive icon if the drive is shared.")]
		HRESULT DisplayOverlayImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_DISPLAYOVERLAYIMAGES), helpstring("Retrieves or sets whether overlay icons are displayed, for example, an image of a hand can be drawn over the drive icon if the drive is shared.")]
		HRESULT DisplayOverlayImages([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_DCB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control tries to work-around character set problems related to filenames</em>
		///
		/// Retrieves or sets whether the control's text is converted from the Windows character set to the OEM
		/// character set and then back to the Windows character set. Such a conversion ensures proper
		/// character conversion when the application calls the \c CharToOem function to convert a Windows
		/// string in the control to OEM characters. This property is most useful if the control contains file
		/// names that will be used on file systems that do not support Unicode.\n
		/// If set to \c True, the conversion is performed; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Text,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647473.aspx">CharToOem</a>
		[propget, id(DISPID_DCB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic opening of the drop-down list box control during drag'n'drop</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down
		/// button during a drag'n'drop operation before the drop-down list box control will be opened
		/// automatically. If set to 0, automatic drop-down is disabled. If set to -1, the system's
		/// double-click time, multiplied with 4, is used.
		///
		/// \sa RegisterForOLEDragDrop, ListDragScrollTimeBase, _IDriveComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_DCB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([out, retval] LONG* pValue);
		[propput, id(DISPID_DCB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([in] LONG newValue);
		/// \brief <em>Specifies for which drive types the volume name may be retrieved</em>
		///
		/// Retrieves or sets the drive types for which the control will retrieve the volume name if the
		/// \c DisplayNameStyle property is set to a value that includes the volume name. Any combination of
		/// the values defined by the \c DriveTypeConstants enumeration is valid.
		///
		/// \attention Retrieving the volume name usually involves disk access which may be slow, especially
		///            for floppy and optical drives.
		///
		/// \sa DisplayNameStyle, DisplayedDriveTypes, IDriveComboBoxItem::DriveType, DriveTypeConstants
		[propget, id(DISPID_DCB_DRIVETYPESWITHVOLUMENAME), helpstring("Retrieves or sets the drive types for which the control will retrieve the volume name if the 'DisplayNameStyle' property is set to a value that includes the volume name."), nonbrowsable]
		HRESULT DriveTypesWithVolumeName([out, retval] DriveTypeConstants* pValue);
		[propput, id(DISPID_DCB_DRIVETYPESWITHVOLUMENAME), helpstring("Retrieves or sets the drive types for which the control will retrieve the volume name if the 'DisplayNameStyle' property is set to a value that includes the volume name."), nonbrowsable]
		HRESULT DriveTypesWithVolumeName([in] DriveTypeConstants newValue);
		/// \brief <em>Retrieves the accessibility object state of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the accessibility object state of the drop-down button which is displayed if the \c Style
		/// property is set to \c sComboDropDownList or \c sDropDownList. For a list of possible object states
		/// see the <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">MSDN article</a>.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IsDroppedDown,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">Accessibility Object State Constants</a>
		[propget, id(DISPID_DCB_DROPDOWNBUTTONOBJECTSTATE), helpstring("Retrieves the accessibility object state of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'."), nonbrowsable]
		HRESULT DropDownButtonObjectState([out, retval] LONG* pValue);
		/// \brief <em>Specifies which key opens the drop-down window</em>
		///
		/// Retrieves or sets the key that opens the drop-down window when pressed. Any of the values defined
		/// by the \c DropDownKeyConstants enumeration is valid.
		///
		/// \sa DropDownKeyConstants
		[propget, id(DISPID_DCB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([out, retval] DropDownKeyConstants* pValue);
		[propput, id(DISPID_DCB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([in] DropDownKeyConstants newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_DCB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the first item that is displayed in the drop-down list box control's client area</em>
		///
		/// Retrieves or sets the first combo box item, that is entirely located within the drop-down list box
		/// control's client area and therefore visible to the user.
		///
		/// \sa ComboItems
		[propget, id(DISPID_DCB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([out, retval] IDriveComboBoxItem** ppFirstItem);
		[propputref, id(DISPID_DCB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([in] IDriveComboBoxItem* pNewFirstItem);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont
		// \sa UseSystemFont, ListForeColor
		[propget, id(DISPID_DCB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_DCB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_DCB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor
		// \sa BackColor, ListForeColor
		[propget, id(DISPID_DCB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_DCB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies which parts of OLE drag'n'drop are handled automatically by the control</em>
		///
		/// Retrieves or sets which parts of OLE drag'n'drop are handled automatically. Any combination of the
		/// values defined by the \c HandleOLEDragDropConstants enumeration is valid.
		///
		/// \sa HandleOLEDragDropConstants
		[propget, id(DISPID_DCB_HANDLEOLEDRAGDROP), helpstring("Retrieves or sets which parts of OLE drag'n'drop are handled automatically.")]
		HRESULT HandleOLEDragDrop([out, retval] HandleOLEDragDropConstants* pValue);
		[propput, id(DISPID_DCB_HANDLEOLEDRAGDROP), helpstring("Retrieves or sets which parts of OLE drag'n'drop are handled automatically.")]
		HRESULT HandleOLEDragDrop([in] HandleOLEDragDropConstants newValue);
		/// \brief <em>Specifies one of the control's associated image list</em>
		///
		/// Retrieves or sets the handle of the specified image list.
		///
		/// \param[in] image list The image list to retrieve or set. Any of the values defined by the
		///            \c ImageListConstants enumeration is valid.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa IconVisibility, UseSystemImageList, ImageListConstants
		[propget, id(DISPID_DCB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_DCB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IDriveComboBoxEvents::MouseHover
		[propget, id(DISPID_DCB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_DCB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndComboBox, hWndListBox, hWndShellUIParentWindow,
		///     _IDriveComboBoxEvents::RecreatedControlWindow, _IDriveComboBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_DCB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained combo box control's window handle</em>
		///
		/// Retrieves the contained combo box control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndListBox, _IDriveComboBoxEvents::CreatedComboBoxControlWindow,
		///     _IDriveComboBoxEvents::DestroyedComboBoxControlWindow
		[propget, id(DISPID_DCB_HWNDCOMBOBOX), helpstring("Retrieves the contained combo box control's window handle."), nonbrowsable]
		HRESULT hWndComboBox([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the drop-down list box control's window handle</em>
		///
		/// Retrieves the drop-down list box control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndComboBox, _IDriveComboBoxEvents::CreatedListBoxControlWindow,
		///     _IDriveComboBoxEvents::DestroyedListBoxControlWindow, _IDriveComboBoxEvents::ListDropDown,
		///     _IDriveComboBoxEvents::ListCloseUp
		[propget, id(DISPID_DCB_HWNDLISTBOX), helpstring("Retrieves the drop-down list box control's window handle."), nonbrowsable]
		HRESULT hWndListBox([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the parent window of any UI displayed by the shell</em>
		///
		/// Retrieves or sets the handle of the window that is used as parent window for any UI that the
		/// shell may display.
		///
		/// \remarks If this property is set to 0, many UI isn't displayed at all.
		///
		/// \sa hWnd
		[propget, id(DISPID_DCB_HWNDSHELLUIPARENTWINDOW), helpstring("Retrieves or sets the handle of the window that is used as parent window for any UI that the shell may display."), nonbrowsable]
		HRESULT hWndShellUIParentWindow([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_DCB_HWNDSHELLUIPARENTWINDOW), helpstring("Retrieves or sets the handle of the window that is used as parent window for any UI that the shell may display."), nonbrowsable]
		HRESULT hWndShellUIParentWindow([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies whether item icons are displayed</em>
		///
		/// Retrieves or sets whether the item's icons are displayed. Any of the values defined by the
		/// \c IconVisibilityConstants enumeration is valid.
		///
		/// \sa hImageList, IconVisibilityConstants
		[propget, id(DISPID_DCB_ICONVISIBILITY), helpstring("Retrieves or sets whether the item's icons are displayed.")]
		HRESULT IconVisibility([out, retval] IconVisibilityConstants* pValue);
		[propput, id(DISPID_DCB_ICONVISIBILITY), helpstring("Retrieves or sets whether the item's icons are displayed.")]
		HRESULT IconVisibility([in] IconVisibilityConstants newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_DCB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_DCB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		// \brief <em>Specifies whether the control displays partial items</em>
		//
		// Retrieves or sets whether the control resizes itself so that an integral number of items is
		// displayed. If set to \c True, an integral number of items is displayed and the control's height
		// may be changed to achieve this; otherwise partial items may be displayed.
		//
		// \attention Changing this property destroys and recreates the control window.
		//
		// \sa ItemHeight
		//[propget, id(DISPID_DCB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		//HRESULT IntegralHeight([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_DCB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		//HRESULT IntegralHeight([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves whether the drop-down list box control is currently displayed</em>
		///
		/// Retrieves whether the drop-down list box control is currently displayed. If \c True, the list box
		/// is displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa DropDownButtonObjectState
		[propget, id(DISPID_DCB_ISDROPPEDDOWN), helpstring("Retrieves whether the drop-down list box control is currently displayed."), nonbrowsable]
		HRESULT IsDroppedDown([out, retval] VARIANT_BOOL* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_DCB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies all items' height</em>
		///
		/// Retrieves or sets the items' height in pixels. If set to -1, the default setting is used.
		///
		/// \sa IDriveComboBoxItem::Height, SelectionFieldHeight
		// \sa IntegralHeight, IDriveComboBoxItem::Height, SelectionFieldHeight
		[propget, id(DISPID_DCB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels.")]
		HRESULT ItemHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_DCB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels.")]
		HRESULT ItemHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the visibility of the vertical scroll bar in the drop-down list box control</em>
		///
		/// Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled
		/// instead of hidden if the control does not contain enough items to scroll. If set to \c True, the
		/// scroll bar is disabled; otherwise it is hidden.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ComboItems
		// \sa ComboItems, ListScrollableWidth
		[propget, id(DISPID_DCB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([in] VARIANT_BOOL newValue);
		// \brief <em>Specifies the drop-down list box control's background color</em>
		//
		// Retrieves or sets the drop-down list box control's background color.
		//
		// \sa ListForeColor, BackColor
		//[propget, id(DISPID_DCB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		//HRESULT ListBackColor([out, retval] OLE_COLOR* pValue);
		//[propput, id(DISPID_DCB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		//HRESULT ListBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa RegisterForOLEDragDrop, _IDriveComboBoxEvents::ListOLEDragMouseMove
		[propget, id(DISPID_DCB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_DCB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([in] LONG newValue);
		// \brief <em>Specifies the drop-down list box control's text color</em>
		//
		// Retrieves or sets the drop-down list box control's text color.
		//
		// \sa ListBackColor, ForeColor
		//[propget, id(DISPID_DCB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		//HRESULT ListForeColor([out, retval] OLE_COLOR* pValue);
		//[propput, id(DISPID_DCB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		//HRESULT ListForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the height of the drop-down list box</em>
		///
		/// Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting
		/// is used.
		///
		/// \sa ListWidth
		// \sa ListWidth, MinVisibleItems
		[propget, id(DISPID_DCB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_DCB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([in] OLE_YSIZE_PIXELS newValue);
		// \brief <em>Specifies the width by which the drop-down list box can be scrolled horizontally</em>
		//
		// Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled
		// horizontally. If the width of the control is greater than this value, a horizontal scroll bar is
		// displayed.
		//
		// \sa ListAlwaysShowVerticalScrollBar, ListWidth
		//[propget, id(DISPID_DCB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		//HRESULT ListScrollableWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		//[propput, id(DISPID_DCB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		//HRESULT ListScrollableWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the width of the drop-down list box</em>
		///
		/// Retrieves or sets the width in pixels of the drop-down list box.
		///
		/// \remarks The minimum width of the drop-down list box is the combo box width.
		///
		/// \sa ListHeight
		// \sa ListHeight, ListScrollableWidth
		[propget, id(DISPID_DCB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_DCB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([in] OLE_XSIZE_PIXELS newValue);
		// \brief <em>Specifies the minimum number of visible items in the drop-down list box</em>
		//
		// Retrieves or sets the minimum number of visible items in the drop-down list box. The list box will
		// be made large enough to display the specified number of items, even if the height specified by the
		// \c ListHeight property is smaller.
		//
		// \remarks This property is ignored if the \c IntegralHeight property is set to \c False.\n
		//          Requires comctl32.dll version 6.0 or higher.
		//
		// \sa ListHeight
		// \sa ListHeight, IntegralHeight
		//[propget, id(DISPID_DCB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		//HRESULT MinVisibleItems([out, retval] LONG* pValue);
		//[propput, id(DISPID_DCB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		//HRESULT MinVisibleItems([in] LONG newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_DCB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_DCB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_DCB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_DCB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_DCB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_DCB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_DCB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IDriveComboBoxEvents::ContextMenu
		[propget, id(DISPID_DCB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_DCB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IDriveComboBoxEvents::OLEDragEnter
		[propget, id(DISPID_DCB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_DCB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_DCB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the control's currently selected item</em>
		///
		/// Retrieves or sets the control's currently selected item.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa SelectionFieldItem, IDriveComboBoxItem::Selected, SelectItemByText,
		///     _IDriveComboBoxEvents::SelectedDriveChanged
		[propget, id(DISPID_DCB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([out, retval] IDriveComboBoxItem** ppSelectedItem);
		[propputref, id(DISPID_DCB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([in] IDriveComboBoxItem* pNewSelectedItem);
		/// \brief <em>Specifies the height of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves or sets the height of the part of the control that displays the currently selected item.
		/// If set to -1, the default setting is used.
		///
		/// \sa ItemHeight
		[propget, id(DISPID_DCB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_DCB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the \c DriveComboBoxItem object wrapping the control's selection field</em>
		///
		/// Retrieves an \c DriveComboBoxItem object that may be used to control the properties of the
		/// control's selection field.
		///
		/// \remarks This property is read-only.
		///
		/// \sa SelectedItem
		[propget, id(DISPID_DCB_SELECTIONFIELDITEM), helpstring("Retrieves an 'DriveComboBoxItem' object that may be used to control the properties of the control's selection field."), nonbrowsable]
		HRESULT SelectionFieldItem([out, retval] IDriveComboBoxItem** ppSelectionFieldItem);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa SupportOLEDragImages, _IDriveComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_DCB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_DCB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_DCB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the text currently displayed in the combo portion</em>
		///
		/// Retrieves or sets the text currently displayed in the combo portion of the control.
		///
		/// \sa TextLength, TextHasBeenEdited, CueBanner, ForeColor, Font
		[propget, id(DISPID_DCB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), nonbrowsable]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_DCB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), nonbrowsable]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Controls how items being too wide are drawn</em>
		///
		/// Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with
		/// an ellipsis ("..."). If set to \c True, the items are truncated with an ellipsis; otherwise they
		/// are clipped.
		///
		/// \remarks If the \c Style property is set to \c sComboField, this property should be set to
		///          \c False.\n
		///          Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa Text
		[propget, id(DISPID_DCB_TEXTENDELLIPSIS), helpstring("Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with an ellipsis (\"...\"). If the 'Style' property is set to 'sComboField', this property should be set to 'False'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT TextEndEllipsis([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_TEXTENDELLIPSIS), helpstring("Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with an ellipsis (\"...\"). If the 'Style' property is set to 'sComboField', this property should be set to 'False'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT TextEndEllipsis([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the length of the text currently displayed in the combo portion</em>
		///
		/// Retrieves the length of the text specified by the \c Text property.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Text
		[propget, id(DISPID_DCB_TEXTLENGTH), helpstring("Retrieves the length of the text specified by the 'Text' property. This property is read-only."), nonbrowsable]
		HRESULT TextLength([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_DCB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_DCB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the system image list to use</em>
		///
		/// Retrieves or sets which of the system image lists is used as the control's image list. Any of the
		/// values defined by the \c UseSystemImageListConstants enumeration is valid.
		///
		/// \remarks If a system image list is used, the \c ilHighResolution image list is always set to the
		///          largest available system image list.
		///
		/// \sa hImageList, DisplayOverlayImages, UseSystemImageListConstants
		[propget, id(DISPID_DCB_USESYSTEMIMAGELIST), helpstring("Retrieves or sets which of the system image lists is used as the control's image list.")]
		HRESULT UseSystemImageList([out, retval] UseSystemImageListConstants* pValue);
		[propput, id(DISPID_DCB_USESYSTEMIMAGELIST), helpstring("Retrieves or sets which of the system image lists is used as the control's image list.")]
		HRESULT UseSystemImageList([in] UseSystemImageListConstants newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_DCB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_DCB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Closes the drop-down list box control</em>
		///
		/// Closes the drop-down list box control.
		///
		/// \sa OpenDropDownWindow, _IDriveComboBoxEvents::ListCloseUp, hWndListBox
		[id(DISPID_DCB_CLOSEDROPDOWNWINDOW), helpstring("Closes the drop-down list box control.")]
		HRESULT CloseDropDownWindow(void);
		/// \brief <em>Creates a new \c DriveComboBoxItemContainer object</em>
		///
		/// Retrieves a new \c DriveComboBoxItemContainer object and fills it with the specified items.
		///
		/// \param[in] items The item(s) to add to the collection. May be either \c Empty, an item ID, a
		///            \c DriveComboBoxItem object or a \c DriveComboBoxItems collection.
		///
		/// \return The created \c DriveComboBoxItemContainer object.
		///
		/// \sa IDriveComboBoxItemContainer::Clone, IDriveComboBoxItemContainer::Add
		[id(DISPID_DCB_CREATEITEMCONTAINER), helpstring("Retrieves a new 'DriveComboBoxItemContainer' object and fills it with 'items'.")]
		HRESULT CreateItemContainer([in, optional] VARIANT items, [out, retval] IDriveComboBoxItemContainer** ppContainer);
		/// \brief <em>Finds an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByText, FindItemByPath, SelectItemByItemData, IDriveComboBoxItem::ItemData
		[id(DISPID_DCB_FINDITEMBYITEMDATA), helpstring("Searches the combo box control for the first item that has the 'ItemData' property set to the specified value.")]
		HRESULT FindItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IDriveComboBoxItem** ppFoundItem);
		/// \brief <em>Finds a drive by its path</em>
		///
		/// Searches the combo box control for the drive that has the specified path.
		///
		/// \param[in] path The path for which to search.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByItemData, FindItemByText, SelectItemByPath, IDriveComboBoxItem::Path
		[id(DISPID_DCB_FINDITEMBYPATH), helpstring("Searches the combo box control for the drive that has the specified path.")]
		HRESULT FindItemByPath([in] BSTR Path, [out, retval] IDriveComboBoxItem** ppFoundItem);
		/// \brief <em>Finds an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByItemData, FindItemByPath, SelectItemByText, CaseSensitiveItemSearching,
		///     IDriveComboBoxItem::Text
		[id(DISPID_DCB_FINDITEMBYTEXT), helpstring("Searches the combo box control for the first item that starts with the specified text.")]
		HRESULT FindItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IDriveComboBoxItem** ppFoundItem);
		/// \brief <em>Retrieves the bounding rectangle of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// drop-down button which is displayed if the \c Style property is set to \c sComboDropDownList or
		/// \c sDropDownList.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		///
		/// \sa GetSelectionFieldRectangle, GetDroppedStateRectangle
		[id(DISPID_DCB_GETDROPDOWNBUTTONRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'.")]
		HRESULT GetDropDownButtonRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the bounding rectangle of the control including the drop-down list box</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the
		/// control when it is dropped down, i. e. including the drop-down list box.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		///
		/// \sa IsDroppedDown, GetDropDownButtonRectangle, GetSelectionFieldRectangle
		[id(DISPID_DCB_GETDROPPEDSTATERECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the control when it is dropped down, i. e. including the drop-down list box.")]
		HRESULT GetDroppedStateRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the bounding rectangle of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// part of the control that displays the currently selected item.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		///
		/// \sa GetDropDownButtonRectangle, GetDroppedStateRectangle
		[id(DISPID_DCB_GETSELECTIONFIELDRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the part of the control that displays the currently selected item.")]
		HRESULT GetSelectionFieldRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		///
		/// \return A value specifying the exact part of the control the specified point lies in. Some of the
		///         values defined by the \c HitTestConstants enumeration are valid.
		///
		/// \sa ListHitTest, HitTestConstants
		[id(DISPID_DCB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [out, retval] HitTestConstants* pHitTestDetails);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the drop-down list box control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[out] hitTestDetails Receives a value specifying the exact part of the drop-down list box
		///             control the specified point lies in. Some of the values defined by the
		///             \c HitTestConstants enumeration are valid.
		///
		/// \return The item that the specified point belongs to. \c Nothing, if no item was "hit".
		///
		/// \sa HitTest, HitTestConstants
		[id(DISPID_DCB_LISTHITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT ListHitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IDriveComboBoxItem** ppHitItem);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_DCB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedItems A collection object containing the items to drag. This parameter is
		///            used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of items
		///            contained in the \c draggedItems collection is displayed in the item count label. If
		///            set to any value larger than 1, this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa _IDriveComboBoxEvents::ItemBeginDrag, _IDriveComboBoxEvents::ItemBeginRDrag,
		///     _IDriveComboBoxEvents::OLEStartDrag, _IDriveComboBoxEvents::OLEGiveFeedback,
		///     _IDriveComboBoxEvents::OLEQueryContinueDrag, SupportOLEDragImages, OLEDragImageStyle,
		///     OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_DCB_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] IDriveComboBoxItemContainer* DraggedItems, [in, defaultvalue(-1)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Opens the drop-down list box control</em>
		///
		/// Opens the drop-down list box control.
		///
		/// \sa CloseDropDownWindow, _IDriveComboBoxEvents::ListDropDown, hWndListBox
		[id(DISPID_DCB_OPENDROPDOWNWINDOW), helpstring("Opens the drop-down list box control.")]
		HRESULT OpenDropDownWindow(void);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_DCB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Reloads the list of drives</em>
		///
		/// \sa ComboItems, DisplayedDriveTypes
		[id(DISPID_DCB_RELOADDRIVES), helpstring("Reloads the list of drives.")]
		HRESULT ReloadDrives(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_DCB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Finds and selects an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value. If a matching item is found, it is made the selected item as specified by the
		/// \c SelectedItem property.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByText, SelectItemByPath, FindItemByItemData, IDriveComboBoxItem::ItemData,
		///     SelectedItem
		[id(DISPID_DCB_SELECTITEMBYITEMDATA), helpstring("Searches the list box control for the first item that has the 'ItemData' property set to the specified value. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IDriveComboBoxItem** ppFoundItem);
		/// \brief <em>Finds and selects a drive by its path</em>
		///
		/// Searches the combo box control for the drive item that has the specified path. If a matching item
		/// is found, it is made the selected item as specified by the \c SelectedItem property.
		///
		/// \param[in] path The path for which to search.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByItemData, SelectItemByText, FindItemByPath, IDriveComboBoxItem::Path, SelectedItem
		[id(DISPID_DCB_SELECTITEMBYPATH), helpstring("Searches the list box control for the drive item that has the specified path. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByPath([in] BSTR Path, [out, retval] IDriveComboBoxItem** ppFoundItem);
		/// \brief <em>Finds and selects an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text. If a matching
		/// item is found, it is made the selected item as specified by the \c SelectedItem property.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByItemData, SelectItemByPath, FindItemByText, CaseSensitiveItemSearching,
		///     IDriveComboBoxItem::Text, SelectedItem
		[id(DISPID_DCB_SELECTITEMBYTEXT), helpstring("Searches the list box control for the first item that starts with the specified text. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IDriveComboBoxItem** ppFoundItem);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IDriveComboBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_DCB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IDriveComboBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c DriveComboBox class' events interface</em>
	///
	/// This interface defines all events the \c DriveComboBox class may raise.
	///
	/// \sa IDriveComboBox
	[
		uuid(28958164-6AB9-481d-A910-35FA62082A5B),
		helpstring("IDriveComboBox-event-interface")
	]
	dispinterface _IDriveComboBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The selected drive was changed</em>
			///
			/// Will be fired after another drive became the selected item.
			///
			/// \param[in] previousSelectedItem The previous selected item.
			/// \param[in] newSelectedItem The new selected item.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa IDriveComboBoxItem::Selected, IDriveComboBox::SelectedItem, SelectionChanged
			[id(DISPID_DCBE_SELECTEDDRIVECHANGED), helpstring("Will be fired after another drive became the selected item.")]
			void SelectedDriveChanged(IDriveComboBoxItem* previousSelectedItem, IDriveComboBoxItem* newSelectedItem);
			/// \brief <em>The user has activated the drop-down list or clicked into the control's edit box</em>
			///
			/// Will be fired after the user has activated the drop-down list or clicked into the control's edit
			/// box.
			///
			/// \sa SelectionChanging
			[id(DISPID_DCBE_BEGINSELECTIONCHANGE), helpstring("Will be fired after the user has activated the drop-down list or clicked into the control's edit box.")]
			void BeginSelectionChange(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, ListClick, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The part of the control that the menu's proposed position lies in.
			///            Some of the values defined by the \c HitTestConstants enumeration are valid.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_DCBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The contained combo box control was created</em>
			///
			/// Will be fired after the contained combo box control was created.
			///
			/// \param[in] hWndComboBox The contained combo box control's window handle.
			///
			/// \sa DestroyedComboBoxControlWindow, IDriveComboBox::hWndComboBox
			[id(DISPID_DCBE_CREATEDCOMBOBOXCONTROLWINDOW), helpstring("Will be fired after the contained combo box control was created.")]
			void CreatedComboBoxControlWindow(LONG hWndComboBox);
			/// \brief <em>The drop-down list box control was created</em>
			///
			/// Will be fired after the drop-down list box control was created.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa DestroyedListBoxControlWindow, ListDropDown, IDriveComboBox::hWndListBox
			[id(DISPID_DCBE_CREATEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was created.")]
			void CreatedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The drop-down combo box control was destroyed</em>
			///
			/// Will be fired after the drop-down combo box control was destroyed.
			///
			/// \param[in] hWndComboBox The drop-down combo box control's window handle.
			///
			/// \sa CreatedComboBoxControlWindow, IDriveComboBox::hWndComboBox
			[id(DISPID_DCBE_DESTROYEDCOMBOBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down combo box control was destroyed.")]
			void DestroyedComboBoxControlWindow(LONG hWndComboBox);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IDriveComboBox::hWnd
			[id(DISPID_DCBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The drop-down list box control was destroyed</em>
			///
			/// Will be fired after the drop-down list box control was destroyed.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa CreatedListBoxControlWindow, ListCloseUp, IDriveComboBox::hWndListBox
			[id(DISPID_DCBE_DESTROYEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was destroyed.")]
			void DestroyedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>Any data associated with an item should be freed</em>
			///
			/// Will be fired if any data associated with the specified item should be freed.
			///
			/// \param[in] comboItem The item for which to free the data. If \c Nothing, all items' data should
			///            be freed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all items freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingItem, RemovedItem, IDriveComboBoxItem::ItemData, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_FREEITEMDATA), helpstring("Will be fired if any data associated with the specified item should be freed. This event may be disabled.")]
			void FreeItemData(IDriveComboBoxItem* comboItem);
			/// \brief <em>An item was inserted</em>
			///
			/// Will be fired after a new item was inserted.
			///
			/// \param[in] comboItem The item that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingItem, RemovedItem, IDriveComboBoxItem, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_INSERTEDITEM), helpstring("Will be fired after a new item was inserted. This event may be disabled.")]
			void InsertedItem(IDriveComboBoxItem* comboItem);
			/// \brief <em>An item is about to be inserted</em>
			///
			/// Will be fired before a new item is inserted.
			///
			/// \param[in] comboItem The item that is about to be inserted.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the item
			///                isn't inserted. If set to \c False, the item is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedItem, RemovingItem, IVirtualDriveComboBoxItem::Index, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_INSERTINGITEM), helpstring("Will be fired before a new item is inserted. This event may be disabled.")]
			void InsertingItem(IVirtualDriveComboBoxItem* comboItem, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the left mouse button.
			///
			/// \param[in] comboItem The item that the user wants to drag. May be \c Nothing, indicating that
			///            the content of the selection field shall be dragged.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IDriveComboBox::OLEDrag, ItemBeginRDrag, HitTestConstants
			[id(DISPID_DCBE_ITEMBEGINDRAG), helpstring("Will be fired if the user seems to want to drag an item using the left mouse button.")]
			void ItemBeginDrag(IDriveComboBoxItem* comboItem, BSTR selectionFieldText, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the right mouse button.
			///
			/// \param[in] comboItem The item that the user wants to drag. May be \c Nothing, indicating that
			///            the content of the selection field shall be dragged.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IDriveComboBox::OLEDrag, ItemBeginDrag, HitTestConstants
			[id(DISPID_DCBE_ITEMBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag an item using the right mouse button.")]
			void ItemBeginRDrag(IDriveComboBoxItem* comboItem, BSTR selectionFieldText, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The value of an item's property is required</em>
			///
			/// Will be fired if an item property was set-up to use a callback and now this property's value is
			/// required.
			///
			/// \param[in] comboItem The item that the value is required for.
			/// \param[in] requestedInfo Specifies which properties' values are required. Any combination of
			///            the values defined by the \c RequestedInfoConstants enumeration is valid.
			/// \param[out] iconIndex Set this parameter to the zero-based index of the icon to use. The
			///             icon is taken from the control's \c ilItems image list. If the \c requestedInfo
			///             parameter doesn't include \c riIconIndex, this value is ignored.
			/// \param[out] selectedIconIndex Set this parameter to the zero-based index of the icon to use.
			///             The icon is taken from the control's \c ilItems image list. If the \c requestedInfo
			///             parameter doesn't include \c riSelectedIconIndex, this value is ignored.
			/// \param[out] overlayIndex Set this parameter to the zero-based index of the overlay icon to use
			///             for the specified item. The overlay icon is taken from the control's \c ilItems
			///             image list. If the \c requestedInfo parameter doesn't include \c riOverlayIndex, this
			///             value is ignored.
			/// \param[out] indent Set this parameter to the item's indentation in steps of 10 pixels. If the
			///             \c requestedInfo parameter doesn't include \c riIndent, this value is ignored.
			/// \param[in] maxItemTextLength The maximum number of characters the item's text may consist of. If
			///            the \c requestedInfo parameter doesn't include \c riItemText, this value is ignored.
			/// \param[out] itemText Set this parameter to the text to use for the specified item. If the
			///             \c requestedInfo parameter doesn't include \c riItemText, this value is ignored.
			/// \param[in,out] dontAskAgain If set to \c True, this event won't be fired again for the
			///                specified item. Instead the specified values will be persisted.
			///
			/// \sa IDriveComboBoxItem::IconIndex, IDriveComboBoxItem::SelectedIconIndex,
			///     IDriveComboBox::hImageList, IDriveComboBoxItem::Indent, IDriveComboBoxItem::Text,
			///     IDriveComboBoxItem::OverlayIndex, RequestedInfoConstants, ImageListConstants
			[id(DISPID_DCBE_ITEMGETDISPLAYINFO), helpstring("Will be fired if an item property was set-up to use a callback and now this property's value is required.")]
			void ItemGetDisplayInfo(IDriveComboBoxItem* comboItem, RequestedInfoConstants requestedInfo, LONG* IconIndex, LONG* SelectedIconIndex, LONG* OverlayIndex, LONG* Indent, LONG maxItemTextLength, BSTR* itemText, VARIANT_BOOL* dontAskAgain);
			/// \brief <em>The mouse cursor was moved into an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseLeave, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_ITEMMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseEnter(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseEnter, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_ITEMMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseLeave(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the drop-down list box control's client area</em>
			///
			/// Will be fired if the user clicks into the drop-down list box control's client area using
			/// the left mouse button.
			///
			/// \param[in] pComboItem The clicked item. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always be
			///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
			///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the drop-down list
			///            box control's upper-left corner.
			/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the drop-down list
			///            box control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the drop-down list box control that was clicked. Any
			///            of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_LISTCLICK), helpstring("Will be fired if the user clicks into the drop-down list box control's client area using the left mouse button. This event may be disabled.")]
			void ListClick(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control's drop-down list box window was closed</em>
			///
			/// Will be fired after the drop-down list box window has been closed.
			///
			/// \sa ListDropDown, IDriveComboBox::CloseDropDownWindow, IDriveComboBox::hWndListBox
			[id(DISPID_DCBE_LISTCLOSEUP), helpstring("Will be fired after the drop-down list box window has been closed.")]
			void ListCloseUp();
			/// \brief <em>The control's drop-down list box window was opened</em>
			///
			/// Will be fired after the drop-down list box window has been opened (before it is made
			/// visible).
			///
			/// \sa ListCloseUp, IDriveComboBox::OpenDropDownWindow, IDriveComboBox::hWndListBox
			[id(DISPID_DCBE_LISTDROPDOWN), helpstring("Will be fired after the drop-down list box window has been opened (before it is made visible).")]
			void ListDropDown();
			/// \brief <em>A mouse button was pressed over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseUp, ListClick, MouseDown, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_LISTMOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseDown(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, ListMouseUp, ListMouseWheel, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_LISTMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseMove(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, ListClick, MouseUp, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_LISTMOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseUp(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseMove, MouseWheel, HitTestConstants, ExtendedMouseButtonConstants,
			///     ScrollAxisConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_LISTMOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseWheel(IDriveComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the drop-down list box control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragLeave, ListMouseUp, OLEDragDrop,
			///     IDriveComboBox::RegisterForOLEDragDrop, IDriveComboBox::FinishOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_DCBE_LISTOLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the drop-down list box control's client area.")]
			void ListOLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragMouseMove, ListOLEDragLeave, ListOLEDragDrop, OLEDragEnter,
			///     IDriveComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IDriveComboBox::ListDragScrollTimeBase, HitTestConstants
			[id(DISPID_DCBE_LISTOLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list box control's client area.")]
			void ListOLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the drop-down list
			/// box control's client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoCloseUp If set to \c True, the drop-down list box control will be closed
			///                automatically; otherwise not.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragDrop, OLEDragLeave,
			///     IDriveComboBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_DCBE_LISTOLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list box control's client area or if the user canceled the drag'n'drop operation.")]
			void ListOLEDragLeave(IOLEDataObject* data, IDriveComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, VARIANT_BOOL* autoCloseUp);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragEnter, ListOLEDragLeave, ListOLEDragDrop, ListMouseMove, OLEDragMouseMove,
			///     IDriveComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IDriveComboBox::ListDragScrollTimeBase, HitTestConstants
			[id(DISPID_DCBE_LISTOLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void ListOLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IListBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IDriveComboBox::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, HitTestConstants,
			///     ExtendedMouseButtonConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ListMouseWheel, ExtendedMouseButtonConstants, ScrollAxisConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa IDriveComboBox::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_DCBE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ListOLEDragDrop,
			///     IDriveComboBox::RegisterForOLEDragDrop, IDriveComboBox::FinishOLEDragDrop,
			///      OLEDropEffectConstants,HitTestConstants
			[id(DISPID_DCBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ListOLEDragEnter,
			///     IDriveComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants,
			///     IDriveComboBox::DragDropDownTime
			[id(DISPID_DCBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, IDriveComboBox::OLEDrag
			[id(DISPID_DCBE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ListOLEDragLeave,
			///     IDriveComboBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_DCBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IDriveComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, IDriveComboBox::OLEDrag
			[id(DISPID_DCBE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ListOLEDragMouseMove,
			///     IDriveComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants
			///     IDriveComboBox::DragDropDownTime
			[id(DISPID_DCBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IDriveComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa IDriveComboBox::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_DCBE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa IDriveComboBox::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_DCBE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_DCBE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_DCBE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa IDriveComboBox::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_DCBE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the control cannot allocate enough memory to meet a specific request.
			[id(DISPID_DCBE_OUTOFMEMORY), helpstring("Will be fired if the control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IDriveComboBox::hWnd
			[id(DISPID_DCBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>An item was removed</em>
			///
			/// Will be fired after an item was removed.
			///
			/// \param[in] comboItem The item that was removed. If \c Nothing, all items were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingItem, InsertedItem, IVirtualDriveComboBoxItem, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_REMOVEDITEM), helpstring("Will be fired after an item was removed. If 'comboItem' is 'Nothing', all items were removed. This event may be disabled.")]
			void RemovedItem(IVirtualDriveComboBoxItem* comboItem);
			/// \brief <em>An item is about to be removed</em>
			///
			/// Will be fired before an item is removed.
			///
			/// \param[in] comboItem The item that is about to be removed. If \c Nothing, all items are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the item isn't
			///                removed. If set to \c False, the item is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedItem, InsertingItem, IDriveComboBoxItem, IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_REMOVINGITEM), helpstring("Will be fired before an item is removed. If 'comboItem' is 'Nothing', all items are removed. This event may be disabled.")]
			void RemovingItem(IDriveComboBoxItem* comboItem, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_DCBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user canceled changing the selected item</em>
			///
			/// Will be fired after the user canceled changing the selected item.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IDriveComboBoxItem::Selected, IDriveComboBox::SelectedItem, SelectionChanging,
			///     SelectionChanged
			[id(DISPID_DCBE_SELECTIONCANCELED), helpstring("Will be fired after the user canceled changing the selected item. This event may be disabled.")]
			void SelectionCanceled(void);
			/// \brief <em>The selected item was changed</em>
			///
			/// Will be fired after another item became the selected item.
			///
			/// \param[in] previousSelectedItem The previous selected item.
			/// \param[in] newSelectedItem The new selected item.
			///
			/// \sa SelectedDriveChanged, IDriveComboBoxItem::Selected, IDriveComboBox::SelectedItem,
			///     SelectionCanceled, SelectionChanging
			[id(DISPID_DCBE_SELECTIONCHANGED), helpstring("Will be fired after another item became the selected item.")]
			void SelectionChanged(IDriveComboBoxItem* previousSelectedItem, IDriveComboBoxItem* newSelectedItem);
			/// \brief <em>The user has concluded an action that changes the currently selected item</em>
			///
			/// Will be fired after the user has concluded an operation within the control's edit box or has
			/// selected an item from the control's drop-down list, but before the selected item is changed.
			///
			/// \param[in] newSelectedItem The item that will become the selected item. May be \c Nothing.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] selectionFieldHasBeenEdited Specifies whether the text displayed in the control's
			///            edit box has been edited. If \c True, the text has been edited; otherwise not.
			/// \param[in] selectionChangeReason Specifies the action that led to this event being raised. Any
			///            of the values defined by the \c SelectionChangeReasonConstants enumeration is valid.
			/// \param[in,out] cancelChange If set to \c True, the selection change is aborted, i. e. the
			///                currently selected item remains selected. If set to \c False, the selection is
			///                changed to the item specified by \c newSelectedItem.
			///
			/// \sa BeginSelectionChange, SelectionChanged, SelectionCanceled, SelectionChangeReasonConstants
			[id(DISPID_DCBE_SELECTIONCHANGING), helpstring("Will be fired after the user has concluded an operation within the control's edit box or has selected an item from the control's drop-down list, but before the selected item is changed.")]
			void SelectionChanging(IDriveComboBoxItem* newSelectedItem, BSTR selectionFieldText, VARIANT_BOOL selectionFieldHasBeenEdited, SelectionChangeReasonConstants selectionChangeReason, VARIANT_BOOL* cancelChange);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IDriveComboBox::DisabledEvents
			[id(DISPID_DCBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c DriveComboBox class</em>
	///
	/// The control's main COM class. It implements the \c IDriveComboBox and
	/// \c _IDriveComboBoxEvents interfaces.
	///
	/// \sa IDriveComboBox, _IDriveComboBoxEvents
	[
		uuid(46673A64-8D6D-4802-A773-39FE08D1511C),
		version(1.5),
		helpstring("DriveComboBox Control 1.5 (Unicode)")
	]
	coclass DriveComboBox
	{
		[default] interface IDriveComboBox;
		[default, source] dispinterface _IDriveComboBoxEvents;
	};


	/// \interface IVirtualImageComboBoxItem
	/// \brief <em>Wraps a not existing item</em>
	///
	/// This interface is a wrapper around an image combo box item that does not yet or not anymore exist
	/// within the control.
	///
	/// \sa _IVirtualImageComboBoxItemEvents, IImageComboBoxItem, _IImageComboBoxEvents
	[
		object,
		uuid(93DB4292-71EE-4da4-BADF-792454D61A66),
		dual,
		nonextensible,
		helpstring("IVirtualImageComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IVirtualImageComboBoxItem : IDispatch
	{
		/// \brief <em>Retrieves the item's icon</em>
		///
		/// Retrieves the zero-based index of the item's icon in the control's \c ilItems image list. If set to
		/// -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. If set to -2, no icon will be or was displayed for this item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo,
		///     SelectedIconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_VICBI_ICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's indentation</em>
		///
		/// Retrieves the item's indentation in steps of 10 pixels. If set to 1, the item's indentation will be
		/// 10 pixels; if set to 2, it will be 20 pixels and so on. If set to -1, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IImageComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_VICBI_INDENT), helpstring("Retrieves the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves the zero-based index that will identify or has identified the item.
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_VICBI_INDEX), helpstring("Retrieves the item's zero-based index."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IImageComboBoxEvents::FreeItemData
		[propget, id(DISPID_VICBI_ITEMDATA), helpstring("Retrieves the Long value associated with the item."), nonbrowsable]
		HRESULT ItemData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's icon</em>
		///
		/// Retrieves the one-based index of the item's overlay icon in the control's \c ilItems image list. If
		/// set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. An index of 0 means that no overlay will be or was drawn for this item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     SelectedIconIndex, ImageListConstants
		[propget, id(DISPID_VICBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the icon that is displayed next to the item if the item is selected</em>
		///
		/// Retrieves the zero-based index of the item's selected icon in the control's \c ilItems image list.
		/// The selected icon is used instead of the normal icon identified by the \c IconIndex property if the
		/// item is the selected item. If set to -1, the control will fire the \c ItemGetDisplayInfo event each
		/// time this property's value is required.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo,
		///     IconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_VICBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's text</em>
		///
		/// Retrieves the item's text. If set to \c vbNullString, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \remarks This is the default property of the \c IVirtualImageComboBoxItem interface.\n
		///          This property is read-only.
		///
		/// \sa _IImageComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_VICBI_TEXT), helpstring("Retrieves the item's text. If set to 'vbNullString', the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT Text([out, retval] BSTR* pValue);
	}


	/// \interface _IVirtualImageComboBoxItemEvents
	/// \brief <em>The \c VirtualImageComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c VirtualImageComboBoxItem class may raise.
	///
	/// \sa IVirtualImageComboBoxItem
	[
		uuid(A2DC9988-7D8C-465e-9FD5-CFB07E163C41),
		helpstring("IVirtualImageComboBoxItem-event-interface")
	]
	dispinterface _IVirtualImageComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualImageComboBoxItem class</em>
	///
	/// This COM class implements the \c IVirtualImageComboBoxItem and \c _IVirtualImageComboBoxItemEvents
	/// interfaces.
	///
	/// \sa IVirtualImageComboBoxItem, _IVirtualImageComboBoxItemEvents, ImageComboBox, ImageComboBoxItem
	[
		uuid(78EC3B3B-8C24-4acf-8B18-D8DAC164FDEA),
		version(1.0),
		noncreatable,
		helpstring("VirtualImageComboBoxItem Class 1.0 (Unicode)")
	]
	coclass VirtualImageComboBoxItem
	{
		[default] interface IVirtualImageComboBoxItem;
		[default, source] dispinterface _IVirtualImageComboBoxItemEvents;
	};


	/// \interface IImageComboBoxItem
	/// \brief <em>Wraps an existing image combo box item</em>
	///
	/// This interface is a wrapper around an item that - unlike an item wrapped by
	/// \c IVirtualImageComboBoxItem - really exists within the control.
	///
	/// \sa _IImageComboBoxItemEvents, IVirtualImageComboBoxItem, IImageComboBoxItems,
	///     IImageComboBoxItemContainer, IImageComboBox, _IImageComboBoxEvents
	[
		object,
		uuid(93CD9AAA-6B19-4798-B308-12A89F047466),
		dual,
		nonextensible,
		helpstring("IImageComboBoxItem interface"),
		pointer_default(unique)
	]
	interface IImageComboBoxItem : IDispatch
	{
		/// \brief <em>Specifies the item's height</em>
		///
		/// Retrieves or sets the item's height in pixels.
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetRectangle, IImageComboBox::ItemHeight
		[propget, id(DISPID_ICBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ComboBox.ItemHeight' property instead.")]
		HRESULT Height([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Specifies the item's icon</em>
		///
		/// Retrieves or sets the zero-based index of the item's icon in the control's \c ilItems image list.
		/// If set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value
		/// is required.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo,
		///     SelectedIconIndex, OverlayIndex, ImageListConstants
		[propget, id(DISPID_ICBI_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the item's icon in the control's 'ilItems' image list. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_ICBI_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the item's icon in the control's 'ilItems' image list. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required."), nonbrowsable]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Retrieves the item's ID</em>
		///
		/// Retrieves an unique ID identifying this item.
		///
		/// \remarks An item's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, ItemIdentifierTypeConstants
		[propget, id(DISPID_ICBI_ID), helpstring("Retrieves the item's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's indentation</em>
		///
		/// Retrieves or sets the item's indentation in steps of 10 pixels. If set to 1, the item's indentation
		/// will be 10 pixels; if set to 2, it will be 20 pixels and so on. If set to -1, the control will fire
		/// the \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \sa _IImageComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_ICBI_INDENT), helpstring("Retrieves or sets the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_ICBI_INDENT), helpstring("Retrieves or sets the item's indentation in steps of 10 pixels. If set to -1, the control will fire the 'ItemGetDisplayInfo' event each time this property's value is required.")]
		HRESULT Indent([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves a zero-based index identifying this item.
		///
		/// \remarks Although adding or removing items changes other items' indexes, the index is the best
		///          (and fastest) option to identify an item.\n
		///          This property is read-only.
		///
		/// \sa ID, ItemIdentifierTypeConstants
		[propget, id(DISPID_ICBI_INDEX), helpstring("Retrieves the item's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the item. Use this property to associate
		/// any data with the item.
		///
		/// \sa _IImageComboBoxEvents::FreeItemData
		[propget, id(DISPID_ICBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([out, retval] LONG* pValue);
		[propput, id(DISPID_ICBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([in] LONG newValue);
		/// \brief <em>Specifies the item's overlay icon</em>
		///
		/// Retrieves the one-based index of the item's overlay icon in the control's \c ilItems image list. If
		/// set to -1, the control will fire the \c ItemGetDisplayInfo event each time this property's value is
		/// required. An index of 0 means that no overlay is drawn for this item.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     SelectedIconIndex, ImageListConstants
		[propget, id(DISPID_ICBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's 'ilItems' image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_ICBI_OVERLAYINDEX), helpstring("Retrieves the one-based index of the overlay icon in the control's 'ilItems' image list. If set to 0, no overlay is drawn for this item."), nonbrowsable]
		HRESULT OverlayIndex([in] LONG newValue);
		/// \brief <em>Specifies whether the item is selected</em>
		///
		/// Retrieves whether the item is the currently selected item. If this property is set to \c True, the
		/// item is selected; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IImageComboBox::SelectedItem
		[propget, id(DISPID_ICBI_SELECTED), helpstring("Retrieves whether the item is the currently selected item.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the icon that is displayed next to the item if the item is selected</em>
		///
		/// Retrieves or sets the zero-based index of the item's selected icon in the control's \c ilItems
		/// image list. The selected icon is used instead of the normal icon identified by the \c IconIndex
		/// property if the item is the selected item. If set to -1, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \sa IImageComboBox::hImageList, _IImageComboBoxEvents::ItemGetDisplayInfo, IconIndex,
		///     OverlayIndex, ImageListConstants
		[propget, id(DISPID_ICBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_ICBI_SELECTEDICONINDEX), helpstring("Retrieves the zero-based index of the item's icon in the control's image list that is used if the item is the control's selected item."), nonbrowsable]
		HRESULT SelectedIconIndex([in] LONG newValue);
		/// \brief <em>Specifies the item's text</em>
		///
		/// Retrieves or sets the item's text. If set to \c vbNullString, the control will fire the
		/// \c ItemGetDisplayInfo event each time this property's value is required.
		///
		/// \remarks This is the default property of the \c IImageComboBoxItem interface.
		///
		/// \sa _IImageComboBoxEvents::ItemGetDisplayInfo
		[propget, id(DISPID_ICBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_ICBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([in] BSTR newValue);

		/// \brief <em>Retrieves an image list containing the item's drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of this item.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return The handle to the image list containing the drag image.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_ICBI_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of this item.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Retrieves the bounding rectangle of either the item or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client
		/// area) of either the item or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c ItemRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the drop-down list box control's upper-left corner.
		///
		/// \sa Height, ItemRectangleTypeConstants
		[id(DISPID_ICBI_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the drop-down list box control's client area) of either the item or a part of it.")]
		HRESULT GetRectangle(ItemRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
	}


	/// \interface _IImageComboBoxItemEvents
	/// \brief <em>The \c ImageComboBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c ImageComboBoxItem class may raise.
	///
	/// \sa IImageComboBoxItem
	[
		uuid(AEC220C8-00C8-43d5-91C0-1184C255E9FA),
		helpstring("IImageComboBoxItem-event-interface")
	]
	dispinterface _IImageComboBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ImageComboBoxItem class</em>
	///
	/// This COM class implements the \c IImageComboBoxItem and \c _IImageComboBoxItemEvents interfaces.
	///
	/// \sa IImageComboBoxItem, _IImageComboBoxItemEvents, ImageComboBox, ImageComboBoxItems
	[
		uuid(CE3CC95C-18B1-42de-899E-298F73200306),
		version(1.5),
		noncreatable,
		helpstring("ImageComboBoxItem Class 1.5 (Unicode)")
	]
	coclass ImageComboBoxItem
	{
		[default] interface IImageComboBoxItem;
		[default, source] dispinterface _IImageComboBoxItemEvents;
	};


	/// \interface IImageComboBoxItems
	/// \brief <em>Manages a collection of \c ImageComboBoxItem objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c ImageComboBoxItem
	/// objects. While a \c ImageComboBoxItemContainer object is used to group any items and acts more like
	/// a clipboard, a \c ImageComboBoxItems object is used to group items that have certain properties in
	/// common.
	///
	/// \sa _IImageComboBoxItemsEvents, IImageComboBoxItem, IImageComboBoxItemContainer, IImageComboBox
	[
		object,
		uuid(22BB3CB9-CB96-4bf8-8D42-F6B3C3DBC51A),
		dual,
		nonextensible,
		helpstring("IImageComboBoxItems interface"),
		pointer_default(unique)
	]
	interface IImageComboBoxItems : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on an item,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_ICBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets an item filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal itemProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_ICBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_ICBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets an item filter.\n
		/// An \c IComboBoxItems collection can be filtered by any of \c IComboBoxItem's properties, that
		/// the \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple
		/// filters are possible, too. A filter is a \c Variant containing an array whose elements are of
		/// type \c Variant. Each element of this array contains a valid value for the property, that the
		/// filter refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_ICBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_ICBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets an item filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_ICBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_ICBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c ImageComboBoxItem object from the collection</em>
		///
		/// Retrieves a \c ImageComboBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be retrieved.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IImageComboBoxItems interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_ICBIS_ITEM), helpstring("Retrieves a 'ImageComboBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IImageComboBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ImageComboBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_ICBIS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds an item to the combo box</em>
		///
		/// Adds an item with the specified properties at the specified position in the control and returns
		/// a \c ImageComboBoxItem object wrapping the inserted item.
		///
		/// \param[in] itemText The new item's caption text. If set to \c vbNullString, the control will fire
		///            the \c ItemGetDisplayInfo event each time this property's value is required.
		/// \param[in] insertAt The new item's zero-based index. If set to -1, the item will be inserted
		///            as the last item.
		/// \param[in] iconIndex The zero-based index of the item's icon in the control's \c ilItems image
		///            list. If set to -1, the control will fire the \c ItemGetDisplayInfo event each time this
		///            property's value is required. A value of -2 means 'not specified' and is valid if
		///            there's no image list associated with the control.
		/// \param[in] selectedIconIndex The zero-based index of the item's selected icon in the control's
		///            \c ilItems image list. This icon will be used instead of the normal icon identified by
		///            \c iconIndex if the item is the selected item. If set to -1, the control will fire the
		///            \c ItemGetDisplayInfo event each time this property's value is required. If set to -2,
		///            the normal icon specified by \c iconIndex will be used.
		/// \param[in] overlayIndex The one-based index of the item's overlay icon in the control's \c ilItems
		///            image list. If set to -1, the control will fire the \c ItemGetDisplayInfo event each
		///            time this property's value is required. If set to 0, no overlay is drawn for this item.
		/// \param[in] itemIndentation The new item's indentation in steps of 10 pixels. If set to 1, the
		///            item's indentation will be 10 pixels; if set to 2, it will be 20 pixels and so on.
		///            If set to -1, the control will fire the \c ItemGetDisplayInfo event each time this
		///            property's value is required.
		/// \param[in] itemData A \c Long value that will be associated with the item.
		///
		/// \return The inserted item.
		///
		/// \sa Count, Remove, RemoveAll, IImageComboBoxItem::Text, IImageComboBoxItem::IconIndex,
		///     IImageComboBoxItem::SelectedIconIndex, IImageComboBoxItem::OverlayIndex,
		///     IImageComboBoxItem::ItemData, IImageComboBox::hImageList,
		///     _IImageComboBoxEvents::ItemGetDisplayInfo
		[id(DISPID_ICBIS_ADD), helpstring("Adds a new item with the specified properties.")]
		HRESULT Add([in] BSTR itemText, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(-2)] LONG IconIndex, [in, defaultvalue(-2)] LONG SelectedIconIndex, [in, defaultvalue(0)] LONG OverlayIndex, [in, defaultvalue(0)] LONG itemIndentation, [in, defaultvalue(0)] LONG ItemData, [out, retval] IImageComboBoxItem** ppAddedItem);
		/// \brief <em>Retrieves whether the specified item is part of the item collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the item to be checked.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified item is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, ItemIdentifierTypeConstants
		[id(DISPID_ICBIS_CONTAINS), helpstring("Retrieves whether the specified item is part of the item collection.")]
		HRESULT Contains([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c ImageComboBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_ICBIS_COUNT), helpstring("Retrieves the number of 'ImageComboBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified item in the collection from the combo box</em>
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to be removed.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, ItemIdentifierTypeConstants
		[id(DISPID_ICBIS_REMOVE), helpstring("Removes the specified item in the collection from the control.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType);
		/// \brief <em>Removes all items in the collection from the combo box</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_ICBIS_REMOVEALL), helpstring("Removes all items in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IImageComboBoxItemsEvents
	/// \brief <em>The \c ImageComboBoxItems class' events interface</em>
	///
	/// This interface defines all events the \c ImageComboBoxItems class may raise.
	///
	/// \sa IImageComboBoxItems
	[
		uuid(7DB3A6C1-62FF-4736-A23E-06C52D95F5B2),
		helpstring("IImageComboBoxItems-event-interface")
	]
	dispinterface _IImageComboBoxItemsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ImageComboBoxItems class</em>
	///
	/// This COM class implements the \c IImageComboBoxItems and \c _IImageComboBoxItemsEvents interfaces.
	///
	/// \sa IImageComboBoxItems, _IImageComboBoxItemsEvents, ImageComboBox, ImageComboBoxItem
	[
		uuid(D6CC6734-8ED2-4362-B735-9F5AA4BD8B3C),
		version(1.5),
		noncreatable,
		helpstring("ImageComboBoxItems Class 1.5 (Unicode)")
	]
	coclass ImageComboBoxItems
	{
		[default] interface IImageComboBoxItems;
		[default, source] dispinterface _IImageComboBoxItemsEvents;
	};


	/// \interface IImageComboBoxItemContainer
	/// \brief <em>Manages a collection of \c ImageComboBoxItem objects</em>
	///
	/// This interface provides easy access to collections of \c ImageComboBoxItem objects. While a
	/// \c ImageComboBoxItems object is used to group items that have certain properties in common, a
	/// \c ImageComboBoxItemContainer object is used to group any items and acts more like a clipboard.
	///
	/// \sa _IImageComboBoxItemContainerEvents, IImageComboBoxItem, IImageComboBoxItems, IImageComboBox
	[
		object,
		uuid(7B4EDE6F-639B-4b0b-9146-F6B3D2D53804),
		dual,
		nonextensible,
		helpstring("IImageComboBoxItemContainer interface"),
		pointer_default(unique)
	]
	interface IImageComboBoxItemContainer : IDispatch
	{
		/// \brief <em>Retrieves a \c ImageComboBoxItem object from the collection</em>
		///
		/// Retrieves a \c ImageComboBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the combo box item to retrieve.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID.
		///
		/// \remarks This is the default property of the \c IImageComboBoxItemContainer interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, IImageComboBoxItem::ID, Add, Remove
		[propget, id(DISPID_ICBIC_ITEM), helpstring("Retrieves a 'ImageComboBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IImageComboBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ImageComboBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_ICBIC__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds the specified item(s) to the collection</em>
		///
		/// \param[in] items The item(s) to add. May be either an item ID, a \c ImageComboBoxItem object or a
		///            \c ImageComboBoxItems collection.
		///
		/// \sa IImageComboBoxItem::ID, Count, Remove, RemoveAll
		[id(DISPID_ICBIC_ADD), helpstring("Adds the specified item(s) to the collection.")]
		HRESULT Add([in] VARIANT Items);
		/// \brief <em>Clones the collection object</em>
		///
		/// Retrieves an exact copy of the collection.
		///
		/// \return The cloned object.
		///
		/// \sa IImageComboBox::CreateItemContainer
		[id(DISPID_ICBIC_CLONE), helpstring("Creates an exact copy of the collection.")]
		HRESULT Clone([out, retval] IImageComboBoxItemContainer** ppClone);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c ImageComboBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_ICBIC_COUNT), helpstring("Retrieves the number of 'ImageComboBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Retrieves an image list containing the items' common drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of the items of this collection.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return: The handle to the image list containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_ICBIC_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of the items of this collection.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Removes the specified item from the collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to remove.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID.
		/// \param[in] removePhysically If \c True, the item is removed from the control, too.
		///
		/// \sa IImageComboBoxItem::ID, Add, Count, RemoveAll, ItemIdentifierTypeConstants
		[id(DISPID_ICBIC_REMOVE), helpstring("Removes the specified item from the collection.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [in, defaultvalue(0)] VARIANT_BOOL removePhysically);
		/// \brief <em>Removes all items from the collection</em>
		///
		/// \param[in] removePhysically If \c True, the items are removed from the control, too.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_ICBIC_REMOVEALL), helpstring("Removes all items from the collection.")]
		HRESULT RemoveAll([in, defaultvalue(0)] VARIANT_BOOL removePhysically);
	}


	/// \interface _IImageComboBoxItemContainerEvents
	/// \brief <em>The \c ImageComboBoxItemContainer class' events interface</em>
	///
	/// This interface defines all events the \c ImageComboBoxItemContainer class may raise.
	///
	/// \sa IImageComboBoxItemContainer
	[
		uuid(B8ABEF60-81C3-4ccc-B108-553A63CF9C3E),
		helpstring("IImageComboBoxItemContainer-event-interface")
	]
	dispinterface _IImageComboBoxItemContainerEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ImageComboBoxItemContainer class</em>
	///
	/// This COM class implements the \c IImageComboBoxItemContainer and
	/// \c _IImageComboBoxItemContainerEvents interfaces.
	///
	/// \sa IImageComboBoxItemContainer, _IImageComboBoxItemContainerEvents, ImageComboBox, ImageComboBoxItem
	[
		uuid(E43D3875-FD2C-46c4-80BD-FE5832A22EEF),
		version(1.5),
		noncreatable,
		helpstring("ImageComboBoxItemContainer Class 1.5 (Unicode)")
	]
	coclass ImageComboBoxItemContainer
	{
		[default] interface IImageComboBoxItemContainer;
		[default, source] dispinterface _IImageComboBoxItemContainerEvents;
	};


	/// \interface IImageComboBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the image combo box control's main interface. It wraps the control window.
	///
	/// \sa _IImageComboBoxEvents
	[
		object,
		uuid(A9BD0EC7-C226-42f0-9A7D-731F08800375),
		dual,
		nonextensible,
		helpstring("IImageComboBox interface"),
		pointer_default(unique)
	]
	interface IImageComboBox : IDispatch
	{
		/// \brief <em>Specifies whether the contained edit control accepts numbers only</em>
		///
		/// Retrieves or sets whether the contained edit control accepts all kind of text or only numbers. If
		/// set to \c True, only numbers, otherwise all text is accepted.
		///
		/// \sa Text
		[propget, id(DISPID_ICB_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_ACCEPTNUMBERSONLY), helpstring("Retrieves or sets whether the contained edit control accepts all kind of text or only numbers.")]
		HRESULT AcceptNumbersOnly([in] VARIANT_BOOL newValue);
		// \brief <em>Controls the style of the control's outer border</em>
		//
		// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		// by the \c AppearanceConstants enumeration is valid.
		//
		// \sa BorderStyle, AppearanceConstants
		//[propget, id(DISPID_ICB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		//HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		//[propput, id(DISPID_ICB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		//HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's automatic scrolling features</em>
		///
		/// Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret
		/// reaches the borders of the control's client area. If set to \c True, the control scrolls
		/// automatically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Style
		[propget, id(DISPID_ICB_AUTOHORIZONTALSCROLLING), helpstring("Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoHorizontalScrolling([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_AUTOHORIZONTALSCROLLING), helpstring("Retrieves or sets whether the control scrolls automatically in horizontal direction, if the caret reaches the borders of the control's client area. Changing this property destroys and recreates the control window.")]
		HRESULT AutoHorizontalScrolling([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \remarks Starting with comctl32.dll version 6.10, this property is ignored if the \c Style property
		///          is set to \c sDropDownList.
		///
		/// \sa ForeColor, Style
		// \sa ForeColor, ListBackColor, Style
		[propget, id(DISPID_ICB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored if the 'Style' property is set to 'sDropDownList'.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_ICB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. Starting with comctl32.dll version 6.10, this property is ignored if the 'Style' property is set to 'sDropDownList'.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		// \brief <em>Controls the style of the control's inner border</em>
		//
		// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		// defined by the \c BorderStyleConstants enumeration is valid.
		//
		// \sa Appearance, BorderStyleConstants
		//[propget, id(DISPID_ICB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		//HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		//[propput, id(DISPID_ICB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		//HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether string comparisons are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are executed when searching for an item by its
		/// text, are case sensitive. If set to \c True, the comparisons are case sensitive; otherwise not.
		///
		/// \sa FindItemByText, SelectItemByText
		[propget, id(DISPID_ICB_CASESENSITIVEITEMSEARCHING), helpstring("Retrieves or sets whether string comparisons, that are executed when searching for an item by its text, are case sensitive.")]
		HRESULT CaseSensitiveItemSearching([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_CASESENSITIVEITEMSEARCHING), helpstring("Retrieves or sets whether string comparisons, that are executed when searching for an item by its text, are case sensitive.")]
		HRESULT CaseSensitiveItemSearching([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the control's items</em>
		///
		/// Retrieves a collection object wrapping the combo box items.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IImageComboBoxItems
		[propget, id(DISPID_ICB_COMBOITEMS), helpstring("Retrieves a collection object wrapping the control's items."), nonbrowsable]
		HRESULT ComboItems([out, retval] IImageComboBoxItems** ppItems);
		/// \brief <em>Specifies the control's textual cue</em>
		///
		/// Retrieves or sets the control's textual cue.
		///
		/// \remarks Due to an bug in Windows XP and Windows Server 2003, cue banners won't work on those
		///          systems if East Asian language and complex script support is installed.\n
		///          Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa Text
		[propget, id(DISPID_ICB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([out, retval] BSTR* pValue);
		[propput, id(DISPID_ICB_CUEBANNER), helpstring("Retrieves or sets the control's textual cue. Requires comctl32.dll version 6.0 or higher."), bindable, displaybind, requestedit]
		HRESULT CueBanner([in] BSTR newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_ICB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_ICB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_ICB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control tries to work-around character set problems related to filenames</em>
		///
		/// Retrieves or sets whether the control's text is converted from the Windows character set to the OEM
		/// character set and then back to the Windows character set. Such a conversion ensures proper
		/// character conversion when the application calls the \c CharToOem function to convert a Windows
		/// string in the control to OEM characters. This property is most useful if the control contains file
		/// names that will be used on file systems that do not support Unicode.\n
		/// If set to \c True, the conversion is performed; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Text,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647473.aspx">CharToOem</a>
		[propget, id(DISPID_ICB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_DOOEMCONVERSION), helpstring("Retrieves or sets whether the control's text is converted from the Windows character set to the OEM character set and then back to the Windows character set. Changing this property destroys and recreates the control window.")]
		HRESULT DoOEMConversion([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic opening of the drop-down list box control during drag'n'drop</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down
		/// button during a drag'n'drop operation before the drop-down list box control will be opened
		/// automatically. If set to 0, automatic drop-down is disabled. If set to -1, the system's
		/// double-click time, multiplied with 4, is used.
		///
		/// \sa RegisterForOLEDragDrop, ListDragScrollTimeBase, _IImageComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_ICB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([out, retval] LONG* pValue);
		[propput, id(DISPID_ICB_DRAGDROPDOWNTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over the drop-down button during a drag'n'drop operation before the drop-down list box control will be opened automatically.")]
		HRESULT DragDropDownTime([in] LONG newValue);
		/// \brief <em>Retrieves the accessibility object state of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the accessibility object state of the drop-down button which is displayed if the \c Style
		/// property is set to \c sComboDropDownList or \c sDropDownList. For a list of possible object states
		/// see the <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">MSDN article</a>.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Style, IsDroppedDown,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">Accessibility Object State Constants</a>
		[propget, id(DISPID_ICB_DROPDOWNBUTTONOBJECTSTATE), helpstring("Retrieves the accessibility object state of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'."), nonbrowsable]
		HRESULT DropDownButtonObjectState([out, retval] LONG* pValue);
		/// \brief <em>Specifies which key opens the drop-down window</em>
		///
		/// Retrieves or sets the key that opens the drop-down window when pressed. Any of the values defined
		/// by the \c DropDownKeyConstants enumeration is valid.
		///
		/// \sa DropDownKeyConstants
		[propget, id(DISPID_ICB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([out, retval] DropDownKeyConstants* pValue);
		[propput, id(DISPID_ICB_DROPDOWNKEY), helpstring("Retrieves or sets the key that opens the drop-down window when pressed.")]
		HRESULT DropDownKey([in] DropDownKeyConstants newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_ICB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the first item that is displayed in the drop-down list box control's client area</em>
		///
		/// Retrieves or sets the first combo box item, that is entirely located within the drop-down list box
		/// control's client area and therefore visible to the user.
		///
		/// \sa ComboItems
		[propget, id(DISPID_ICB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([out, retval] IImageComboBoxItem** ppFirstItem);
		[propputref, id(DISPID_ICB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first combo box item, that is entirely located within the drop-down list box control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([in] IImageComboBoxItem* pNewFirstItem);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont
		// \sa UseSystemFont, ListForeColor
		[propget, id(DISPID_ICB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_ICB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_ICB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor
		// \sa BackColor, ListForeColor
		[propget, id(DISPID_ICB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_ICB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies one of the control's associated image list</em>
		///
		/// Retrieves or sets the handle of the specified image list.
		///
		/// \param[in] image list The image list to retrieve or set. Any of the values defined by the
		///            \c ImageListConstants enumeration is valid.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa IconVisibility, ImageListConstants
		[propget, id(DISPID_ICB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_ICB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IImageComboBoxEvents::MouseHover
		[propget, id(DISPID_ICB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_ICB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndComboBox, hWndEdit, hWndListBox, _IImageComboBoxEvents::RecreatedControlWindow,
		///     _IImageComboBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_ICB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained combo box control's window handle</em>
		///
		/// Retrieves the contained combo box control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndEdit, hWndListBox, _IImageComboBoxEvents::CreatedComboBoxControlWindow,
		///     _IImageComboBoxEvents::DestroyedComboBoxControlWindow
		[propget, id(DISPID_ICB_HWNDCOMBOBOX), helpstring("Retrieves the contained combo box control's window handle."), nonbrowsable]
		HRESULT hWndComboBox([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the contained edit control's window handle</em>
		///
		/// Retrieves the contained edit control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndComboBox, hWndListBox, _IImageComboBoxEvents::CreatedEditControlWindow,
		///     _IImageComboBoxEvents::DestroyedEditControlWindow
		[propget, id(DISPID_ICB_HWNDEDIT), helpstring("Retrieves the contained edit control's window handle."), nonbrowsable]
		HRESULT hWndEdit([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the drop-down list box control's window handle</em>
		///
		/// Retrieves the drop-down list box control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWnd, hWndComboBox, hWndEdit, _IImageComboBoxEvents::CreatedListBoxControlWindow,
		///     _IImageComboBoxEvents::DestroyedListBoxControlWindow, _IImageComboBoxEvents::ListDropDown,
		///     _IImageComboBoxEvents::ListCloseUp
		[propget, id(DISPID_ICB_HWNDLISTBOX), helpstring("Retrieves the drop-down list box control's window handle."), nonbrowsable]
		HRESULT hWndListBox([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies whether item icons are displayed</em>
		///
		/// Retrieves or sets whether the item's icons are displayed. Any of the values defined by the
		/// \c IconVisibilityConstants enumeration is valid.
		///
		/// \sa hImageList, IconVisibilityConstants
		[propget, id(DISPID_ICB_ICONVISIBILITY), helpstring("Retrieves or sets whether the item's icons are displayed.")]
		HRESULT IconVisibility([out, retval] IconVisibilityConstants* pValue);
		[propput, id(DISPID_ICB_ICONVISIBILITY), helpstring("Retrieves or sets whether the item's icons are displayed.")]
		HRESULT IconVisibility([in] IconVisibilityConstants newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_ICB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_ICB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		// \brief <em>Specifies whether the control displays partial items</em>
		//
		// Retrieves or sets whether the control resizes itself so that an integral number of items is
		// displayed. If set to \c True, an integral number of items is displayed and the control's height
		// may be changed to achieve this; otherwise partial items may be displayed.
		//
		// \attention Changing this property destroys and recreates the control window.
		//
		// \sa ItemHeight
		//[propget, id(DISPID_ICB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		//HRESULT IntegralHeight([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_ICB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		//HRESULT IntegralHeight([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves whether the drop-down list box control is currently displayed</em>
		///
		/// Retrieves whether the drop-down list box control is currently displayed. If \c True, the list box
		/// is displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Style, DropDownButtonObjectState
		[propget, id(DISPID_ICB_ISDROPPEDDOWN), helpstring("Retrieves whether the drop-down list box control is currently displayed."), nonbrowsable]
		HRESULT IsDroppedDown([out, retval] VARIANT_BOOL* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_ICB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies all items' height</em>
		///
		/// Retrieves or sets the items' height in pixels. If set to -1, the default setting is used.
		///
		/// \sa IImageComboBoxItem::Height, SelectionFieldHeight
		// \sa IntegralHeight, IImageComboBoxItem::Height, SelectionFieldHeight
		[propget, id(DISPID_ICB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels.")]
		HRESULT ItemHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_ICB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels.")]
		HRESULT ItemHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the visibility of the vertical scroll bar in the drop-down list box control</em>
		///
		/// Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled
		/// instead of hidden if the control does not contain enough items to scroll. If set to \c True, the
		/// scroll bar is disabled; otherwise it is hidden.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ComboItems
		// \sa ComboItems, ListScrollableWidth
		[propget, id(DISPID_ICB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_LISTALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar in the drop-down list box control is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT ListAlwaysShowVerticalScrollBar([in] VARIANT_BOOL newValue);
		// \brief <em>Specifies the drop-down list box control's background color</em>
		//
		// Retrieves or sets the drop-down list box control's background color.
		//
		// \sa ListForeColor, BackColor, ListInsertMarkColor
		//[propget, id(DISPID_ICB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		//HRESULT ListBackColor([out, retval] OLE_COLOR* pValue);
		//[propput, id(DISPID_ICB_LISTBACKCOLOR), helpstring("Retrieves or sets the drop-down list box control's background color.")]
		//HRESULT ListBackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa RegisterForOLEDragDrop, _IImageComboBoxEvents::ListOLEDragMouseMove
		[propget, id(DISPID_ICB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_ICB_LISTDRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT ListDragScrollTimeBase([in] LONG newValue);
		// \brief <em>Specifies the drop-down list box control's text color</em>
		//
		// Retrieves or sets the drop-down list box control's text color.
		//
		// \sa ListBackColor, ForeColor, ListInsertMarkColor
		//[propget, id(DISPID_ICB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		//HRESULT ListForeColor([out, retval] OLE_COLOR* pValue);
		//[propput, id(DISPID_ICB_LISTFORECOLOR), helpstring("Retrieves or sets the drop-down list box control's text color.")]
		//HRESULT ListForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the height of the drop-down list box</em>
		///
		/// Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting
		/// is used.
		///
		/// \sa ListWidth
		// \sa ListWidth, MinVisibleItems
		[propget, id(DISPID_ICB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_ICB_LISTHEIGHT), helpstring("Retrieves or sets the height in pixels of the drop-down list box. If set to -1, the default setting is used.")]
		HRESULT ListHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \sa SetListInsertMarkPosition
		// \sa SetListInsertMarkPosition, ListBackColor, ListForeColor
		[propget, id(DISPID_ICB_LISTINSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT ListInsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_ICB_LISTINSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT ListInsertMarkColor([in] OLE_COLOR newValue);
		// \brief <em>Specifies the width by which the drop-down list box can be scrolled horizontally</em>
		//
		// Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled
		// horizontally. If the width of the control is greater than this value, a horizontal scroll bar is
		// displayed.
		//
		// \sa ListAlwaysShowVerticalScrollBar, ListWidth
		//[propget, id(DISPID_ICB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		//HRESULT ListScrollableWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		//[propput, id(DISPID_ICB_LISTSCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the drop-down list box can be scrolled horizontally.")]
		//HRESULT ListScrollableWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the width of the drop-down list box</em>
		///
		/// Retrieves or sets the width in pixels of the drop-down list box.
		///
		/// \remarks The minimum width of the drop-down list box is the combo box width.
		///
		/// \sa ListHeight
		// \sa ListHeight, ListScrollableWidth
		[propget, id(DISPID_ICB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_ICB_LISTWIDTH), helpstring("Retrieves or sets the width in pixels of the drop-down list box. The minimum width of the drop-down list box is the combo box width.")]
		HRESULT ListWidth([in] OLE_XSIZE_PIXELS newValue);
		// \brief <em>Specifies the control's current locale</em>
		//
		// Retrieves or sets the control's current locale. The locale influences how items are sorted if the
		// \c Sorted property is set to \c True. For a list of possible locale identifiers see
		// <a href="https://msdn.microsoft.com/en-us/library/dd318693.aspx">MSDN Online</a>.
		//
		// \sa Sorted
		//[propget, id(DISPID_ICB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		//HRESULT Locale([out, retval] LONG* pValue);
		//[propput, id(DISPID_ICB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		//HRESULT Locale([in] LONG newValue);
		/// \brief <em>Specifies the maximum length of the input</em>
		///
		/// Retrieves or sets the maximum number of characters, that the user can type into the control. If set
		/// to -1, the system's default setting is used.
		///
		/// \remarks Text, that is set through the \c Text property may exceed this limit.
		///
		/// \sa TextLength, Text, _IImageComboBoxEvents::TruncatedText
		[propget, id(DISPID_ICB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([out, retval] LONG* pValue);
		[propput, id(DISPID_ICB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type into the control.")]
		HRESULT MaxTextLength([in] LONG newValue);
		// \brief <em>Specifies the minimum number of visible items in the drop-down list box</em>
		//
		// Retrieves or sets the minimum number of visible items in the drop-down list box. The list box will
		// be made large enough to display the specified number of items, even if the height specified by the
		// \c ListHeight property is smaller.
		//
		// \remarks This property is ignored if the \c IntegralHeight property is set to \c False.\n
		//          Requires comctl32.dll version 6.0 or higher.
		//
		// \sa ListHeight
		// \sa ListHeight, IntegralHeight
		//[propget, id(DISPID_ICB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		//HRESULT MinVisibleItems([out, retval] LONG* pValue);
		//[propput, id(DISPID_ICB_MINVISIBLEITEMS), helpstring("Retrieves or sets the minimum number of visible items in the drop-down list box. This property is ignored if the 'IntegralHeight' property is set to 'False'. Requires comctl32.dll version 6.0 or higher.")]
		//HRESULT MinVisibleItems([in] LONG newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_ICB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_ICB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_ICB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_ICB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_ICB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_ICB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_ICB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IImageComboBoxEvents::ContextMenu
		[propget, id(DISPID_ICB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_ICB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IImageComboBoxEvents::OLEDragEnter
		[propget, id(DISPID_ICB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_ICB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_ICB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features. Changing this property destroys and recreates the control window.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the control's currently selected item</em>
		///
		/// Retrieves or sets the control's currently selected item.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa SelectionFieldItem, IImageComboBoxItem::Selected, SelectItemByText,
		///     _IImageComboBoxEvents::SelectionChanged
		[propget, id(DISPID_ICB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([out, retval] IImageComboBoxItem** ppSelectedItem);
		[propputref, id(DISPID_ICB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([in] IImageComboBoxItem* pNewSelectedItem);
		/// \brief <em>Specifies the height of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves or sets the height of the part of the control that displays the currently selected item.
		/// If set to -1, the default setting is used.
		///
		/// \sa ItemHeight
		[propget, id(DISPID_ICB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_ICB_SELECTIONFIELDHEIGHT), helpstring("Retrieves or sets the height of the part of the control that displays the currently selected item.")]
		HRESULT SelectionFieldHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the \c ImageComboBoxItem object wrapping the control's selection field</em>
		///
		/// Retrieves an \c ImageComboBoxItem object that may be used to control the properties of the
		/// control's selection field.
		///
		/// \remarks This property is read-only.
		///
		/// \sa SelectedItem
		[propget, id(DISPID_ICB_SELECTIONFIELDITEM), helpstring("Retrieves an 'ImageComboBoxItem' object that may be used to control the properties of the control's selection field."), nonbrowsable]
		HRESULT SelectionFieldItem([out, retval] IImageComboBoxItem** ppSelectionFieldItem);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa SupportOLEDragImages, _IImageComboBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_ICB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the items are sorted alphabetically</em>
		///
		/// Retrieves or sets whether the items in the control are sorted alphabetically. If set to \c True,
		/// the control sorts the items alphabetically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ComboItems
		// \sa ComboItems, Locale
		[propget, id(DISPID_ICB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how data can be input into the control</em>
		///
		/// Retrieves or sets which kind of user input is possible. Any of the values defined by the
		/// \c StyleConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa StyleConstants
		[propget, id(DISPID_ICB_STYLE), helpstring("Retrieves or sets which kind of user input is possible. Changing this property destroys and recreates the control window.")]
		HRESULT Style([out, retval] StyleConstants* pValue);
		[propput, id(DISPID_ICB_STYLE), helpstring("Retrieves or sets which kind of user input is possible. Changing this property destroys and recreates the control window.")]
		HRESULT Style([in] StyleConstants newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_ICB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_ICB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the text currently displayed in the combo portion</em>
		///
		/// Retrieves or sets the text currently displayed in the combo portion of the control.
		///
		/// \sa TextLength, TextHasBeenEdited, MaxTextLength, AcceptNumbersOnly, CueBanner, ForeColor, Font,
		///     _IImageComboBoxEvents::TextChanged
		[propget, id(DISPID_ICB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_ICB_TEXT), helpstring("Retrieves or sets the text currently displayed in the combo portion of the control."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Controls how items being too wide are drawn</em>
		///
		/// Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with
		/// an ellipsis ("..."). If set to \c True, the items are truncated with an ellipsis; otherwise they
		/// are clipped.
		///
		/// \remarks If the \c Style property is set to \c sComboField, this property should be set to
		///          \c False.\n
		///          Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa Style, Text
		[propget, id(DISPID_ICB_TEXTENDELLIPSIS), helpstring("Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with an ellipsis (\"...\"). If the 'Style' property is set to 'sComboField', this property should be set to 'False'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT TextEndEllipsis([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_TEXTENDELLIPSIS), helpstring("Retrieves or sets whether items, that are too wide for the control, are clipped or truncated with an ellipsis (\"...\"). If the 'Style' property is set to 'sComboField', this property should be set to 'False'. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT TextEndEllipsis([in] VARIANT_BOOL newValue);
		/// \brief <em>Checks whether the text displayed in the control's edit box has been edited</em>
		///
		/// Retrieves whether the text displayed in the control's edit box has been edited after the last
		/// \c BeginSelectionChange event has been raised. If \c True, the text has been edited; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Text, _IImageComboBoxEvents::BeginSelectionChange
		[propget, id(DISPID_ICB_TEXTHASBEENEDITED), helpstring("Retrieves whether the text displayed in the control's edit box has been edited after the last 'BeginSelectionChange' event has been raised. This property is read-only."), nonbrowsable]
		HRESULT TextHasBeenEdited([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the length of the text currently displayed in the combo portion</em>
		///
		/// Retrieves the length of the text specified by the \c Text property.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaxTextLength, Text
		[propget, id(DISPID_ICB_TEXTLENGTH), helpstring("Retrieves the length of the text specified by the 'Text' property. This property is read-only."), nonbrowsable]
		HRESULT TextLength([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether the control uses shell word delimiters</em>
		///
		/// Retrieves or sets whether the slash (/) backslash (\\) and period (.) characters are used as word
		/// delimiters. If set to \c True, these characters are used as word delimiters, making keyboard
		/// shortcuts for word-by-word cursor movement effective in path names and URLs. If set to \c False,
		/// the characters are not used as word delimiters.
		///
		/// \remarks If the \c Style property is set to \c sComboField, this property should be set to
		///          \c False.
		///
		/// \sa Style, Text
		[propget, id(DISPID_ICB_USESHELLWORDBREAKFUNCTION), helpstring("Retrieves or sets whether the slash (/) backslash (\\) and period (.) characters are used as word delimiters. If the 'Style' property is set to 'sComboField', this property should be set to 'False'.")]
		HRESULT UseShellWordBreakFunction([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_USESHELLWORDBREAKFUNCTION), helpstring("Retrieves or sets whether the slash (/) backslash (\\) and period (.) characters are used as word delimiters. If the 'Style' property is set to 'sComboField', this property should be set to 'False'.")]
		HRESULT UseShellWordBreakFunction([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_ICB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_ICB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_ICB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_ICB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Closes the drop-down list box control</em>
		///
		/// Closes the drop-down list box control.
		///
		/// \sa OpenDropDownWindow, _IImageComboBoxEvents::ListCloseUp, hWndListBox
		[id(DISPID_ICB_CLOSEDROPDOWNWINDOW), helpstring("Closes the drop-down list box control.")]
		HRESULT CloseDropDownWindow(void);
		/// \brief <em>Creates a new \c ImageComboBoxItemContainer object</em>
		///
		/// Retrieves a new \c ImageComboBoxItemContainer object and fills it with the specified items.
		///
		/// \param[in] items The item(s) to add to the collection. May be either \c Empty, an item ID, a
		///            \c ImageComboBoxItem object or a \c ImageComboBoxItems collection.
		///
		/// \return The created \c ImageComboBoxItemContainer object.
		///
		/// \sa IImageComboBoxItemContainer::Clone, IImageComboBoxItemContainer::Add
		[id(DISPID_ICB_CREATEITEMCONTAINER), helpstring("Retrieves a new 'ImageComboBoxItemContainer' object and fills it with 'items'.")]
		HRESULT CreateItemContainer([in, optional] VARIANT items, [out, retval] IImageComboBoxItemContainer** ppContainer);
		/// \brief <em>Finds an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByText, SelectItemByItemData, IImageComboBoxItem::ItemData
		[id(DISPID_ICB_FINDITEMBYITEMDATA), helpstring("Searches the combo box control for the first item that has the 'ItemData' property set to the specified value.")]
		HRESULT FindItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IImageComboBoxItem** ppFoundItem);
		/// \brief <em>Finds an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByItemData, SelectItemByText, CaseSensitiveItemSearching, IImageComboBoxItem::Text
		[id(DISPID_ICB_FINDITEMBYTEXT), helpstring("Searches the combo box control for the first item that starts with the specified text.")]
		HRESULT FindItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IImageComboBoxItem** ppFoundItem);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the drop-down list box control's
		///            upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the drop-down list box control's
		///            upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] comboItem The item at which the insertion mark should be displayed.
		///
		/// \sa SetListInsertMarkPosition, GetListInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_ICB_GETCLOSESTLISTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestListInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] IImageComboBoxItem** comboItem);
		/// \brief <em>Retrieves the bounding rectangle of the drop-down button that is displayed if \c Style is set to \c sComboDropDownList or \c sDropDownList</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// drop-down button which is displayed if the \c Style property is set to \c sComboDropDownList or
		/// \c sDropDownList.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the button's bounding
		///             rectangle relative to the control's upper-left corner.
		///
		/// \sa Style, GetSelectionFieldRectangle, GetDroppedStateRectangle
		[id(DISPID_ICB_GETDROPDOWNBUTTONRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the drop-down button which is displayed if the 'Style' property is set to 'sComboDropDownList' or 'sDropDownList'.")]
		HRESULT GetDropDownButtonRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the bounding rectangle of the control including the drop-down list box</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the
		/// control when it is dropped down, i. e. including the drop-down list box.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the overall bounding
		///             rectangle relative to the screen's upper-left corner.
		///
		/// \sa IsDroppedDown, GetDropDownButtonRectangle, GetSelectionFieldRectangle
		[id(DISPID_ICB_GETDROPPEDSTATERECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the control when it is dropped down, i. e. including the drop-down list box.")]
		HRESULT GetDroppedStateRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] comboItem The item at which the insertion mark is displayed.
		///
		/// \sa SetListInsertMarkPosition, GetClosestListInsertMarkPosition, GetListInsertMarkRectangle,
		///     InsertMarkPositionConstants
		[id(DISPID_ICB_GETLISTINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetListInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] IImageComboBoxItem** comboItem);
		/// \brief <em>Retrieves the bounding rectangle of the control's insertion mark</em>
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the drop-down list box control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the drop-down list box control's upper-left corner.
		///
		/// \sa GetListInsertMarkPosition, SetListInsertMarkPosition
		[id(DISPID_ICB_GETLISTINSERTMARKRECTANGLE), helpstring("Retrieves the bounding rectangle of the control's insertion mark.")]
		HRESULT GetListInsertMarkRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Retrieves the contained edit control's current selection's start and end</em>
		///
		/// Retrieves the zero-based character indices of the contained edit control's current selection's start and end.
		///
		/// \param[out] selectionStart The zero-based index of the character at which the selection starts.
		/// \param[out] selectionEnd The zero-based index of the first unselected character after the end of
		///             the selection.
		///
		/// \sa SetSelection
		[id(DISPID_ICB_GETSELECTION), helpstring("Retrieves the zero-based character indices of the contained edit control's current selection's start and end.")]
		HRESULT GetSelection([in, out, defaultvalue(0)] LONG* selectionStart, [in, out, defaultvalue(0)] LONG* selectionEnd);
		/// \brief <em>Retrieves the bounding rectangle of the part of the control that displays the currently selected item</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
		/// part of the control that displays the currently selected item.
		///
		/// \param[out] left The x-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] top The y-coordinate (in pixels) of the upper-left corner of the item field's bounding
		///             rectangle relative to the control's upper-left corner.
		/// \param[out] right The x-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		/// \param[out] bottom The y-coordinate (in pixels) of the lower-right corner of the item field's
		///             bounding rectangle relative to the control's upper-left corner.
		///
		/// \sa Style, GetDropDownButtonRectangle, GetDroppedStateRectangle
		[id(DISPID_ICB_GETSELECTIONFIELDRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the part of the control that displays the currently selected item.")]
		HRESULT GetSelectionFieldRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Left, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Top, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* Right, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* Bottom);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		///
		/// \return A value specifying the exact part of the control the specified point lies in. Some of the
		///         values defined by the \c HitTestConstants enumeration are valid.
		///
		/// \sa ListHitTest, HitTestConstants
		[id(DISPID_ICB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [out, retval] HitTestConstants* pHitTestDetails);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the drop-down list box control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            drop-down list box control's upper-left corner.
		/// \param[out] hitTestDetails Receives a value specifying the exact part of the drop-down list box
		///             control the specified point lies in. Some of the values defined by the
		///             \c HitTestConstants enumeration are valid.
		///
		/// \return The item that the specified point belongs to. \c Nothing, if no item was "hit".
		///
		/// \sa HitTest, HitTestConstants
		[id(DISPID_ICB_LISTHITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT ListHitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IImageComboBoxItem** ppHitItem);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_ICB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedItems A collection object containing the items to drag. This parameter is
		///            used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of items
		///            contained in the \c draggedItems collection is displayed in the item count label. If
		///            set to any value larger than 1, this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa _IImageComboBoxEvents::ItemBeginDrag, _IImageComboBoxEvents::ItemBeginRDrag,
		///     _IImageComboBoxEvents::OLEStartDrag, _IImageComboBoxEvents::OLEGiveFeedback,
		///     _IImageComboBoxEvents::OLEQueryContinueDrag, SupportOLEDragImages, OLEDragImageStyle,
		///     OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_ICB_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] IImageComboBoxItemContainer* DraggedItems, [in, defaultvalue(-1)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Opens the drop-down list box control</em>
		///
		/// Opens the drop-down list box control.
		///
		/// \sa CloseDropDownWindow, _IImageComboBoxEvents::ListDropDown, hWndListBox
		[id(DISPID_ICB_OPENDROPDOWNWINDOW), helpstring("Opens the drop-down list box control.")]
		HRESULT OpenDropDownWindow(void);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_ICB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_ICB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Finds and selects an item by its \c ItemData property</em>
		///
		/// Searches the combo box control for the first item that has the \c ItemData property set to the
		/// specified value. If a matching item is found, it is made the selected item as specified by the
		/// \c SelectedItem property.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByText, FindItemByItemData, IImageComboBoxItem::ItemData, SelectedItem
		[id(DISPID_ICB_SELECTITEMBYITEMDATA), helpstring("Searches the list box control for the first item that has the 'ItemData' property set to the specified value. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IImageComboBoxItem** ppFoundItem);
		/// \brief <em>Finds and selects an item by its text</em>
		///
		/// Searches the combo box control for the first item that starts with the specified text. If a matching
		/// item is found, it is made the selected item as specified by the \c SelectedItem property.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByItemData, FindItemByText, CaseSensitiveItemSearching, IImageComboBoxItem::Text,
		///     SelectedItem
		[id(DISPID_ICB_SELECTITEMBYTEXT), helpstring("Searches the list box control for the first item that starts with the specified text. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IImageComboBoxItem** ppFoundItem);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified item. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] comboItem The item at which to show the insertion mark. If set to \c Nothing, the
		///            insertion mark will be removed.
		///
		/// \sa GetListInsertMarkPosition, GetClosestListInsertMarkPosition, ListInsertMarkColor,
		///     RegisterForOLEDragDrop, InsertMarkPositionConstants
		[id(DISPID_ICB_SETLISTINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetListInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] IImageComboBoxItem* comboItem);
		/// \brief <em>Sets the contained edit control's selection's start and end</em>
		///
		/// Sets the zero-based character indices of the contained edit control's selection's start and end.
		///
		/// \param[in] selectionStart The zero-based index of the character at which the selection starts. If
		///            set to -1, the current selection is cleared.
		/// \param[in] selectionEnd The zero-based index of the first unselected character after the end of
		///            the selection.
		///
		/// \remarks To select all text in the contained edit control, set \c selectionStart to 0 and
		///          \c selectionEnd to -1.
		///
		/// \sa GetSelection
		[id(DISPID_ICB_SETSELECTION), helpstring("Sets the zero-based character indices of the contained edit control's selection's start and end.")]
		HRESULT SetSelection([in] LONG selectionStart, [in] LONG selectionEnd);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IImageComboBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_ICB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IImageComboBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ImageComboBox class' events interface</em>
	///
	/// This interface defines all events the \c ImageComboBox class may raise.
	///
	/// \sa IImageComboBox
	[
		uuid(B4039F32-66CD-4535-93CE-F3D96F31AD5B),
		helpstring("IImageComboBox-event-interface")
	]
	dispinterface _IImageComboBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The selected item was changed</em>
			///
			/// Will be fired after another item became the selected item.
			///
			/// \param[in] previousSelectedItem The previous selected item.
			/// \param[in] newSelectedItem The new selected item.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa IImageComboBoxItem::Selected, IImageComboBox::SelectedItem, SelectionCanceled,
			///     SelectionChanging
			[id(DISPID_ICBE_SELECTIONCHANGED), helpstring("Will be fired after another item became the selected item.")]
			void SelectionChanged(IImageComboBoxItem* previousSelectedItem, IImageComboBoxItem* newSelectedItem);
			/// \brief <em>The control's text is about to be drawn</em>
			///
			/// Will be fired before the contained edit control's content is drawn.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IImageComboBox::Text, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_BEFOREDRAWTEXT), helpstring("Will be fired before the contained edit control's content is drawn. This event may be disabled.")]
			void BeforeDrawText(void);
			/// \brief <em>The user has activated the drop-down list or clicked into the control's edit box</em>
			///
			/// Will be fired after the user has activated the drop-down list or clicked into the control's edit
			/// box.
			///
			/// \sa SelectionChanging
			[id(DISPID_ICBE_BEGINSELECTIONCHANGE), helpstring("Will be fired after the user has activated the drop-down list or clicked into the control's edit box.")]
			void BeginSelectionChange(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, ListClick, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The part of the control that the menu's proposed position lies in.
			///            Some of the values defined by the \c HitTestConstants enumeration are valid.
			/// \param[in,out] showDefaultMenu If set to \c True, the default context menu is displayed;
			///                otherwise the control doesn't display any context menu itself, but you may
			///                display your custom menu.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_ICBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* showDefaultMenu);
			/// \brief <em>The contained combo box control was created</em>
			///
			/// Will be fired after the contained combo box control was created.
			///
			/// \param[in] hWndComboBox The contained combo box control's window handle.
			///
			/// \sa DestroyedComboBoxControlWindow, IImageComboBox::hWndComboBox
			[id(DISPID_ICBE_CREATEDCOMBOBOXCONTROLWINDOW), helpstring("Will be fired after the contained combo box control was created.")]
			void CreatedComboBoxControlWindow(LONG hWndComboBox);
			/// \brief <em>The contained edit control was created</em>
			///
			/// Will be fired after the contained edit control was created.
			///
			/// \param[in] hWndEdit The contained edit control's window handle.
			///
			/// \sa DestroyedEditControlWindow, IImageComboBox::hWndEdit
			[id(DISPID_ICBE_CREATEDEDITCONTROLWINDOW), helpstring("Will be fired after the contained edit control was created.")]
			void CreatedEditControlWindow(LONG hWndEdit);
			/// \brief <em>The drop-down list box control was created</em>
			///
			/// Will be fired after the drop-down list box control was created.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa DestroyedListBoxControlWindow, ListDropDown, IImageComboBox::hWndListBox
			[id(DISPID_ICBE_CREATEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was created.")]
			void CreatedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The drop-down combo box control was destroyed</em>
			///
			/// Will be fired after the drop-down combo box control was destroyed.
			///
			/// \param[in] hWndComboBox The drop-down combo box control's window handle.
			///
			/// \sa CreatedComboBoxControlWindow, IImageComboBox::hWndComboBox
			[id(DISPID_ICBE_DESTROYEDCOMBOBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down combo box control was destroyed.")]
			void DestroyedComboBoxControlWindow(LONG hWndComboBox);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IImageComboBox::hWnd
			[id(DISPID_ICBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The contained edit control was destroyed</em>
			///
			/// Will be fired after the contained edit control was destroyed.
			///
			/// \param[in] hWndEdit The contained edit control's window handle.
			///
			/// \sa CreatedEditControlWindow, IImageComboBox::hWndEdit
			[id(DISPID_ICBE_DESTROYEDEDITCONTROLWINDOW), helpstring("Will be fired after the contained edit control was destroyed.")]
			void DestroyedEditControlWindow(LONG hWndEdit);
			/// \brief <em>The drop-down list box control was destroyed</em>
			///
			/// Will be fired after the drop-down list box control was destroyed.
			///
			/// \param[in] hWndListBox The drop-down list box control's window handle.
			///
			/// \sa CreatedListBoxControlWindow, ListCloseUp, IImageComboBox::hWndListBox
			[id(DISPID_ICBE_DESTROYEDLISTBOXCONTROLWINDOW), helpstring("Will be fired after the drop-down list box control was destroyed.")]
			void DestroyedListBoxControlWindow(LONG hWndListBox);
			/// \brief <em>Any data associated with an item should be freed</em>
			///
			/// Will be fired if any data associated with the specified item should be freed.
			///
			/// \param[in] comboItem The item for which to free the data. If \c Nothing, all items' data should
			///            be freed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all items freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingItem, RemovedItem, IImageComboBoxItem::ItemData, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_FREEITEMDATA), helpstring("Will be fired if any data associated with the specified item should be freed. This event may be disabled.")]
			void FreeItemData(IImageComboBoxItem* comboItem);
			/// \brief <em>An item was inserted</em>
			///
			/// Will be fired after a new item was inserted.
			///
			/// \param[in] comboItem The item that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingItem, RemovedItem, IImageComboBoxItem, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_INSERTEDITEM), helpstring("Will be fired after a new item was inserted. This event may be disabled.")]
			void InsertedItem(IImageComboBoxItem* comboItem);
			/// \brief <em>An item is about to be inserted</em>
			///
			/// Will be fired before a new item is inserted.
			///
			/// \param[in] comboItem The item that is about to be inserted. If the combo box is sorted, this
			///            object's \c Index property may be wrong.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the item
			///                isn't inserted. If set to \c False, the item is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedItem, RemovingItem, IVirtualImageComboBoxItem::Index, IImageComboBox::Sorted,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_INSERTINGITEM), helpstring("Will be fired before a new item is inserted. This event may be disabled.")]
			void InsertingItem(IVirtualImageComboBoxItem* comboItem, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the left mouse button.
			///
			/// \param[in] comboItem The item that the user wants to drag. May be \c Nothing, indicating that
			///            the content of the selection field shall be dragged.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IImageComboBox::OLEDrag, ItemBeginRDrag, HitTestConstants
			[id(DISPID_ICBE_ITEMBEGINDRAG), helpstring("Will be fired if the user seems to want to drag an item using the left mouse button.")]
			void ItemBeginDrag(IImageComboBoxItem* comboItem, BSTR selectionFieldText, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the right mouse button.
			///
			/// \param[in] comboItem The item that the user wants to drag. May be \c Nothing, indicating that
			///            the content of the selection field shall be dragged.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IImageComboBox::OLEDrag, ItemBeginDrag, HitTestConstants
			[id(DISPID_ICBE_ITEMBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag an item using the right mouse button.")]
			void ItemBeginRDrag(IImageComboBoxItem* comboItem, BSTR selectionFieldText, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The value of an item's property is required</em>
			///
			/// Will be fired if an item property was set-up to use a callback and now this property's value is
			/// required.
			///
			/// \param[in] comboItem The item that the value is required for.
			/// \param[in] requestedInfo Specifies which properties' values are required. Any combination of
			///            the values defined by the \c RequestedInfoConstants enumeration is valid.
			/// \param[out] iconIndex Set this parameter to the zero-based index of the icon to use. The
			///             icon is taken from the control's \c ilItems image list. If the \c requestedInfo
			///             parameter doesn't include \c riIconIndex, this value is ignored.
			/// \param[out] selectedIconIndex Set this parameter to the zero-based index of the icon to use.
			///             The icon is taken from the control's \c ilItems image list. If the \c requestedInfo
			///             parameter doesn't include \c riSelectedIconIndex, this value is ignored.
			/// \param[out] overlayIndex Set this parameter to the zero-based index of the overlay icon to use
			///             for the specified item. The overlay icon is taken from the control's \c ilItems
			///             image list. If the \c requestedInfo parameter doesn't include \c riOverlayIndex, this
			///             value is ignored.
			/// \param[out] indent Set this parameter to the item's indentation in steps of 10 pixels. If the
			///             \c requestedInfo parameter doesn't include \c riIndent, this value is ignored.
			/// \param[in] maxItemTextLength The maximum number of characters the item's text may consist of. If
			///            the \c requestedInfo parameter doesn't include \c riItemText, this value is ignored.
			/// \param[out] itemText Set this parameter to the text to use for the specified item. If the
			///             \c requestedInfo parameter doesn't include \c riItemText, this value is ignored.
			/// \param[in,out] dontAskAgain If set to \c True, this event won't be fired again for the
			///                specified item. Instead the specified values will be persisted.
			///
			/// \sa IImageComboBoxItem::IconIndex, IImageComboBoxItem::SelectedIconIndex,
			///     IImageComboBox::hImageList, IImageComboBoxItem::Indent, IImageComboBoxItem::Text,
			///     IImageComboBoxItem::OverlayIndex, RequestedInfoConstants, ImageListConstants
			[id(DISPID_ICBE_ITEMGETDISPLAYINFO), helpstring("Will be fired if an item property was set-up to use a callback and now this property's value is required.")]
			void ItemGetDisplayInfo(IImageComboBoxItem* comboItem, RequestedInfoConstants requestedInfo, LONG* IconIndex, LONG* SelectedIconIndex, LONG* OverlayIndex, LONG* Indent, LONG maxItemTextLength, BSTR* itemText, VARIANT_BOOL* dontAskAgain);
			/// \brief <em>The mouse cursor was moved into an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseLeave, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_ITEMMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseEnter(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle.
			///
			/// \param[in] comboItem The item that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Most of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseEnter, ListMouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_ITEMMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseLeave(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the drop-down list box control's client area</em>
			///
			/// Will be fired if the user clicks into the drop-down list box control's client area using
			/// the left mouse button.
			///
			/// \param[in] pComboItem The clicked item. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always be
			///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
			///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the drop-down list
			///            box control's upper-left corner.
			/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the drop-down list
			///            box control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the drop-down list box control that was clicked. Any
			///            of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_LISTCLICK), helpstring("Will be fired if the user clicks into the drop-down list box control's client area using the left mouse button. This event may be disabled.")]
			void ListClick(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control's drop-down list box window was closed</em>
			///
			/// Will be fired after the drop-down list box window has been closed.
			///
			/// \sa ListDropDown, IImageComboBox::CloseDropDownWindow, IImageComboBox::hWndListBox
			[id(DISPID_ICBE_LISTCLOSEUP), helpstring("Will be fired after the drop-down list box window has been closed.")]
			void ListCloseUp();
			/// \brief <em>The control's drop-down list box window was opened</em>
			///
			/// Will be fired after the drop-down list box window has been opened (before it is made
			/// visible).
			///
			/// \sa ListCloseUp, IImageComboBox::OpenDropDownWindow, IImageComboBox::hWndListBox
			[id(DISPID_ICBE_LISTDROPDOWN), helpstring("Will be fired after the drop-down list box window has been opened (before it is made visible).")]
			void ListDropDown();
			/// \brief <em>A mouse button was pressed over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseUp, ListClick, MouseDown, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_LISTMOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseDown(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, ListMouseUp, ListMouseWheel, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_LISTMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseMove(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// drop-down list box control's client area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseDown, ListClick, MouseUp, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_LISTMOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseUp(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the drop-down list box control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the drop-down list box control's client
			/// area.
			///
			/// \param[in] comboItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ListMouseMove, MouseWheel, HitTestConstants, ExtendedMouseButtonConstants,
			///     ScrollAxisConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_LISTMOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the drop-down list box control's client area. This event may be disabled.")]
			void ListMouseWheel(IImageComboBoxItem* comboItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the drop-down list box control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragLeave, ListMouseUp, OLEDragDrop,
			///     IImageComboBox::RegisterForOLEDragDrop, IImageComboBox::FinishOLEDragDrop,
			///     OLEDropEffectConstants, IImageComboBox::SetListInsertMarkPosition, HitTestConstants
			[id(DISPID_ICBE_LISTOLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the drop-down list box control's client area.")]
			void ListOLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragMouseMove, ListOLEDragLeave, ListOLEDragDrop, OLEDragEnter,
			///     IImageComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IImageComboBox::ListDragScrollTimeBase, IImageComboBox::SetListInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_ICBE_LISTOLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the drop-down list box control's client area.")]
			void ListOLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the drop-down list
			/// box control's client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoCloseUp If set to \c True, the drop-down list box control will be closed
			///                automatically; otherwise not.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa ListOLEDragEnter, ListOLEDragMouseMove, ListOLEDragDrop, OLEDragLeave,
			///     IImageComboBox::RegisterForOLEDragDrop, IImageComboBox::SetListInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_ICBE_LISTOLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list box control's client area or if the user canceled the drag'n'drop operation.")]
			void ListOLEDragLeave(IOLEDataObject* data, IImageComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, VARIANT_BOOL* autoCloseUp);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the drop-down list
			/// box control's client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the drop-down
			///            list box control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the drop-down list box control that the mouse
			///            cursor's position lies in. Any of the values defined by the \c HitTestConstants
			///            enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                drop-down list box control auto-scrolls to the left; if set to a value greater
			///                than 0, the drop-down list box control auto-scrolls to the right. The
			///                higher/lower the value is, the faster the drop-down list box control scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the drop-down
			///                list box control auto-scrolls upwardly; if set to a value greater than 0, the
			///                drop-down list box control auto-scrolls downwards. The higher/lower the value is,
			///                the faster the drop-down list box control scrolls.
			///
			/// \sa ListOLEDragEnter, ListOLEDragLeave, ListOLEDragDrop, ListMouseMove, OLEDragMouseMove,
			///     IImageComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IImageComboBox::ListDragScrollTimeBase, IImageComboBox::SetListInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_ICBE_LISTOLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void ListOLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IListBox::HoverTime property.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IImageComboBox::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, HitTestConstants,
			///     ExtendedMouseButtonConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ListMouseWheel, ExtendedMouseButtonConstants, ScrollAxisConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa IImageComboBox::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_ICBE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, ListOLEDragDrop,
			///     IImageComboBox::RegisterForOLEDragDrop, IImageComboBox::FinishOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_ICBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, ListOLEDragEnter,
			///     IImageComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants,
			///     IImageComboBox::DragDropDownTime
			[id(DISPID_ICBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, IImageComboBox::OLEDrag
			[id(DISPID_ICBE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, ListOLEDragLeave,
			///     IImageComboBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_ICBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IImageComboBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, IImageComboBox::OLEDrag
			[id(DISPID_ICBE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoDropDown If set to \c True, the drop-down list box control will be opened
			///                automatically; otherwise not.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, ListOLEDragMouseMove,
			///     IImageComboBox::RegisterForOLEDragDrop, OLEDropEffectConstants, HitTestConstants
			///     IImageComboBox::DragDropDownTime
			[id(DISPID_ICBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IImageComboBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoDropDown);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa IImageComboBox::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_ICBE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa IImageComboBox::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_ICBE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_ICBE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_ICBE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa IImageComboBox::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_ICBE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the control cannot allocate enough memory to meet a specific request.
			[id(DISPID_ICBE_OUTOFMEMORY), helpstring("Will be fired if the control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IImageComboBox::hWnd
			[id(DISPID_ICBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>An item was removed</em>
			///
			/// Will be fired after an item was removed.
			///
			/// \param[in] comboItem The item that was removed. If \c Nothing, all items were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingItem, InsertedItem, IVirtualImageComboBoxItem, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_REMOVEDITEM), helpstring("Will be fired after an item was removed. If 'comboItem' is 'Nothing', all items were removed. This event may be disabled.")]
			void RemovedItem(IVirtualImageComboBoxItem* comboItem);
			/// \brief <em>An item is about to be removed</em>
			///
			/// Will be fired before an item is removed.
			///
			/// \param[in] comboItem The item that is about to be removed. If \c Nothing, all items are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the item isn't
			///                removed. If set to \c False, the item is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedItem, InsertingItem, IImageComboBoxItem, IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_REMOVINGITEM), helpstring("Will be fired before an item is removed. If 'comboItem' is 'Nothing', all items are removed. This event may be disabled.")]
			void RemovingItem(IImageComboBoxItem* comboItem, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_ICBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The user canceled changing the selected item</em>
			///
			/// Will be fired after the user canceled changing the selected item.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IImageComboBoxItem::Selected, IImageComboBox::SelectedItem, SelectionChanging,
			///     SelectionChanged
			[id(DISPID_ICBE_SELECTIONCANCELED), helpstring("Will be fired after the user canceled changing the selected item. This event may be disabled.")]
			void SelectionCanceled(void);
			/// \brief <em>The user has concluded an action that changes the currently selected item</em>
			///
			/// Will be fired after the user has concluded an operation within the control's edit box or has
			/// selected an item from the control's drop-down list, but before the selected item is changed.
			///
			/// \param[in] newSelectedItem The item that will become the selected item. May be \c Nothing.
			/// \param[in] selectionFieldText The text currently being displayed in the selection field.
			/// \param[in] selectionFieldHasBeenEdited Specifies whether the text displayed in the control's
			///            edit box has been edited. If \c True, the text has been edited; otherwise not.
			/// \param[in] selectionChangeReason Specifies the action that led to this event being raised. Any
			///            of the values defined by the \c SelectionChangeReasonConstants enumeration is valid.
			/// \param[in,out] cancelChange If set to \c True, the selection change is aborted, i. e. the
			///                currently selected item remains selected. If set to \c False, the selection is
			///                changed to the item specified by \c newSelectedItem.
			///
			/// \sa BeginSelectionChange, SelectionChanged, SelectionCanceled, SelectionChangeReasonConstants
			[id(DISPID_ICBE_SELECTIONCHANGING), helpstring("Will be fired after the user has concluded an operation within the control's edit box or has selected an item from the control's drop-down list, but before the selected item is changed.")]
			void SelectionChanging(IImageComboBoxItem* newSelectedItem, BSTR selectionFieldText, VARIANT_BOOL selectionFieldHasBeenEdited, SelectionChangeReasonConstants selectionChangeReason, VARIANT_BOOL* cancelChange);
			/// \brief <em>The control's text was changed</em>
			///
			/// Will be fired after the contained edit control's content was changed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IImageComboBox::Text
			[id(DISPID_ICBE_TEXTCHANGED), helpstring("Will be fired after the contained edit control's content was changed. This event may be disabled.")]
			void TextChanged(void);
			/// \brief <em>The text, that was entered into the control, got truncated</em>
			///
			/// Will be fired if the text, that was entered into the contained edit control, got truncated. This
			/// happens in the following situations:
			/// - The control's resulting text would have been longer than allowed by the \c MaxTextLength
			///   property.
			/// - The control would have to scroll horizontally to display the entered text, but the
			///   \c AutoHorizontalScrolling property is set to \c False.
			///
			/// \sa IImageComboBox::Text, IImageComboBox::MaxTextLength, IImageComboBox::AutoHorizontalScrolling
			[id(DISPID_ICBE_TRUNCATEDTEXT), helpstring("Will be fired if the text, that was entered into the contained edit control, got truncated.")]
			void TruncatedText(void);
			/// \brief <em>The control's writing direction has been changed by the user</em>
			///
			/// Will be fired if the contained edit control's writing direction has been changed by the user.
			///
			/// \param[in] newWritingDirection The control's new writing direction. Any of the values defined by
			///            the \c WritingDirectionConstants enumeration is valid.
			///
			/// \remarks Due to limitations of Microsoft Windows, this event is not raised if the writing
			///          direction is changed using the contained edit control's default context menu.
			///
			/// \sa IImageComboBox::RightToLeft, WritingDirectionConstants
			[id(DISPID_ICBE_WRITINGDIRECTIONCHANGED), helpstring("Will be fired if the control's writing direction has been changed by the user.")]
			void WritingDirectionChanged(WritingDirectionConstants newWritingDirection);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IImageComboBox::DisabledEvents
			[id(DISPID_ICBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ImageComboBox class</em>
	///
	/// The control's main COM class. It implements the \c IImageComboBox and
	/// \c _IImageComboBoxEvents interfaces.
	///
	/// \sa IImageComboBox, _IImageComboBoxEvents
	[
		uuid(9FA8C3C4-6AF0-45ad-9947-054365A8DEEC),
		version(1.5),
		helpstring("ImageComboBox Control 1.5 (Unicode)")
	]
	coclass ImageComboBox
	{
		[default] interface IImageComboBox;
		[default, source] dispinterface _IImageComboBoxEvents;
	};


	/// \interface IVirtualListBoxItem
	/// \brief <em>Wraps a not existing item</em>
	///
	/// This interface is a wrapper around a list box item that does not yet or not anymore exist within
	/// the control.
	///
	/// \sa _IVirtualListBoxItemEvents, IListBoxItem, _IListBoxEvents
	[
		object,
		uuid(EB149D9C-0C73-4bfe-9DC3-09D9BD20A7A4),
		dual,
		nonextensible,
		helpstring("IVirtualListBoxItem interface"),
		pointer_default(unique)
	]
	interface IVirtualListBoxItem : IDispatch
	{
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves the zero-based index that will identify or has identified the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IListBoxItems::Add
		[propget, id(DISPID_VLBI_INDEX), helpstring("Retrieves the item's zero-based index."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the item.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IListBoxEvents::FreeItemData
		[propget, id(DISPID_VLBI_ITEMDATA), helpstring("Retrieves the Long value associated with the item."), nonbrowsable]
		HRESULT ItemData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's text</em>
		///
		/// Retrieves the item's text.
		///
		/// \remarks This is the default property of the \c IVirtualListBoxItem interface.\n
		///          This property is read-only.
		[propget, id(DISPID_VLBI_TEXT), helpstring("Retrieves the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
	}


	/// \interface _IVirtualListBoxItemEvents
	/// \brief <em>The \c VirtualListBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c VirtualListBoxItem class may raise.
	///
	/// \sa IVirtualListBoxItem
	[
		uuid(AA6CB256-611F-487d-AE5F-2E5114ED1059),
		helpstring("IVirtualListBoxItem-event-interface")
	]
	dispinterface _IVirtualListBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualListBoxItem class</em>
	///
	/// This COM class implements the \c IVirtualListBoxItem and \c _IVirtualListBoxItemEvents
	/// interfaces.
	///
	/// \sa IVirtualListBoxItem, _IVirtualListBoxItemEvents, ListBox, ListBoxItem
	[
		uuid(F0E0EC99-41BD-45d1-89A5-054D1D8C63D0),
		version(1.0),
		noncreatable,
		helpstring("VirtualListBoxItem Class 1.0 (Unicode)")
	]
	coclass VirtualListBoxItem
	{
		[default] interface IVirtualListBoxItem;
		[default, source] dispinterface _IVirtualListBoxItemEvents;
	};


	/// \interface IListBoxItem
	/// \brief <em>Wraps an existing list box item</em>
	///
	/// This interface is a wrapper around an item that - unlike an item wrapped by
	/// \c IVirtualListBoxItem - really exists within the control.
	///
	/// \sa _IListBoxItemEvents, IVirtualListBoxItem, IListBoxItems, IListBoxItemContainer,
	///     IListBox, _IListBoxEvents
	[
		object,
		uuid(99215EC6-8CCE-44bf-A4E0-1834688B1736),
		dual,
		nonextensible,
		helpstring("IListBoxItem interface"),
		pointer_default(unique)
	]
	interface IListBoxItem : IDispatch
	{
		/// \brief <em>Retrieves whether the item is the control's selection anchor item</em>
		///
		/// Retrieves whether the item is the control's anchor item, i. e. it's the item with which
		/// range-selection begins. If it is the anchor item, this property is set to \c True; otherwise
		/// it's set to \c False.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Caret, Selected, IListBox::MultiSelect, IListBox::AnchorItem
		[propget, id(DISPID_LBI_ANCHOR), helpstring("Retrieves whether the item is the current anchor item, i. e. it's the item with which range-selection begins.")]
		HRESULT Anchor([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the item is the control's caret item</em>
		///
		/// Retrieves whether the item is the control's caret item, i. e. it has the focus. If it is the
		/// caret item, this property is set to \c True; otherwise it's set to \c False.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Anchor, Selected, IListBox::CaretItem
		[propget, id(DISPID_LBI_CARET), helpstring("Retrieves whether the item is the current caret item, i. e. it has the focus.")]
		HRESULT Caret([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the item's height</em>
		///
		/// Retrieves or sets the item's height in pixels.
		///
		/// \remarks If the \c OwnerDrawItems property is not set to \c odiOwnerDrawVariableHeight, this
		///          property is read-only. Use the \c IListBox::ItemHeight property instead.
		///
		/// \sa GetRectangle, IListBox::OwnerDrawItems, IListBox::ItemHeight
		[propget, id(DISPID_LBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ListBox.ItemHeight' property instead.")]
		HRESULT Height([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_LBI_HEIGHT), helpstring("Retrieves or sets the item's height in pixels. If the 'OwnerDrawItems' property is not set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ListBox.ItemHeight' property instead.")]
		HRESULT Height([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the item's ID</em>
		///
		/// Retrieves an unique ID identifying this item.
		///
		/// \remarks An item's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, ItemIdentifierTypeConstants
		[propget, id(DISPID_LBI_ID), helpstring("Retrieves the item's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the item's zero-based index</em>
		///
		/// Retrieves a zero-based index identifying this item.
		///
		/// \remarks Although adding or removing items changes other items' indexes, the index is the best
		///          (and fastest) option to identify an item.\n
		///          This property is read-only.
		///
		/// \sa ID, ItemIdentifierTypeConstants
		[propget, id(DISPID_LBI_INDEX), helpstring("Retrieves the item's zero-based index.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies the item's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the item. Use this property to associate
		/// any data with the item.
		///
		/// \sa _IListBoxEvents::FreeItemData
		[propget, id(DISPID_LBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([out, retval] LONG* pValue);
		[propput, id(DISPID_LBI_ITEMDATA), helpstring("Retrieves or sets the Long value associated with the item.")]
		HRESULT ItemData([in] LONG newValue);
		/// \brief <em>Specifies whether the item is selected</em>
		///
		/// Retrieves or sets whether the item is drawn as a selected item, i. e. whether its background
		/// is highlighted. If this property is set to \c True, the item is highlighted; otherwise not.
		///
		/// \sa IListBox::MultiSelect, IListBox::DeselectItems, IListBox::SelectItems, Anchor, Caret,
		///     IListBox::CaretItem
		[propget, id(DISPID_LBI_SELECTED), helpstring("Retrieves or sets whether the item is drawn as a selected item.")]
		HRESULT Selected([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LBI_SELECTED), helpstring("Retrieves or sets whether the item is drawn as a selected item.")]
		HRESULT Selected([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the item's text</em>
		///
		/// Retrieves or sets the item's text.
		///
		/// \remarks This is the default property of the \c IListBoxItem interface.
		///
		/// \sa IListBox::ProcessTabs
		[propget, id(DISPID_LBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_LBI_TEXT), helpstring("Retrieves or sets the item's text.")]
		HRESULT Text([in] BSTR newValue);

		/// \brief <em>Retrieves an image list containing the item's drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of this item.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return The handle to the image list containing the drag image.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_LBI_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of this item.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Retrieves the bounding rectangle of either the item or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the
		/// item or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c ItemRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \sa Height, ItemRectangleTypeConstants
		[id(DISPID_LBI_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the item or a part of it.")]
		HRESULT GetRectangle(ItemRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
	}


	/// \interface _IListBoxItemEvents
	/// \brief <em>The \c ListBoxItem class' events interface</em>
	///
	/// This interface defines all events the \c ListBoxItem class may raise.
	///
	/// \sa IListBoxItem
	[
		uuid(01E322AB-6256-408f-98E3-5A1574EB42C2),
		helpstring("IListBoxItem-event-interface")
	]
	dispinterface _IListBoxItemEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ListBoxItem class</em>
	///
	/// This COM class implements the \c IListBoxItem and \c _IListBoxItemEvents interfaces.
	///
	/// \sa IListBoxItem, _IListBoxItemEvents, ListBox, ListBoxItems
	[
		uuid(BA46D1E6-F8CA-4958-8612-C0998D552479),
		version(1.5),
		noncreatable,
		helpstring("ListBoxItem Class 1.5 (Unicode)")
	]
	coclass ListBoxItem
	{
		[default] interface IListBoxItem;
		[default, source] dispinterface _IListBoxItemEvents;
	};


	/// \interface IListBoxItems
	/// \brief <em>Manages a collection of \c ListBoxItem objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c ListBoxItem
	/// objects. While a \c ListBoxItemContainer object is used to group any items and acts more like
	/// a clipboard, a \c ListBoxItems object is used to group items that have certain properties in
	/// common.
	///
	/// \sa _IListBoxItemsEvents, IListBoxItem, IListBoxItemContainer, IListBox
	[
		object,
		uuid(BCBDB00D-54FA-4599-A201-053377E2C8CD),
		dual,
		nonextensible,
		helpstring("IListBoxItems interface"),
		pointer_default(unique)
	]
	interface IListBoxItems : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on an item,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_LBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LBIS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on an item, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets an item filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal itemProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Some of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_LBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_LBIS_COMPARISONFUNCTION), helpstring("Retrieves or sets an item filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets an item filter.\n
		/// An \c IListBoxItems collection can be filtered by any of \c IListBoxItem's properties, that
		/// the \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple
		/// filters are possible, too. A filter is a \c Variant containing an array whose elements are of
		/// type \c Variant. Each element of this array contains a valid value for the property, that the
		/// filter refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Some of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_LBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_LBIS_FILTER), helpstring("Retrieves or sets an item filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets an item filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Some of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_LBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_LBIS_FILTERTYPE), helpstring("Retrieves or sets an item filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c ListBoxItem object from the collection</em>
		///
		/// Retrieves a \c ListBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to be retrieved.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IListBoxItems interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_LBIS_ITEM), helpstring("Retrieves a 'ListBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IListBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ListBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_LBIS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds an item to the list box</em>
		///
		/// Adds an item with the specified properties at the specified position in the control and returns
		/// a \c ListBoxItem object wrapping the inserted item.
		///
		/// \param[in] itemText The new item's caption text.
		/// \param[in] insertAt The new item's zero-based index. If set to -1, the item will be inserted
		///            as the last item.
		/// \param[in] itemData A \c Long value that will be associated with the item.
		///
		/// \return The inserted item.
		///
		/// \remarks If the \c HasStrings property is set to \c False and the \c OwnerDrawItems property is set
		///          to a value other than \c odiDontOwnerDraw, the parameter \c itemText is ignored.
		///
		/// \sa Count, Remove, RemoveAll, IListBoxItem::Text, IListBoxItem::ItemData, IListBox::HasStrings,
		///     IListBox::OwnerDrawItems, IListBox::PrepareForItemInsertions
		[id(DISPID_LBIS_ADD), helpstring("Adds a new item with the specified properties.")]
		HRESULT Add([in] BSTR itemText, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(0)] LONG ItemData, [out, retval] IListBoxItem** ppAddedItem);
		/// \brief <em>Retrieves whether the specified item is part of the item collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the item to be checked.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified item is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, ItemIdentifierTypeConstants
		[id(DISPID_LBIS_CONTAINS), helpstring("Retrieves whether the specified item is part of the item collection.")]
		HRESULT Contains([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c ListBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_LBIS_COUNT), helpstring("Retrieves the number of 'ListBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified item in the collection from the list box</em>
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to be removed.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. Any of the
		///            values defined by the \c ItemIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, ItemIdentifierTypeConstants
		[id(DISPID_LBIS_REMOVE), helpstring("Removes the specified item in the collection from the control.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitIndex)] ItemIdentifierTypeConstants itemIdentifierType);
		/// \brief <em>Removes all items in the collection from the list box</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_LBIS_REMOVEALL), helpstring("Removes all items in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IListBoxItemsEvents
	/// \brief <em>The \c ListBoxItems class' events interface</em>
	///
	/// This interface defines all events the \c ListBoxItems class may raise.
	///
	/// \sa IListBoxItems
	[
		uuid(E0C2393B-9B15-47fa-A5BE-21A5B432A670),
		helpstring("IListBoxItems-event-interface")
	]
	dispinterface _IListBoxItemsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ListBoxItems class</em>
	///
	/// This COM class implements the \c IListBoxItems and \c _IListBoxItemsEvents interfaces.
	///
	/// \sa IListBoxItems, _IListBoxItemsEvents, ListBox, ListBoxItem
	[
		uuid(F397D2BA-CE28-4844-B2B5-0F3149559CFF),
		version(1.5),
		noncreatable,
		helpstring("ListBoxItems Class 1.5 (Unicode)")
	]
	coclass ListBoxItems
	{
		[default] interface IListBoxItems;
		[default, source] dispinterface _IListBoxItemsEvents;
	};


	/// \interface IListBoxItemContainer
	/// \brief <em>Manages a collection of \c ListBoxItem objects</em>
	///
	/// This interface provides easy access to collections of \c ListBoxItem objects. While a
	/// \c ListBoxItems object is used to group items that have certain properties in common, a
	/// \c ListBoxItemContainer object is used to group any items and acts more like a clipboard.
	///
	/// \sa _IListBoxItemContainerEvents, IListBoxItem, IListBoxItems, IListBox
	[
		object,
		uuid(F62EED31-2F64-42f1-B0D3-FD08D4FC6533),
		dual,
		nonextensible,
		helpstring("IListBoxItemContainer interface"),
		pointer_default(unique)
	]
	interface IListBoxItemContainer : IDispatch
	{
		/// \brief <em>Retrieves a \c ListBoxItem object from the collection</em>
		///
		/// Retrieves a \c ListBoxItem object from the collection that wraps the item identified by
		/// \c itemIdentifier.
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to retrieve.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID in non-virtual mode and \c iitIndex in virtual mode.
		///
		/// \remarks This is the default property of the \c IListBoxItemContainer interface.\n
		///          This property is read-only.
		///
		/// \sa ItemIdentifierTypeConstants, IListBoxItem::ID, IListBoxItem::Index, IListBox::VirtualMode, Add,
		///     Remove
		[propget, id(DISPID_LBIC_ITEM), helpstring("Retrieves a 'ListBoxItem' object from the collection that wraps the item identified by 'itemIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [out, retval] IListBoxItem** ppItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ListBoxItem objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_LBIC__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds the specified item(s) to the collection</em>
		///
		/// \param[in] items The item(s) to add. May be either an item ID (non-virtual mode only), an item
		///            index (virtual-mode only), a \c ListBoxItem object or a \c ListBoxItems collection.
		///
		/// \sa IListBoxItem::ID, IListBoxItem::Index, IListBox::VirtualMode, Count, Remove, RemoveAll
		[id(DISPID_LBIC_ADD), helpstring("Adds the specified item(s) to the collection.")]
		HRESULT Add([in] VARIANT Items);
		/// \brief <em>Clones the collection object</em>
		///
		/// Retrieves an exact copy of the collection.
		///
		/// \return The cloned object.
		///
		/// \sa IListBox::CreateItemContainer
		[id(DISPID_LBIC_CLONE), helpstring("Creates an exact copy of the collection.")]
		HRESULT Clone([out, retval] IListBoxItemContainer** ppClone);
		/// \brief <em>Counts the items in the collection</em>
		///
		/// Retrieves the number of \c ListBoxItem objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_LBIC_COUNT), helpstring("Retrieves the number of 'ListBoxItem' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Retrieves an image list containing the items' common drag image</em>
		///
		/// Retrieves the handle to an image list containing a bitmap that can be used to visualize
		/// dragging of the items of this collection.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return: The handle to the image list containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the image list.
		[id(DISPID_LBIC_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an image list containing a bitmap that can be used to visualize dragging of the items of this collection.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Removes the specified item from the collection</em>
		///
		/// \param[in] itemIdentifier A value that identifies the list box item to remove.
		/// \param[in] itemIdentifierType A value specifying the meaning of \c itemIdentifier. This must be
		///            \c iitID in non-virtual mode and \c iitIndex in virtual mode.
		/// \param[in] removePhysically If \c True, the item is removed from the control, too.
		///
		/// \sa IListBoxItem::ID, IListBoxItem::Index, IListBox::VirtualMode, Add, Count, RemoveAll,
		///     ItemIdentifierTypeConstants
		[id(DISPID_LBIC_REMOVE), helpstring("Removes the specified item from the collection.")]
		HRESULT Remove([in] LONG itemIdentifier, [in, defaultvalue(iitID)] ItemIdentifierTypeConstants itemIdentifierType, [in, defaultvalue(0)] VARIANT_BOOL removePhysically);
		/// \brief <em>Removes all items from the collection</em>
		///
		/// \param[in] removePhysically If \c True, the items are removed from the control, too.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_LBIC_REMOVEALL), helpstring("Removes all items from the collection.")]
		HRESULT RemoveAll([in, defaultvalue(0)] VARIANT_BOOL removePhysically);
	}


	/// \interface _IListBoxItemContainerEvents
	/// \brief <em>The \c ListBoxItemContainer class' events interface</em>
	///
	/// This interface defines all events the \c ListBoxItemContainer class may raise.
	///
	/// \sa IListBoxItemContainer
	[
		uuid(413645D4-6458-403a-AFA0-9C6F8BD23E42),
		helpstring("IListBoxItemContainer-event-interface")
	]
	dispinterface _IListBoxItemContainerEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ListBoxItemContainer class</em>
	///
	/// This COM class implements the \c IListBoxItemContainer and \c _IListBoxItemContainerEvents
	/// interfaces.
	///
	/// \sa IListBoxItemContainer, _IListBoxItemContainerEvents, ListBox, ListBoxItem
	[
		uuid(369D0DA8-58F6-452c-AEDA-F784FA3A6A24),
		version(1.5),
		noncreatable,
		helpstring("ListBoxItemContainer Class 1.5 (Unicode)")
	]
	coclass ListBoxItemContainer
	{
		[default] interface IListBoxItemContainer;
		[default, source] dispinterface _IListBoxItemContainerEvents;
	};


	/// \interface IListBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the list box control's main interface. It wraps the control window.
	///
	/// \sa _IListBoxEvents
	[
		object,
		uuid(0705B9CB-5DA5-40d8-A962-DF51DF7B2DA2),
		dual,
		nonextensible,
		helpstring("IListBox interface"),
		pointer_default(unique)
	]
	interface IListBox : IDispatch
	{
		/// \brief <em>Specifies whether the control detects drag'n'drop operations</em>
		///
		/// Retrieves or sets whether drag'n'drop mode can be entered. If set to \c True, drag'n'drop mode
		/// can be entered by pressing the left or right mouse button over an item and then moving the
		/// mouse with the button still pressed. If set to \c False, drag'n'drop mode is not available -
		/// this also means the \c ItemBeginDrag and \c ItemBeginRDrag events don't get fired.
		///
		/// \sa RegisterForOLEDragDrop, DragScrollTimeBase, SetInsertMarkPosition,
		///     _IListBoxEvents::ItemBeginDrag, _IListBoxEvents::ItemBeginRDrag
		[propget, id(DISPID_LB_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_ALLOWDRAGDROP), helpstring("Retrieves or sets whether drag'n'drop mode can be entered.")]
		HRESULT AllowDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether items can be selected</em>
		///
		/// Retrieves or sets whether list box items can be selected by the user. If set to \c True, the user
		/// can select items; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa MultiSelect
		[propget, id(DISPID_LB_ALLOWITEMSELECTION), helpstring("Retrieves or sets whether list box items can be selected by the user. Changing this property destroys and recreates the control window.")]
		HRESULT AllowItemSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_ALLOWITEMSELECTION), helpstring("Retrieves or sets whether list box items can be selected by the user. Changing this property destroys and recreates the control window.")]
		HRESULT AllowItemSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the visibility of the vertical scroll bar</em>
		///
		/// Retrieves or sets whether the vertical scroll bar is disabled instead of hidden if the control does
		/// not contain enough items to scroll. If set to \c True, the scroll bar is disabled; otherwise it is
		/// hidden.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ListItems, ScrollableWidth
		[propget, id(DISPID_LB_ALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT AlwaysShowVerticalScrollBar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_ALWAYSSHOWVERTICALSCROLLBAR), helpstring("Retrieves or sets whether the vertical scroll bar is disabled instead of hidden if the control does not contain enough items to scroll. Changing this property destroys and recreates the control window.")]
		HRESULT AlwaysShowVerticalScrollBar([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's selection anchor item</em>
		///
		/// Retrieves or sets the control's anchor item. The anchor item is the item with which
		/// range-selection begins.
		///
		/// \sa IListBoxItem::Anchor, MultiSelect, CaretItem
		[propget, id(DISPID_LB_ANCHORITEM), helpstring("Retrieves or sets the control's anchor item. The anchor item is the item with which range-selection begins."), nonbrowsable]
		HRESULT AnchorItem([out, retval] IListBoxItem** ppAnchorItem);
		[propputref, id(DISPID_LB_ANCHORITEM), helpstring("Retrieves or sets the control's anchor item. The anchor item is the item with which range-selection begins."), nonbrowsable]
		HRESULT AnchorItem([in] IListBoxItem* pNewAnchorItem);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_LB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_LB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa ForeColor, InsertMarkColor
		[propget, id(DISPID_LB_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_LB_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_LB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_LB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Specifies the control's caret item</em>
		///
		/// Retrieves or sets the control's caret item. The caret item is the item that has the focus.
		///
		/// \param[in] partialVisibilityIsOkay If set to \c True, the control is scrolled until the caret item
		///            is at least partially visible. If set to \c False, the control is scrolled until the
		///            entire caret item is visible.
		///
		/// \remarks In single-selection mode the caret item can be set only if the \c SelectedItem property is
		///          set to \c Nothing.
		///
		/// \sa IListBoxItem::Caret, MultiSelect, SelectedItem, AnchorItem
		[propget, id(DISPID_LB_CARETITEM), helpstring("Retrieves or sets the control's caret item. The caret item is the item that has the focus."), nonbrowsable]
		HRESULT CaretItem([in, defaultvalue(0)] VARIANT_BOOL partialVisibilityIsOkay, [out, retval] IListBoxItem** ppCaretItem);
		[propputref, id(DISPID_LB_CARETITEM), helpstring("Retrieves or sets the control's caret item. The caret item is the item that has the focus."), nonbrowsable]
		HRESULT CaretItem([in, defaultvalue(0)] VARIANT_BOOL partialVisibilityIsOkay, [in] IListBoxItem* pNewCaretItem);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the width of a column in a multi-column list box</em>
		///
		/// Retrieves or sets the width of a column in a multi-column list box. If set to -1, the system's
		/// default setting is used.
		///
		/// \sa MultiColumn
		[propget, id(DISPID_LB_COLUMNWIDTH), helpstring("Retrieves or sets the width of a column in a multi-column list box.")]
		HRESULT ColumnWidth([out, retval] LONG* pValue);
		[propput, id(DISPID_LB_COLUMNWIDTH), helpstring("Retrieves or sets the width of a column in a multi-column list box.")]
		HRESULT ColumnWidth([in] LONG newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_LB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_LB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_LB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the items currently dragged</em>
		///
		/// Retrieves a collection object wrapping the items that are currently dragged. These are the
		/// same items that were passed to the \c BeginDrag or \c OLEDrag method.
		///
		/// \remarks This property is read-only.
		///
		/// \sa BeginDrag, OLEDrag, IListBoxItemContainer, ListItems
		[propget, id(DISPID_LB_DRAGGEDITEMS), helpstring("Retrieves a collection object wrapping the items that are currently dragged."), nonbrowsable]
		HRESULT DraggedItems([out, retval] IListBoxItemContainer** ppItems);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa AllowDragDrop, RegisterForOLEDragDrop, _IListBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_LB_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_LB_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([in] LONG newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_LB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the first item that is displayed in the control's client area</em>
		///
		/// Retrieves or sets the first list box item, that is entirely located within the control's client
		/// area and therefore visible to the user.
		///
		/// \sa ListItems
		[propget, id(DISPID_LB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first list box item, that is entirely located within the control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([out, retval] IListBoxItem** ppFirstItem);
		[propputref, id(DISPID_LB_FIRSTVISIBLEITEM), helpstring("Retrieves or sets the first list box item, that is entirely located within the control's client area and therefore visible to the user."), nonbrowsable]
		HRESULT FirstVisibleItem([in] IListBoxItem* pNewFirstItem);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa UseSystemFont, ForeColor
		[propget, id(DISPID_LB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_LB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_LB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color.
		///
		/// \sa BackColor, InsertMarkColor
		[propget, id(DISPID_LB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_LB_FORECOLOR), helpstring("Retrieves or sets the control's text color.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies whether the control's items are strings</em>
		///
		/// Retrieves or sets whether the items in the control are strings. If set to \c True, the control
		/// contains strings; otherwise the items consist of the value specified by the \c ItemData property
		/// only.
		///
		/// \remarks This property is ignored if the \c OwnerDrawItems property is set to \c odiDontOwnerDraw.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa OwnerDrawItems, IListBoxItem::ItemData, IListBoxItem::Text
		[propget, id(DISPID_LB_HASSTRINGS), helpstring("Retrieves or sets whether the items in the control are strings. This property is ignored if the 'OwnerDrawItems' property is set to 'odiDontOwnerDraw'. Changing this property destroys and recreates the control window.")]
		HRESULT HasStrings([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_HASSTRINGS), helpstring("Retrieves or sets whether the items in the control are strings. This property is ignored if the 'OwnerDrawItems' property is set to 'odiDontOwnerDraw'. Changing this property destroys and recreates the control window.")]
		HRESULT HasStrings([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the image list containing the drag image</em>
		///
		/// Retrieves the handle to the image list containing the drag image that is used during a
		/// drag'n'drop operation to visualize the dragged items.
		///
		/// \sa ShowDragImage, BeginDrag, _IListBoxEvents::DragMouseMove
		[propget, id(DISPID_LB_HDRAGIMAGELIST), helpstring("Retrieves the handle to the image list containing the drag image that is used during a drag'n'drop operation to visualize the dragged items."), nonbrowsable]
		HRESULT hDragImageList([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies one of the control's associated image list</em>
		///
		/// Retrieves or sets the handle of the specified image list.
		///
		/// \param[in] image list The image list to retrieve or set. Only the \c ilHighResolution value defined
		///            by the \c ImageListConstants enumeration is valid.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa ImageListConstants
		[propget, id(DISPID_LB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_LB_HIMAGELIST), helpstring("Retrieves or sets the handle to the specified image list."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IListBoxEvents::MouseHover
		[propget, id(DISPID_LB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_LB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IListBoxEvents::RecreatedControlWindow, _IListBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_LB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the tooltip control's window handle</em>
		///
		/// Retrieves or sets the tooltip control's window handle.
		///
		/// \remarks The previously set tooltip window does NOT get destroyed automatically.
		///
		/// \sa ToolTips
		[propget, id(DISPID_LB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_LB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([in] OLE_HANDLE newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME is a Windows feature making it easy to enter
		/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
		///
		/// \sa IMEModeConstants
		[propget, id(DISPID_LB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_LB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \remarks This property is ignored if the \c InsertMarkStyle property is set to \c imsNative.
		///
		/// \sa InsertMarkStyle, SetInsertMarkPosition, BackColor, ForeColor
		[propget, id(DISPID_LB_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in. This property is ignored if the 'InsertMarkStyle' property is set to 'imsNative'.")]
		HRESULT InsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_LB_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in. This property is ignored if the 'InsertMarkStyle' property is set to 'imsNative'.")]
		HRESULT InsertMarkColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the appearance of the control's insertion mark</em>
		///
		/// Retrieves or sets the style of the control's insertion mark. Any of the values defined by the
		/// \c InsertMarkStyleConstants enumeration is valid.
		///
		/// \sa InsertMarkColor, SetInsertMarkPosition, InsertMarkStyleConstants
		[propget, id(DISPID_LB_INSERTMARKSTYLE), helpstring("Retrieves or sets the style of the control's insertion mark.")]
		HRESULT InsertMarkStyle([out, retval] InsertMarkStyleConstants* pValue);
		[propput, id(DISPID_LB_INSERTMARKSTYLE), helpstring("Retrieves or sets the style of the control's insertion mark.")]
		HRESULT InsertMarkStyle([in] InsertMarkStyleConstants newValue);
		/// \brief <em>Specifies whether the control displays partial items</em>
		///
		/// Retrieves or sets whether the control resizes itself so that an integral number of items is
		/// displayed. If set to \c True, an integral number of items is displayed and the control's height
		/// may be changed to achieve this; otherwise partial items may be displayed.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ItemHeight
		[propget, id(DISPID_LB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		HRESULT IntegralHeight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_INTEGRALHEIGHT), helpstring("Retrieves or sets whether the control resizes itself so that an integral number of items is displayed. Changing this property destroys and recreates the control window.")]
		HRESULT IntegralHeight([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_LB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies all items' height</em>
		///
		/// Retrieves or sets the items' height in pixels. If set to -1, the default setting is used.
		///
		/// \remarks If the \c OwnerDrawItems property is set to \c odiOwnerDrawVariableHeight, this property
		///          is ignored. Use the \c IListBoxItem::Height property instead.
		///
		/// \sa OwnerDrawItems, IntegralHeight, IListBoxItem::Height
		[propget, id(DISPID_LB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels. If the 'OwnerDrawItems' property is set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ListBoxItem.Height' property instead.")]
		HRESULT ItemHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_LB_ITEMHEIGHT), helpstring("Retrieves or sets the items' height in pixels. If the 'OwnerDrawItems' property is set to 'odiOwnerDrawVariableHeight', this property is ignored. Use the 'ListBoxItem.Height' property instead.")]
		HRESULT ItemHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the number of items per column</em>
		///
		/// Retrieves the number of items displayed in a column.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MultiColumn
		[propget, id(DISPID_LB_ITEMSPERCOLUMN), helpstring("Retrieves the number of items displayed in a column."), nonbrowsable]
		HRESULT ItemsPerColumn([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the control's items</em>
		///
		/// Retrieves a collection object wrapping the list box items.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IListBoxItems
		[propget, id(DISPID_LB_LISTITEMS), helpstring("Retrieves a collection object wrapping the control's items."), nonbrowsable]
		HRESULT ListItems([out, retval] IListBoxItems** ppItems);
		/// \brief <em>Specifies the control's current locale</em>
		///
		/// Retrieves or sets the control's current locale. The locale influences how items are sorted if the
		/// \c Sorted property is set to \c True. For a list of possible locale identifiers see
		/// <a href="https://msdn.microsoft.com/en-us/library/dd318693.aspx">MSDN Online</a>.
		///
		/// \sa Sorted
		[propget, id(DISPID_LB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		HRESULT Locale([out, retval] LONG* pValue);
		[propput, id(DISPID_LB_LOCALE), helpstring("Retrieves or sets the control's current locale. The locale influences how items are sorted if the 'Sorted' property is set to 'True'. See help file for details.")]
		HRESULT Locale([in] LONG newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_LB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_LB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_LB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_LB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_LB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether items are displayed in multiple columns</em>
		///
		/// Retrieves or sets whether the control is scrolled horizontally and the items are displayed in
		/// multiple columns. If set to \c True, the items are displayed in multiple columns; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ColumnWidth, ItemsPerColumn
		[propget, id(DISPID_LB_MULTICOLUMN), helpstring("Retrieves or sets whether the control is scrolled horizontally and the items are displayed in multiple columns. Changing this property destroys and recreates the control window.")]
		HRESULT MultiColumn([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_MULTICOLUMN), helpstring("Retrieves or sets whether the control is scrolled horizontally and the items are displayed in multiple columns. Changing this property destroys and recreates the control window.")]
		HRESULT MultiColumn([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether multiple items can be selected</em>
		///
		/// Retrieves or sets whether multiple items can be selected at the same time and how an item's
		/// selection state can be changed by the user. Any of the values defined by the
		/// \c MultiSelectConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa AllowItemSelection, MultiSelectConstants
		[propget, id(DISPID_LB_MULTISELECT), helpstring("Retrieves or sets whether multiple items can be selected at the same time and how an item's selection state can be changed by the user. Changing this property destroys and recreates the control window.")]
		HRESULT MultiSelect([out, retval] MultiSelectConstants* pValue);
		[propput, id(DISPID_LB_MULTISELECT), helpstring("Retrieves or sets whether multiple items can be selected at the same time and how an item's selection state can be changed by the user. Changing this property destroys and recreates the control window.")]
		HRESULT MultiSelect([in] MultiSelectConstants newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_LB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_LB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies whether the items are drawn by the application instead of the control</em>
		///
		/// Retrieves or sets whether your application draws the items itself. Any of the values defined by the
		/// \c OwnerDrawItemsConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa HasStrings, OwnerDrawItemsConstants
		[propget, id(DISPID_LB_OWNERDRAWITEMS), helpstring("Retrieves or sets whether your application draws the items itself. Changing this property destroys and recreates the control window.")]
		HRESULT OwnerDrawItems([out, retval] OwnerDrawItemsConstants* pValue);
		[propput, id(DISPID_LB_OWNERDRAWITEMS), helpstring("Retrieves or sets whether your application draws the items itself. Changing this property destroys and recreates the control window.")]
		HRESULT OwnerDrawItems([in] OwnerDrawItemsConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IListBoxEvents::ContextMenu
		[propget, id(DISPID_LB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether tab characters in the item texts are expanded or ignored</em>
		///
		/// Retrieves or sets whether tab characters in the item texts are expanded or ignored. If set to
		/// \c True, tab characters are expanded resulting in multi-column texts; otherwise tab characters are
		/// ignored.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa TabStops, TabWidth, IListBoxItem::Text
		[propget, id(DISPID_LB_PROCESSTABS), helpstring("Retrieves or sets whether tab characters in the item texts are expanded or ignored. Changing this property destroys and recreates the control window.")]
		HRESULT ProcessTabs([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_PROCESSTABS), helpstring("Retrieves or sets whether tab characters in the item texts are expanded or ignored. Changing this property destroys and recreates the control window.")]
		HRESULT ProcessTabs([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_LB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. If set to
		/// \c True, the control accepts OLE drag'n'drop actions; otherwise not.
		///
		/// \sa SupportOLEDragImages, _IListBoxEvents::OLEDragEnter
		[propget, id(DISPID_LB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_LB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_LB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the width by which the list box can be scrolled horizontally</em>
		///
		/// Retrieves or sets the width in pixels, by which the list box can be scrolled horizontally. If the
		/// width of the control is greater than this value, a horizontal scroll bar is displayed.
		///
		/// \sa AlwaysShowVerticalScrollBar
		[propget, id(DISPID_LB_SCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the list box can be scrolled horizontally.")]
		HRESULT ScrollableWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_LB_SCROLLABLEWIDTH), helpstring("Retrieves or sets the width in pixels, by which the list box can be scrolled horizontally.")]
		HRESULT ScrollableWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the control's selected item</em>
		///
		/// Retrieves or sets the control's currently selected item.
		///
		/// \remarks This is the control's default property.\n
		///          This property is for single-selection mode only.
		///
		/// \sa SelectedItemsArray, IListBoxItem::Selected, MultiSelect, CaretItem, SelectItemByText
		[propget, id(DISPID_LB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([out, retval] IListBoxItem** ppSelectedItem);
		[propputref, id(DISPID_LB_SELECTEDITEM), helpstring("Retrieves or sets the control's currently selected item."), nonbrowsable]
		HRESULT SelectedItem([in] IListBoxItem* pNewSelectedItem);
		/// \brief <em>Specifies the selected items</em>
		///
		/// Retrieves or sets the selected items. The sub-type of this property is an array of \c Longs.
		/// Each element of this array contains the index of a selected item.
		///
		/// \sa SelectedItem, IListBoxItem::Selected, MultiSelect
		[propget, id(DISPID_LB_SELECTEDITEMSARRAY), helpstring("Retrieves or sets the selected items."), nonbrowsable]
		HRESULT SelectedItemsArray([out, retval] VARIANT* pValue);
		[propput, id(DISPID_LB_SELECTEDITEMSARRAY), helpstring("Retrieves or sets the selected items."), nonbrowsable]
		HRESULT SelectedItemsArray([in] VARIANT newValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa hDragImageList, SupportOLEDragImages, _IListBoxEvents::DragMouseMove
		[propget, id(DISPID_LB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the items are sorted alphabetically</em>
		///
		/// Retrieves or sets whether the items in the control are sorted alphabetically. If set to \c True,
		/// the control sorts the items alphabetically; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ListItems, Locale, _IComboBoxEvents::CompareItems
		[propget, id(DISPID_LB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_SORTED), helpstring("Retrieves or sets whether the items in the control are sorted alphabetically. Changing this property destroys and recreates the control window.")]
		HRESULT Sorted([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, hImageList, OLEDragImageStyle, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_LB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's tab stops</em>
		///
		/// Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a
		/// \c Variant containing an array of integer values, each specifying a tab stop's position.
		///
		/// \remarks This property is ignored, if the \c ProcessTabs property is set to \c False.
		///
		/// \sa ProcessTabs, TabWidth
		[propget, id(DISPID_LB_TABSTOPS), helpstring("Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a 'Variant' containing an array of integer values, each specifying a tab stop's position. This property is ignored, if the 'ProcessTabs' property is set to 'False'."), nonbrowsable]
		HRESULT TabStops([out, retval] VARIANT* pValue);
		[propput, id(DISPID_LB_TABSTOPS), helpstring("Retrieves or sets the positions (in pixels) of the control's tab stops. The property expects a 'Variant' containing an array of integer values, each specifying a tab stop's position. This property is ignored, if the 'ProcessTabs' property is set to 'False'."), nonbrowsable]
		HRESULT TabStops([in] VARIANT newValue);
		/// \brief <em>Specifies the width of a tab</em>
		///
		/// Retrieves or sets the distance (in pixels) between 2 tab stops. If set to -1, the system's default
		/// value is used.
		///
		/// \remarks This property is ignored, if the \c ProcessTabs property is set to \c False.\n
		///          This property is ignored, if the \c TabStops property is not set to \c Empty.
		///
		/// \sa ProcessTabs, TabStops
		[propget, id(DISPID_LB_TABWIDTH), helpstring("Retrieves or sets the distance (in pixels) between 2 tab stops. This property is ignored, if the 'ProcessTabs' property is set to 'False' or the 'TabStops' property is set to 'Empty'.")]
		HRESULT TabWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_LB_TABWIDTH), helpstring("Retrieves or sets the distance (in pixels) between 2 tab stops. This property is ignored, if the 'ProcessTabs' property is set to 'False' or the 'TabStops' property is set to 'Empty'.")]
		HRESULT TabWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_LB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies which kinds of tooltips are displayed</em>
		///
		/// Retrieves or sets which kinds of tooltips the control is displaying. Any combination of the values
		/// defined by the \c ToolTipsConstants enumeration is valid.
		///
		/// \sa hWndToolTip, _IListBoxEvents::ItemGetInfoTipText, ToolTipsConstants
		[propget, id(DISPID_LB_TOOLTIPS), helpstring("Retrieves or sets the kinds of tooltips the control is displaying.")]
		HRESULT ToolTips([out, retval] ToolTipsConstants* pValue);
		[propput, id(DISPID_LB_TOOLTIPS), helpstring("Retrieves or sets the kinds of tooltips the control is displaying.")]
		HRESULT ToolTips([in] ToolTipsConstants newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \sa Font
		[propget, id(DISPID_LB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_LB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the number of items in virtual mode</em>
		///
		/// Retrieves or sets the number of items in the control if the \c VirtualMode property is set to
		/// \c True.
		///
		/// \sa VirtualMode
		[propget, id(DISPID_LB_VIRTUALITEMCOUNT), helpstring("Retrieves or sets the number of items in the control if the 'VirtualMode' property is set to 'True'.")]
		HRESULT VirtualItemCount([out, retval] LONG* pValue);
		[propput, id(DISPID_LB_VIRTUALITEMCOUNT), helpstring("Retrieves or sets the number of items in the control if the 'VirtualMode' property is set to 'True'.")]
		HRESULT VirtualItemCount([in] LONG newValue);
		/// \brief <em>Specifies whether data-management is done by the application instead of the control</em>
		///
		/// Retrieves or sets whether the data-management for the control is done by your application or
		/// by the control itself. If set to \c True, data-management is done by your application; otherwise
		/// it's done by the control.
		///
		/// \remarks Using your own data-management system may increase performance, especially if the
		///          list box contains many items. However, virtual list box controls have several
		///          limitations (list may be incomplete):\n
		///          - The \c HasStrings property is not supported.
		///          - The \c Sorted property is not supported.
		///          - The \c OwnerDrawItems property must be set to \c odiOwnerDrawFixedHeight.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa VirtualItemCount, HasStrings, Sorted, OwnerDrawItems
		[propget, id(DISPID_LB_VIRTUALMODE), helpstring("Retrieves or sets whether the data-management for the control is done by your application or by the control itself. Changing this property destroys and recreates the control window.")]
		HRESULT VirtualMode([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_LB_VIRTUALMODE), helpstring("Retrieves or sets whether the data-management for the control is done by your application or by the control itself. Changing this property destroys and recreates the control window.")]
		HRESULT VirtualMode([in] VARIANT_BOOL newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_LB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Enters drag'n'drop mode</em>
		///
		/// \param[in] draggedItems A collection object containing the items to drag.
		/// \param[in] hDragImageList The image list containing the drag image that shall be used to
		///            visualize the drag'n'drop operation. If -1, the control creates the drag image
		///            itself; if \c 0, no drag image is used.
		/// \param[in,out] xHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		/// \param[in,out] yHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
		///                0, this parameter is ignored. This parameter will be changed to the value that
		///                finally was used by the method.
		///
		/// \sa OLEDrag, DraggedItems, EndDrag, hDragImageList, _IListBoxEvents::ItemBeginDrag,
		///     _IListBoxEvents::ItemBeginRDrag, IListBoxItem::CreateDragImage,
		///     IListBoxItemContainer::CreateDragImage
		[id(DISPID_LB_BEGINDRAG), helpstring("Enters drag'n'drop mode.")]
		HRESULT BeginDrag([in] IListBoxItemContainer* DraggedItems, [in, defaultvalue(0)] OLE_HANDLE hDragImageList, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xHotSpot, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yHotSpot);
		/// \brief <em>Creates a new \c ListBoxItemContainer object</em>
		///
		/// Retrieves a new \c ListBoxItemContainer object and fills it with the specified items.
		///
		/// \param[in] items The item(s) to add to the collection. May be either \c Empty, an item ID, a
		///            \c ListBoxItem object or a \c ListBoxItems collection.
		///
		/// \return The created \c ListBoxItemContainer object.
		///
		/// \sa IListBoxItemContainer::Clone, IListBoxItemContainer::Add
		[id(DISPID_LB_CREATEITEMCONTAINER), helpstring("Retrieves a new 'ListBoxItemContainer' object and fills it with 'items'.")]
		HRESULT CreateItemContainer([in, optional] VARIANT items, [out, retval] IListBoxItemContainer** ppContainer);
		/// \brief <em>Deselects a range of items</em>
		///
		/// Deselects the specified range of items.
		///
		/// \param[in] firstItem The first item to deselect. If set to \c Empty, the control's first item is
		///            used.
		/// \param[in] lastItem The last item to deselect. If set to \c Empty, the control's first item is
		///            used.
		///
		/// \sa SelectItems, MultiSelect, IListBoxItem::Selected
		[id(DISPID_LB_DESELECTITEMS), helpstring("Deselects the specified range of items.")]
		HRESULT DeselectItems([in, optional] VARIANT firstItem, [in, optional] VARIANT lastItem);
		/// \brief <em>Exits drag'n'drop mode</em>
		///
		/// \param[in] abort If \c True, the drag'n'drop operation will be handled as aborted; otherwise
		///            it will be handled as a drop.
		///
		/// \sa DraggedItems, BeginDrag, _IListBoxEvents::AbortedDrag, _IListBoxEvents::Drop
		[id(DISPID_LB_ENDDRAG), helpstring("Exits drag'n'drop mode.")]
		HRESULT EndDrag([in] VARIANT_BOOL abort);
		/// \brief <em>Finds an item by its \c ItemData property</em>
		///
		/// Searches the list box control for the first item that has the \c ItemData property set to the
		/// specified value.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa FindItemByText, SelectItemByItemData, IListBoxItem::ItemData
		[id(DISPID_LB_FINDITEMBYITEMDATA), helpstring("Searches the list box control for the first item that has the 'ItemData' property set to the specified value.")]
		HRESULT FindItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IListBoxItem** ppFoundItem);
		/// \brief <em>Finds an item by its text</em>
		///
		/// Searches the list box control for the first item that starts with the specified text.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \remarks The search is not case sensitive.
		///
		/// \sa FindItemByItemData, SelectItemByText, IListBoxItem::Text
		[id(DISPID_LB_FINDITEMBYTEXT), helpstring("Searches the list box control for the first item that starts with the specified text. The search is not case sensitive.")]
		HRESULT FindItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IListBoxItem** ppFoundItem);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] listItem The item at which the insertion mark should be displayed.
		///
		/// \sa SetInsertMarkPosition, GetInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_LB_GETCLOSESTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] IListBoxItem** listItem);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified item. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] listItem The item at which the insertion mark is displayed.
		///
		/// \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, GetInsertMarkRectangle,
		///     InsertMarkPositionConstants
		[id(DISPID_LB_GETINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] IListBoxItem** listItem);
		/// \brief <em>Retrieves the bounding rectangle of the control's insertion mark</em>
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \remarks This method fails if the \c InsertMarkStyle property is set to \c imsNative.
		///
		/// \sa InsertMarkStyle, GetInsertMarkPosition, SetInsertMarkPosition
		[id(DISPID_LB_GETINSERTMARKRECTANGLE), helpstring("Retrieves the bounding rectangle of the control's insertion mark. This method fails if the 'InsertMarkStyle' property is set to 'imsNative'.")]
		HRESULT GetInsertMarkRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[out] hitTestDetails Receives a value specifying the exact part of the control the specified
		///             point lies in. Some of the values defined by the \c HitTestConstants enumeration are
		///             valid.
		///
		/// \return The item that the specified point belongs to. \c Nothing, if no item was "hit".
		///
		/// \sa HitTestConstants
		[id(DISPID_LB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IListBoxItem** ppHitItem);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_LB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedItems A collection object containing the items to drag. This parameter is
		///            used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of items
		///            contained in the \c draggedItems collection is displayed in the item count label. If
		///            set to any value larger than 1, this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa BeginDrag, _IListBoxEvents::ItemBeginDrag, _IListBoxEvents::ItemBeginRDrag,
		///     _IListBoxEvents::OLEStartDrag, _IListBoxEvents::OLEGiveFeedback,
		///     _IListBoxEvents::OLEQueryContinueDrag, SupportOLEDragImages, OLEDragImageStyle,
		///     OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_LB_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] IListBoxItemContainer* DraggedItems, [in, defaultvalue(-1)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Prepares the control for insertion of many items</em>
		///
		/// Prepares the control for the insertion of many items by reserving memory in advance. It is not
		/// necessary to call this method, but doing so can improve performance when inserting many (> 100)
		/// items at once.
		///
		/// \param[in] numberOfItems The number of items for which to reserve memory in advance.
		/// \param[in] averageStringWidth The average length of the item texts.
		///
		/// \return The number of items for which memory has been allocated.
		///
		/// \sa IListBoxItems::Add
		[id(DISPID_LB_PREPAREFORITEMINSERTIONS), helpstring("Prepares the control for the insertion of many (> 100) items by reserving memory in advance.")]
		HRESULT PrepareForItemInsertions([in] LONG numberOfItems, [in] LONG averageStringWidth, [out, retval] LONG* pAllocatedItems);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_LB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_LB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Finds and selects an item by its \c ItemData property</em>
		///
		/// Searches the list box control for the first item that has the \c ItemData property set to the
		/// specified value. If a matching item is found, it is made the selected item as specified by the
		/// \c SelectedItem property.
		///
		/// \param[in] itemData The \c ItemData value for which to search.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \sa SelectItemByText, FindItemByItemData, IListBoxItem::ItemData, SelectedItem
		[id(DISPID_LB_SELECTITEMBYITEMDATA), helpstring("Searches the list box control for the first item that has the 'ItemData' property set to the specified value. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property.")]
		HRESULT SelectItemByItemData([in] LONG ItemData, [in, optional] VARIANT startAfterItem, [out, retval] IListBoxItem** ppFoundItem);
		/// \brief <em>Finds and selects an item by its text</em>
		///
		/// Searches the list box control for the first item that starts with the specified text. If a matching
		/// item is found, it is made the selected item as specified by the \c SelectedItem property.
		///
		/// \param[in] searchString The string for which to search.
		/// \param[in] exactMatch If \c True, only exact matches are returned; otherwise any item that starts
		///            with the specified string may be returned.
		/// \param[in] startAfterItem The item after which the search shall be started. If the bottom of the
		///            control is reached, the search is continued from the top of the control back to the item
		///            specified by \c startAfterItem. If set to \c Empty, the control is searched from top
		///            to bottom.
		///
		/// \return The found item or \c Nothing if no matching item was found.
		///
		/// \remarks The search is not case sensitive.
		///
		/// \sa SelectItemByItemData, FindItemByText, IListBoxItem::Text, SelectedItem
		[id(DISPID_LB_SELECTITEMBYTEXT), helpstring("Searches the list box control for the first item that starts with the specified text. If a matching item is found, it is made the selected item as specified by the 'SelectedItem' property. The search is not case sensitive.")]
		HRESULT SelectItemByText([in] BSTR searchString, [in, defaultvalue(-1)] VARIANT_BOOL exactMatch, [in, optional] VARIANT startAfterItem, [out, retval] IListBoxItem** ppFoundItem);
		/// \brief <em>Selects a range of items</em>
		///
		/// Selects the specified range of items.
		///
		/// \param[in] firstItem The first item to select. If set to \c Empty, the control's first item is
		///            used.
		/// \param[in] lastItem The last item to select. If set to \c Empty, the control's first item is
		///            used.
		///
		/// \sa DeselectItems, MultiSelect, IListBoxItem::Selected
		[id(DISPID_LB_SELECTITEMS), helpstring("Selects the specified range of items.")]
		HRESULT SelectItems([in, optional] VARIANT firstItem, [in, optional] VARIANT lastItem);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified item. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] listItem The item at which to show the insertion mark. If set to \c Nothing, the
		///            insertion mark will be removed.
		///
		/// \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkColor, InsertMarkStyle,
		///     RegisterForOLEDragDrop, InsertMarkPositionConstants
		[id(DISPID_LB_SETINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] IListBoxItem* listItem);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IListBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_LB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IListBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ListBox class' events interface</em>
	///
	/// This interface defines all events the \c ListBox class may raise.
	///
	/// \sa IListBox
	[
		uuid(731DA6B7-E4AE-472a-AB65-603C199B4251),
		helpstring("IListBox-event-interface")
	]
	dispinterface _IListBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The caret was changed</em>
			///
			/// Will be fired after another item became the caret item. The caret item is the item that has
			/// the focus.
			///
			/// \param[in] previousCaretItem The previous caret item.
			/// \param[in] newCaretItem The new caret item.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa SelectionChanged, IListBoxItem::Caret, IListBox::CaretItem
			[id(DISPID_LBE_CARETCHANGED), helpstring("Will be fired after another item became the caret item. The caret item is the item that has the focus.")]
			void CaretChanged(IListBoxItem* previousCaretItem, IListBoxItem* newCaretItem);
			/// \brief <em>A drag'n'drop operation was aborted</em>
			///
			/// Will be fired if a drag'n'drop operation was aborted.
			///
			/// \sa Drop, IListBox::EndDrag
			[id(DISPID_LBE_ABORTEDDRAG), helpstring("Will be fired if a drag'n'drop operation was aborted.")]
			void AbortedDrag(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] listItem The item that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>Two items must be compared</em>
			///
			/// Will be fired during sorting of an owner-drawn list box if two items must be compared.
			///
			/// \param[in] firstItem The first item to compare.
			/// \param[in] secondItem The second item to compare.
			/// \param[in] locale The identifier of the locale to use for comparison.
			/// \param[in,out] result The comparison's result. Any of the values defined by the
			///                \c CompareResultConstants enumeration is valid.
			///
			/// \remarks The items' indexes may be -1. For instance, this will happen if one of the items is
			///          currently being inserted. In this case all properties of \c IListBoxItem except
			///          \c Index and \c ItemData will fail and the \c ItemData property is read-only.
			///
			/// \sa IListBox::OwnerDrawItems, IListBox::Sorted, IListBox::Locale, CompareResultConstants,
			///     IListBoxItem::Index, IListBoxItem::ItemData
			[id(DISPID_LBE_COMPAREITEMS), helpstring("Will be fired during sorting of an owner-drawn list box if two items must be compared.")]
			void CompareItems(IListBoxItem* firstItem, IListBoxItem* secondItem, LONG Locale, CompareResultConstants* result);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] listItem The item the context menu refers to. Will be \c Nothing if the context
			///            menu should be displayed for the whole control instead of only for a single item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the menu's proposed position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_LBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] listItem The item that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IListBox::hWnd
			[id(DISPID_LBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area during a
			/// drag'n'drop operation.
			///
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa MouseMove, OLEDragMouseMove, IListBox::DragScrollTimeBase, IListBoxItem::GetRectangle,
			///     IListBox::SetInsertMarkPosition, IListBox::BeginDrag, HitTestConstants
			[id(DISPID_LBE_DRAGMOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area during a drag'n'drop operation.")]
			void DragMouseMove(IListBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>A drag'n'drop operation ended successful</em>
			///
			/// Will be fired if a drag'n'drop operation ended successful.
			///
			/// \param[in] dropTarget The item that is the nearest one from the mouse cursor's position. If
			///            the mouse cursor's position lies outside the control's client area, this parameter
			///            is \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa AbortedDrag, IListBox::EndDrag, HitTestConstants
			[id(DISPID_LBE_DROP), helpstring("Will be fired if a drag'n'drop operation ended successful.")]
			void Drop(IListBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>Any data associated with an item should be freed</em>
			///
			/// Will be fired if any data associated with the specified item should be freed.
			///
			/// \param[in] listItem The item for which to free the data. If \c Nothing, all items' data should
			///            be freed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all items freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingItem, RemovedItem, IListBoxItem::ItemData, IListBox::DisabledEvents
			[id(DISPID_LBE_FREEITEMDATA), helpstring("Will be fired if any data associated with the specified item should be freed. This event may be disabled.")]
			void FreeItemData(IListBoxItem* listItem);
			/// \brief <em>An item was inserted</em>
			///
			/// Will be fired after a new item was inserted.
			///
			/// \param[in] listItem The item that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingItem, RemovedItem, IListBoxItem, IListBox::DisabledEvents
			[id(DISPID_LBE_INSERTEDITEM), helpstring("Will be fired after a new item was inserted. This event may be disabled.")]
			void InsertedItem(IListBoxItem* listItem);
			/// \brief <em>An item is about to be inserted</em>
			///
			/// Will be fired before a new item is inserted.
			///
			/// \param[in] listItem The item that is about to be inserted. If the list box is sorted, this
			///            object's \c Index property may be wrong.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the item
			///                isn't inserted. If set to \c False, the item is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedItem, RemovingItem, IVirtualListBoxItem::Index, IListBox::Sorted,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_INSERTINGITEM), helpstring("Will be fired before a new item is inserted. This event may be disabled.")]
			void InsertingItem(IVirtualListBoxItem* listItem, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the left mouse button.
			///
			/// \param[in] listItem The item that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IListBox::BeginDrag, IListBox::OLEDrag, IListBox::AllowDragDrop, ItemBeginRDrag,
			///     HitTestConstants
			[id(DISPID_LBE_ITEMBEGINDRAG), helpstring("Will be fired if the user seems to want to drag an item using the left mouse button.")]
			void ItemBeginDrag(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag an item</em>
			///
			/// Will be fired if the user seems to want to drag an item using the right mouse button.
			///
			/// \param[in] treeItem The item that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IListBox::BeginDrag, IListBox::OLEDrag, IListBox::AllowDragDrop, ItemBeginDrag,
			///     HitTestConstants
			[id(DISPID_LBE_ITEMBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag an item using the right mouse button.")]
			void ItemBeginRDrag(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The value of an item's property is required</em>
			///
			/// Will be fired if an item's icon or overlay index is required.
			///
			/// \param[in] listItem The item that the value is required for.
			/// \param[in] requestedInfo Specifies which properties' values are required. Some combinations of
			///            the values defined by the \c RequestedInfoConstants enumeration are valid.
			/// \param[out] iconIndex Set this parameter to the zero-based index of the icon to use for the
			///             specified item. The icon is taken from the control's \c ilHighResolution image list.
			///             If the \c requestedInfo parameter doesn't include \c riIconIndex, this value is
			///             ignored.
			/// \param[out] overlayIndex Set this parameter to the zero-based index of the overlay icon to use
			///             for the specified item. The overlay icon is taken from the control's
			///             \c ilHighResolution image list. If the \c requestedInfo parameter doesn't include
			///             \c riOverlayIndex, this value is ignored.
			///
			/// \sa IListBox::hImageList, RequestedInfoConstants, ImageListConstants
			[id(DISPID_LBE_ITEMGETDISPLAYINFO), helpstring("Will be fired if an item's icon or overlay index is required.")]
			void ItemGetDisplayInfo(IListBoxItem* listItem, RequestedInfoConstants requestedInfo, LONG* IconIndex, LONG* OverlayIndex);
			/// \brief <em>The control is about to show the item's info tip and the text to display is required</em>
			///
			/// Will be fired if the control is about to popup a tooltip to display some information about the
			/// specified item and requests the text to display.
			///
			/// \param[in] listItem The item that the tooltip will be displayed for.
			/// \param[in] maxInfoTipLength The maximum number of characters the info tip text may consist of.
			/// \param[out] infoTipText Set this parameter to the text to display in the tooltip control.
			/// \param[in,out] abortToolTip If set to \c True, the tooltip won't be displayed.
			///
			/// \sa IListBox::ToolTips
			[id(DISPID_LBE_ITEMGETINFOTIPTEXT), helpstring("Will be fired if the control is about to popup a tooltip to display some information about the specified item and requests the text to display.")]
			void ItemGetInfoTipText(IListBoxItem* listItem, LONG maxInfoTipLength, BSTR* infoTipText, VARIANT_BOOL* abortToolTip);
			/// \brief <em>The mouse cursor was moved into an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle.
			///
			/// \param[in] listItem The item that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseLeave, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_ITEMMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseEnter(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of an item's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle.
			///
			/// \param[in] listItem The item that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ItemMouseEnter, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_ITEMMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified item's bounding rectangle. This event may be disabled.")]
			void ItemMouseLeave(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, ProcessKeyStroke, IListBox::DisabledEvents
			[id(DISPID_LBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, ProcessCharacterInput, IListBox::DisabledEvents
			[id(DISPID_LBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, ProcessKeyStroke, IListBox::DisabledEvents
			[id(DISPID_LBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] listItem The item that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] listItem The item that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>An item's size is required in an owner-drawn list box</em>
			///
			/// Will be fired if the \c OwnerDrawItems property is set to a value other than \c odiDontOwnerDraw
			/// and a list box item's size needs to be known in preparation of drawing it.
			///
			/// \param[in] listItem The item for which the size is required. If the list box is empty, this
			///            parameter will be \c Nothing.
			/// \param[out] itemHeight Must be set to the item's height in pixels.
			///
			/// \sa OwnerDrawItem, IListBox::ItemHeight, IListBoxItem::Height, IListBox::OwnerDrawItems
			[id(DISPID_LBE_MEASUREITEM), helpstring("Will be fired if the 'OwnerDrawItems' property is set to a value other than 'odiDontOwnerDraw' and a list box item's size needs to be known in preparation of drawing it.")]
			void MeasureItem(IListBoxItem* listItem, OLE_YSIZE_PIXELS* ItemHeight);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, ItemMouseEnter, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IListBox::HoverTime property.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IListBox::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, ItemMouseLeave, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, HitTestConstants,
			///     ExtendedMouseButtonConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] listItem The item that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
			///            in. Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, ScrollAxisConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta, HitTestConstants hitTestDetails);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa IListBox::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_LBE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in,out] dropTarget The item that is the target of the drag'n'drop operation. You may set
			///                this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IListBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, IListBox::SetInsertMarkPosition, IListBox::FinishOLEDragDrop,
			///     HitTestConstants
			[id(DISPID_LBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IListBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, IListBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, IListBox::DragScrollTimeBase, IListBox::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_LBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IListBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, IListBox::OLEDrag
			[id(DISPID_LBE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The item that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, IListBox::RegisterForOLEDragDrop,
			///     IListBox::SetInsertMarkPosition, HitTestConstants
			[id(DISPID_LBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IListBoxItem* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, IListBox::OLEDrag
			[id(DISPID_LBE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The item that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another item.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] yToItemTop The y-coordinate (in pixels) of the mouse cursor's position relative to the
			///            \c dropTarget item's upper border.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to 0,
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IListBox::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, IListBox::DragScrollTimeBase, IListBox::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_LBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IListBoxItem** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG yToItemTop, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa IListBox::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_LBE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa IListBox::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_LBE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_LBE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_LBE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa IListBox::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_LBE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>The control couldn't allocate enough memory</em>
			///
			/// Will be fired if the control cannot allocate enough memory to meet a specific request.
			[id(DISPID_LBE_OUTOFMEMORY), helpstring("Will be fired if the control cannot allocate enough memory to meet a specific request.")]
			void OutOfMemory(void);
			/// \brief <em>An item must be drawn in an owner-drawn list box</em>
			///
			/// Will be fired if the \c OwnerDrawItems property is set to a value other than \c odiDontOwnerDraw
			/// and a list box item must be drawn.
			///
			/// \param[in] listItem The item to draw. If the list box is empty, this parameter will be
			///            \c Nothing.
			/// \param[in] requiredAction Specifies the required drawing action. Any combination of the values
			///            defined by the \c OwnerDrawActionConstants enumeration is valid.
			/// \param[in] itemState Specifies the item's current state (focused, selected etc.). Most of
			///            the values defined by the \c OwnerDrawItemStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			///
			/// \sa MeasureItem, IListBox::ItemHeight, IListBoxItem::Height, IListBox::OwnerDrawItems, RECTANGLE,
			///     OwnerDrawActionConstants, OwnerDrawItemStateConstants
			[id(DISPID_LBE_OWNERDRAWITEM), helpstring("Will be fired if the 'OwnerDrawItems' property is set to a value other than 'odiDontOwnerDraw' and a list box item must be drawn.")]
			void OwnerDrawItem(IListBoxItem* listItem, OwnerDrawActionConstants requiredAction, OwnerDrawItemStateConstants itemState, LONG hDC, RECTANGLE* drawingRectangle);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus. This event may be used to customize item selection based on user input.
			///
			/// \param[in] keyAscii The pressed key's ASCII code.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[out] itemToSelect The zero-based index of the item to select. If set to -1, the default
			///             processing takes place. If set to -2, the control does not select any item, assuming
			///             that the client application already performed selection. Otherwise the item with
			///             the specified index gets selected.
			///
			/// \remarks This event is raised only for owner-drawn controls with \c HasStrings being set to
			///          \c False.\n
			///          This event may be disabled.
			///
			/// \sa ProcessKeyStroke, KeyDown, KeyPress, KeyUp, IListBox::HasStrings, IListBox::DisabledEvents
			[id(DISPID_LBE_PROCESSCHARACTERINPUT), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be used to customize item selection based on user input. This event may be disabled.")]
			void ProcessCharacterInput(SHORT keyAscii, SHORT shift, LONG* itemToSelect);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus. This event may be used
			/// to customize item selection based on user input.
			///
			/// \param[in] keyCode The pressed key. Any of the values defined by VB's \c KeyCodeConstants
			///            enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[out] itemToSelect The zero-based index of the item to select. If set to -1, the default
			///             processing takes place. If set to -2, the control does not select any item, assuming
			///             that the client application already performed selection. Otherwise the item with
			///             the specified index gets selected.
			///
			/// \remarks Current versions of Windows don't seem to handle a return value of -2 correctly, if the
			///          pressed key is a character.\n
			///          This event may be disabled.
			///
			/// \sa ProcessCharacterInput, KeyDown, KeyPress, KeyUp, IListBox::DisabledEvents
			[id(DISPID_LBE_PROCESSKEYSTROKE), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be used to customize item selection based on user input. This event may be disabled.")]
			void ProcessKeyStroke(SHORT keyCode, SHORT shift, LONG* itemToSelect);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] listItem The item that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] listItem The item that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IListBox::DisabledEvents
			[id(DISPID_LBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IListBox::hWnd
			[id(DISPID_LBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>An item was removed</em>
			///
			/// Will be fired after an item was removed.
			///
			/// \param[in] listItem The item that was removed. If \c Nothing, all items were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingItem, InsertedItem, IVirtualListBoxItem, IListBox::DisabledEvents
			[id(DISPID_LBE_REMOVEDITEM), helpstring("Will be fired after an item was removed. If 'listItem' is 'Nothing', all items were removed. This event may be disabled.")]
			void RemovedItem(IVirtualListBoxItem* listItem);
			/// \brief <em>An item is about to be removed</em>
			///
			/// Will be fired before an item is removed.
			///
			/// \param[in] listItem The item that is about to be removed. If \c Nothing, all items are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the item isn't
			///                removed. If set to \c False, the item is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedItem, InsertingItem, IListBoxItem, IListBox::DisabledEvents
			[id(DISPID_LBE_REMOVINGITEM), helpstring("Will be fired before an item is removed. If 'listItem' is 'Nothing', all items are removed. This event may be disabled.")]
			void RemovingItem(IListBoxItem* listItem, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_LBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The selection in the control might have changed</em>
			///
			/// Will be fired after the selection in the control might have changed.
			///
			/// \sa IListBoxItem::Selected, CaretChanged, IListBox::MultiSelect
			[id(DISPID_LBE_SELECTIONCHANGED), helpstring("Will be fired after the selection in the control might have changed.")]
			void SelectionChanged(void);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] listItem The item that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was clicked. Some of the values defined
			///            by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] listItem The item that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails The part of the control that was double-clicked. Some of the values
			///            defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IListBox::DisabledEvents
			[id(DISPID_LBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(IListBoxItem* listItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c ListBox class</em>
	///
	/// The control's main COM class. It implements the \c IListBox and
	/// \c _IListBoxEvents interfaces.
	///
	/// \sa IListBox, _IListBoxEvents
	[
		uuid(28A001A1-9A2A-499a-90B4-D1A0F653E759),
		version(1.5),
		helpstring("ListBox Control 1.5 (Unicode)")
	]
	coclass ListBox
	{
		[default] interface IListBox;
		[default, source] dispinterface _IListBoxEvents;
	};


	[
		uuid(037E3AC9-0C00-4fd0-80CD-8DB5ADA8E5C7),
		version(1.5),
		noncreatable,
		helpstring("CommonProperties Class 1.5 (Unicode)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};


	[
		uuid(D2F3F135-8189-455e-8BE1-9B305A0F85B8),
		version(1.5),
		noncreatable,
		helpstring("DriveTypeProperties Class 1.5 (Unicode)"),
		hidden
	]
	coclass DriveTypeProperties
	{
		[default] interface IUnknown;
	};


	[
		uuid(D708469A-DA06-4fc6-AADA-DE6B2E073013),
		version(1.5),
		noncreatable,
		helpstring("StringProperties Class 1.5 (Unicode)"),
		hidden
	]
	coclass StringProperties
	{
		[default] interface IUnknown;
	};
};
